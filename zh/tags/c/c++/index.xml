<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>C/C&#43;&#43; on AimerNeige&#39;s Blog</title>
    <link>https://aimerneige.com/zh/tags/c/c&#43;&#43;/</link>
    <description>Recent content in C/C&#43;&#43; on AimerNeige&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="https://aimerneige.com/zh/tags/c/c++/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>这不是 Bug，而是语言特性</title>
      <link>https://aimerneige.com/zh/post/this-is-not-bug/</link>
      <pubDate>Thu, 05 Nov 2020 14:37:41 +0800</pubDate>
      
      <guid>https://aimerneige.com/zh/post/this-is-not-bug/</guid>
      <description>C 语言中 goto 带来的奇怪问题</description>
    </item>
    
    <item>
      <title>C 函数指针</title>
      <link>https://aimerneige.com/zh/post/c-function-point/</link>
      <pubDate>Wed, 04 Nov 2020 21:00:39 +0800</pubDate>
      
      <guid>https://aimerneige.com/zh/post/c-function-point/</guid>
      <description>函数指针用法</description>
    </item>
    
    <item>
      <title>C 语言多线程基础</title>
      <link>https://aimerneige.com/zh/post/c-thread-basic/</link>
      <pubDate>Sun, 01 Nov 2020 18:21:23 +0800</pubDate>
      
      <guid>https://aimerneige.com/zh/post/c-thread-basic/</guid>
      <description>线程于进程的对比
          thread 线程 有共享内存   process 进程 没有共享内存    gcc file.c -lpthread 创建线程
#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;pthread.h&amp;gt; void *myfunc(void *args) { for (int i = 0; i &amp;lt; 50; i++) { printf(&amp;#34;%d\n&amp;#34;, i); } return NULL; } int main() { pthread_t th1; pthread_t th2; pthread_create(&amp;amp;th1, NULL, myfunc, NULL); pthread_create(&amp;amp;th2, NULL, myfunc, NULL); pthread_join(th1, NULL); pthread_join(th2, NULL); return 0; } 传入参数</description>
    </item>
    
    <item>
      <title>C 语言静态函数</title>
      <link>https://aimerneige.com/zh/post/c-static-function/</link>
      <pubDate>Sat, 31 Oct 2020 20:31:36 +0800</pubDate>
      
      <guid>https://aimerneige.com/zh/post/c-static-function/</guid>
      <description>在 C 语言中，函数默认是全局的。在函数前加“static”关键字可以使一个函数变成静态函数。例如，下面的函数 fun() 是静态的：
static int fun(void) { printf(&amp;#34;I am a static funciton.\n&amp;#34;); } 与 C 语言中的全局函数不同，对静态函数的访问仅限于声明它们的文件。因此，当我们想要限制函数的访问时，我们可以将函数定义为静态的。另外，如果我们想要在其他文件中使用相同的函数名，我们也可以将函数定义为静态的。
例如，我们在文件 file.c 中存储了下面的程序：
// in file `file1.c` #include &amp;lt;stdio.h&amp;gt; static void fun1() { printf(&amp;#34;fun1 called.\n&amp;#34;); } 然后，我们在文件 file2.c 中存储了这样的程序：
// in file `file2.c` #include &amp;lt;stdio.h&amp;gt; int main(void) { fun1(); return 0; } 接下来，如果我们按照如下的命令编译：
gcc file2.c file1.c 你会得到这样的链接错误：
undefined reference to `fun1&amp;#39; 这是因为 fun1() 函数在 file1.c 中被定义为静态，因而不能在 file2.c 中引用。</description>
    </item>
    
    <item>
      <title>GCC 基础</title>
      <link>https://aimerneige.com/zh/post/gcc-basic/</link>
      <pubDate>Sat, 17 Oct 2020 22:37:01 +0800</pubDate>
      
      <guid>https://aimerneige.com/zh/post/gcc-basic/</guid>
      <description>GCC 简介 GCC 是 Linux 下的编译工具集，是 GNU Compiler Collection 的缩写,包含 gcc 、 g++ 等编译器。这个工具集不仅包含编译器，还包含其他工具集，例如 ar 、 nm 等。
GCC 工具集不仅能编译 C/C++ 语言，其他例如 Objective-C 、 Pascal 、 Fortran 、 Java 、 Ada 等语言均能进行编译。
GCC 在可以根据不同的硬件平台进行编译，即能进行交叉编译，在 A 平台上编译 B 平台的程序，支持常见的 X86 、 ARM 、 PowerPC 、 mips 等，以及 Linux 、 Windows 等软件平台。
GCC 的 C 编译器 是 gcc，其命令格式为 :
Usage: gcc [options] file... GCC 下默认文扩展名的含义：
   文件扩展名 GCC 所理解的含义     *.</description>
    </item>
    
  </channel>
</rss>
