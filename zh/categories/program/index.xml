<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Program on AimerNeige&#39;s Blog</title>
    <link>https://aimerneige.com/zh/categories/program/</link>
    <description>Recent content in Program on AimerNeige&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 05 Nov 2020 14:37:41 +0800</lastBuildDate><atom:link href="https://aimerneige.com/zh/categories/program/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>这不是 Bug，而是语言特性</title>
      <link>https://aimerneige.com/zh/post/c/this-is-not-bug/</link>
      <pubDate>Thu, 05 Nov 2020 14:37:41 +0800</pubDate>
      
      <guid>https://aimerneige.com/zh/post/c/this-is-not-bug/</guid>
      <description>C 语言中 goto 带来的奇怪问题</description>
    </item>
    
    <item>
      <title>C 函数指针</title>
      <link>https://aimerneige.com/zh/post/c/c-function-point/</link>
      <pubDate>Wed, 04 Nov 2020 21:00:39 +0800</pubDate>
      
      <guid>https://aimerneige.com/zh/post/c/c-function-point/</guid>
      <description>函数指针用法</description>
    </item>
    
    <item>
      <title>C 语言多线程基础</title>
      <link>https://aimerneige.com/zh/post/c/c-thread-basic/</link>
      <pubDate>Sun, 01 Nov 2020 18:21:23 +0800</pubDate>
      
      <guid>https://aimerneige.com/zh/post/c/c-thread-basic/</guid>
      <description>线程于进程的对比
thread 线程 有共享内存 process 进程 没有共享内存 gcc file.c -lpthread 创建线程
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;pthread.h&amp;gt; void *myfunc(void *args) { for (int i = 0; i &amp;lt; 50; i++) { printf(&amp;#34;%d\n&amp;#34;, i); } return NULL; } int main() { pthread_t th1; pthread_t th2; pthread_create(&amp;amp;th1, NULL, myfunc, NULL); pthread_create(&amp;amp;th2, NULL, myfunc, NULL); pthread_join(th1, NULL); pthread_join(th2, NULL); return 0; } 传入参数
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;pthread.h&amp;gt; void *myfunc(void *args) { char *name = (char *)args; for (int i = 0; i &amp;lt; 50; i++) { printf(&amp;#34;%s %d\n&amp;#34;, name, i); } return NULL; } int main() { pthread_t th1; pthread_t th2; pthread_create(&amp;amp;th1, NULL, myfunc, &amp;#34;th1&amp;#34;); pthread_create(&amp;amp;th2, NULL, myfunc, &amp;#34;th2&amp;#34;); pthread_join(th1, NULL); pthread_join(th2, NULL); return 0; } 分部计算</description>
    </item>
    
    <item>
      <title>C 语言静态函数</title>
      <link>https://aimerneige.com/zh/post/c/c-static-function/</link>
      <pubDate>Sat, 31 Oct 2020 20:31:36 +0800</pubDate>
      
      <guid>https://aimerneige.com/zh/post/c/c-static-function/</guid>
      <description>在 C 语言中，函数默认是全局的。在函数前加“static”关键字可以使一个函数变成静态函数。例如，下面的函数 fun() 是静态的：
static int fun(void) { printf(&amp;#34;I am a static funciton.\n&amp;#34;); } 与 C 语言中的全局函数不同，对静态函数的访问仅限于声明它们的文件。因此，当我们想要限制函数的访问时，我们可以将函数定义为静态的。另外，如果我们想要在其他文件中使用相同的函数名，我们也可以将函数定义为静态的。
例如，我们在文件 file.c 中存储了下面的程序：
// in file `file1.c` #include &amp;lt;stdio.h&amp;gt; static void fun1() { printf(&amp;#34;fun1 called.\n&amp;#34;); } 然后，我们在文件 file2.c 中存储了这样的程序：
// in file `file2.c` #include &amp;lt;stdio.h&amp;gt; int main(void) { fun1(); return 0; } 接下来，如果我们按照如下的命令编译：
gcc file2.c file1.c 你会得到这样的链接错误：
undefined reference to `fun1&amp;#39; 这是因为 fun1() 函数在 file1.c 中被定义为静态，因而不能在 file2.c 中引用。</description>
    </item>
    
    <item>
      <title>面向小白的 C 语言随机数详解</title>
      <link>https://aimerneige.com/zh/post/c/c-random-number/</link>
      <pubDate>Fri, 24 Jan 2020 15:58:19 +0800</pubDate>
      
      <guid>https://aimerneige.com/zh/post/c/c-random-number/</guid>
      <description>函数指针用法</description>
    </item>
    
  </channel>
</rss>
