<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Program | Aimer's Blog</title>
<meta name=keywords content><meta name=description content><meta name=author content="Aimer Neige"><link rel=canonical href=https://aimerneige.com/zh/categories/program/><link crossorigin=anonymous href=/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css integrity="sha256-1vzSCk+4bvpN+sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as=style><link rel=icon href=https://aimerneige.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://aimerneige.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://aimerneige.com/favicon-32x32.png><link rel=apple-touch-icon href=https://aimerneige.com/apple-touch-icon.png><link rel=mask-icon href=https://aimerneige.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://aimerneige.com/zh/categories/program/index.xml><link rel=alternate hreflang=zh href=https://aimerneige.com/zh/categories/program/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://aimerneige.com/zh/categories/program/"><meta property="og:site_name" content="Aimer's Blog"><meta property="og:title" content="Program"><meta property="og:locale" content="zh"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Program"><meta name=twitter:description content></head><body class=list id=top><script>window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://aimerneige.com/zh/ accesskey=h title="Aimer's Blog (Alt + H)">Aimer's Blog</a><div class=logo-switches><ul class=lang-switch><li>|</li><li><a href=https://aimerneige.com/en/ title=English aria-label=English>English</a></li></ul></div></div><ul id=menu><li><a href=https://aimerneige.com/zh/about/ title=关于><span>关于</span></a></li><li><a href=https://aimerneige.com/zh/post/ title=文章><span>文章</span></a></li><li><a href=https://aimerneige.com/zh/archives/ title=归档><span>归档</span></a></li><li><a href=https://aimerneige.com/zh/tags/ title=标签><span>标签</span></a></li><li><a href=https://aimerneige.com/zh/categories/ title=分类><span>分类</span></a></li><li><a href=https://aimerneige.com/zh/search/ title=搜索><span>搜索</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://aimerneige.com/zh/>主页</a>&nbsp;»&nbsp;<a href=https://aimerneige.com/zh/categories/>分类 🤹‍♂️</a></div><h1>Program</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>这不是 Bug，而是语言特性</h2></header><div class=entry-content><p>今天遇到一个奇怪的问题：
一个 C 语言初学者写了这样的错误代码：
switch (a) { case1: // do something break; case2: // do something break; case3: // do something break; default: break; } 错误很容易解决，但是，在编译这样的程序时，编译器居然没有报错？？！！
那么 case1 case2 这些东西是哪里来的？
几番求证无果，最后在翻阅《C 专家编程》这本书的时候突然发现了原因：
首先像下面这样写是可以的：
switch (i) { case 5 + 3: do_again: case 2: printf("I loop unremittingly\n"); goto do_again; default: i++; case 3: ; } 这里定义了一个标签 do_again，并且通过 goto 跳转。
原错误代码中 case1 case2 等被编译器理解为了标签。
由于 goto 不被建议使用，博主居然已经忘记了标签和 goto 的用法。
不管怎么说，问题解决了。
这不是 Bug，而是 C 语言的特性。 #(滑稽)...</p></div><footer class=entry-footer><span title='2020-11-05 14:37:41 +0800 +0800'>十一月 5, 2020</span>&nbsp;·&nbsp;Aimer Neige</footer><a class=entry-link aria-label="post link to 这不是 Bug，而是语言特性" href=https://aimerneige.com/zh/post/c/this-is-not-bug/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>C 函数指针</h2></header><div class=entry-content><p>函数指针在大型的 C 语言项目中十分重要，但是学校对它的介绍一带而过，国内一些介绍函数指针的文章十分粗浅甚至存在错误（这里就不点名了），因此博主写了这篇文章介绍函数指针，希望能够帮助一些 C 语言学习者。
文章部分内容翻译引用于 https://www.geeksforgeeks.org/function-pointer-in-c/
函数指针的概念 类似变量，函数也会被分配一段存储空间，这段存储空间的首地址即被称做这个函数的地址。而且函数名表示的就是这个地址。既然是地址，我们就可以定义一个指针变量来存放，这个指针变量就叫做函数指针变量，简称函数指针。
函数指针的定义 下面的语句定义了一个指向函数的指针变量 p。其中 void *表示返回值，(*p) 表示 p 是一个指针变量， (int, float) 是函数的参数列表。
void *(*p) (int, float); 这样我们就得到了一个指针变量 p，它的类型为 void * (*)(int, float)
所以函数指针的定义方法为：
函数返回类型 (*指针变量名) (函数参数列表); 这里的函数参数列表类似函数声明，只需写出变量类型即可，并不需要定义变量。
即下面的俩种写法等价并且第二种写法中定义的变量并没有任何意义，建议使用第一种写法，不要使用第二种写法。
void *(*p) (int, float); void *(*p) (int a, float b); 如何对函数指针赋值 int Func(int x); // 函数的声明 int (*p) (int x); // 函数指针的定义 p = &amp;Func; // 函数指针的赋值 p = Func; // 另一种可行的写法 注：对于俩种赋值写法的详细说明见对函数赋值和调用的一些说明
函数指针的调用 #include &lt;stdio....</p></div><footer class=entry-footer><span title='2020-11-04 21:00:39 +0800 +0800'>十一月 4, 2020</span>&nbsp;·&nbsp;Aimer Neige</footer><a class=entry-link aria-label="post link to C 函数指针" href=https://aimerneige.com/zh/post/c/c-function-point/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>C 语言多线程基础</h2></header><div class=entry-content><p>线程于进程的对比
thread 线程 有共享内存 process 进程 没有共享内存 gcc file.c -lpthread 创建线程
#include &lt;stdio.h> #include &lt;pthread.h> void *myfunc(void *args) { for (int i = 0; i &lt; 50; i++) { printf("%d\n", i); } return NULL; } int main() { pthread_t th1; pthread_t th2; pthread_create(&amp;th1, NULL, myfunc, NULL); pthread_create(&amp;th2, NULL, myfunc, NULL); pthread_join(th1, NULL); pthread_join(th2, NULL); return 0; } 传入参数
#include &lt;stdio.h> #include &lt;pthread.h> void *myfunc(void *args) { char *name = (char *)args; for (int i = 0; i &lt; 50; i++) { printf("%s %d\n", name, i); } return NULL; } int main() { pthread_t th1; pthread_t th2; pthread_create(&amp;th1, NULL, myfunc, "th1"); pthread_create(&amp;th2, NULL, myfunc, "th2"); pthread_join(th1, NULL); pthread_join(th2, NULL); return 0; } 分部计算...</p></div><footer class=entry-footer><span title='2020-11-01 18:21:23 +0800 +0800'>十一月 1, 2020</span>&nbsp;·&nbsp;Aimer Neige</footer><a class=entry-link aria-label="post link to C 语言多线程基础" href=https://aimerneige.com/zh/post/c/c-thread-basic/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>C 语言静态函数</h2></header><div class=entry-content><p>在 C 语言中，函数默认是全局的。在函数前加“static”关键字可以使一个函数变成静态函数。例如，下面的函数 fun() 是静态的：
static int fun(void) { printf("I am a static funciton.\n"); } 与 C 语言中的全局函数不同，对静态函数的访问仅限于声明它们的文件。因此，当我们想要限制函数的访问时，我们可以将函数定义为静态的。另外，如果我们想要在其他文件中使用相同的函数名，我们也可以将函数定义为静态的。
例如，我们在文件 file.c 中存储了下面的程序：
// in file `file1.c` #include &lt;stdio.h> static void fun1() { printf("fun1 called.\n"); } 然后，我们在文件 file2.c 中存储了这样的程序：
// in file `file2.c` #include &lt;stdio.h> int main(void) { fun1(); return 0; } 接下来，如果我们按照如下的命令编译：
gcc file2.c file1.c 你会得到这样的链接错误：
undefined reference to `fun1' 这是因为 fun1() 函数在 file1.c 中被定义为静态，因而不能在 file2.c 中引用。</p></div><footer class=entry-footer><span title='2020-10-31 20:31:36 +0800 +0800'>十月 31, 2020</span>&nbsp;·&nbsp;Aimer Neige</footer><a class=entry-link aria-label="post link to C 语言静态函数" href=https://aimerneige.com/zh/post/c/c-static-function/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>面向小白的 C 语言随机数详解</h2></header><div class=entry-content><p>// 生成一系列0~9之间的随机整数 #include &lt;stdio.h> #include &lt;stdlib.h> #include &lt;time.h> int main() { srand( time(NULL) ); int ret; for (int i = 0; i &lt; 20; i++) { ret = rand() % 10; // ret是一个0~9之间的随机整数 printf("%d ", ret); } return 0; } 输出结果
7 6 6 1 6 9 2 7 1 8 2 0 5 9 2 5 4 0 0 0 这是啥啊？看不懂啊。 不要着急，我来慢慢讲 首先是一个最简单的随机数：
#include &lt;stdio.h> #include &lt;stdlib.h> int main() { int ret = rand(); printf("%d", ret); return 0; } 输出结果...</p></div><footer class=entry-footer><span title='2020-01-24 15:58:19 +0800 +0800'>一月 24, 2020</span>&nbsp;·&nbsp;Aimer Neige</footer><a class=entry-link aria-label="post link to 面向小白的 C 语言随机数详解" href=https://aimerneige.com/zh/post/c/c-random-number/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://aimerneige.com/zh/>Aimer's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script></body></html>