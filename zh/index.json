[{"content":"更新系统 # Debian apt update # Fedora dnf update 安装常用工具 # Debain apt install -y neofetch htop tree ncdu ranger zsh vim neovim git curl wget lsd # Fedora dnf install -y neofetch htop tree ncdu ranger zsh vim neovim git curl wget lsd 创建 sudo 用户 # Debian adduser aimerneige usermod -aG sudo aimerneige # Fedora useradd -G wheel aimerneige passwd aimerneige 测试 root 权限 su - aimerneige sudo cat /etc/shadow 配置 SSH 连接密钥 # 在你的本地环境执行这条指令 ssh-copy-id aimerneige@server 测试连通性 ssh aimerneige@server 禁用 root 和密码登录 sudo vim /etc/ssh/sshd_config  将 PermitRootLogin 修改为 no 可以禁用 root 用户登录 将 PasswordAuthentication 修改为 no 可以禁用密码登录  设置 sudo 免密码 sudo visudo 在末尾添加如下内容\naimerneige ALL=(ALL) NOPASSWD:ALL 删除云服务商提供的其他用户 sudo deluser default .notice{padding:18px;line-height:24px;margin-bottom:24px;border-radius:4px;color:#444;background:#e7f2fa}.notice p:last-child{margin-bottom:0}.notice-title{margin:-18px -18px 12px;padding:4px 18px;border-radius:4px 4px 0 0;font-weight:700;color:#fff;background:#6ab0de}.notice.warning .notice-title{background:rgba(217,83,79,.9)}.notice.warning{background:#fae2e2}.notice.info .notice-title{background:#f0b37e}.notice.info{background:#fff2db}.notice.note .notice-title{background:#6ab0de}.notice.note{background:#e7f2fA}.notice.tip .notice-title{background:rgba(92,184,92,.8)}.notice.tip{background:#e6f9e6}.icon-notice{display:inline-flex;align-self:center;margin-right:8px}.icon-notice img,.icon-notice svg{height:1em;width:1em;fill:currentColor}.icon-notice img,.icon-notice.baseline svg{top:0.125em;position:relative} Warning\n不要删除 root 用户。\n 重启服务器 sudo reboot 其他配置 配置 zsh 环境 # 安装 oh-my-zsh sh -c \u0026#34;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\u0026#34; # 从 github 更新配置 （使用你自己的配置文件！！！！！） sh -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/aimerneige/zsh/master/install.sh)\u0026#34; # 安装 zsh-autosuggestions git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions # 安装 k git clone https://github.com/supercrabtree/k $ZSH_CUSTOM/plugins/k # 安装 starship curl -sS https://starship.rs/install.sh | sh 配置 neovim rm -rf ~/.config/nvim # 使用你自己的配置文件！！！！！ git clone git@github.com:aimerneige/nvim.git ~/.config/nvim 参考链接  Best-practice for authentication after creating a new Linux server  ","permalink":"https://aimerneige.com/zh/post/devops/how-to-setup-your-new-linux-server/","summary":"更新系统 # Debian apt update # Fedora dnf update 安装常用工具 # Debain apt install -y neofetch htop tree ncdu ranger zsh vim neovim git curl wget lsd # Fedora dnf install -y neofetch htop tree ncdu ranger zsh vim neovim git curl wget lsd 创建 sudo 用户 # Debian adduser aimerneige usermod -aG sudo aimerneige # Fedora useradd -G wheel aimerneige passwd aimerneige 测试 root 权限 su - aimerneige sudo cat /etc/shadow 配置 SSH 连接密钥 # 在你的本地环境执行这条指令 ssh-copy-id aimerneige@server 测试连通性 ssh aimerneige@server 禁用 root 和密码登录 sudo vim /etc/ssh/sshd_config  将 PermitRootLogin 修改为 no 可以禁用 root 用户登录 将 PasswordAuthentication 修改为 no 可以禁用密码登录  设置 sudo 免密码 sudo visudo 在末尾添加如下内容","title":"如何配置新购置的 Linux 服务器"},{"content":"安装 wsl2 使用管理员身份开启 windows terminal.\n执行如下指令：\nwsl.exe --install 等待安装完成后在开始菜单执行重启(Restart)\n.notice{padding:18px;line-height:24px;margin-bottom:24px;border-radius:4px;color:#444;background:#e7f2fa}.notice p:last-child{margin-bottom:0}.notice-title{margin:-18px -18px 12px;padding:4px 18px;border-radius:4px 4px 0 0;font-weight:700;color:#fff;background:#6ab0de}.notice.warning .notice-title{background:rgba(217,83,79,.9)}.notice.warning{background:#fae2e2}.notice.info .notice-title{background:#f0b37e}.notice.info{background:#fff2db}.notice.note .notice-title{background:#6ab0de}.notice.note{background:#e7f2fA}.notice.tip .notice-title{background:rgba(92,184,92,.8)}.notice.tip{background:#e6f9e6}.icon-notice{display:inline-flex;align-self:center;margin-right:8px}.icon-notice img,.icon-notice svg{height:1em;width:1em;fill:currentColor}.icon-notice img,.icon-notice.baseline svg{top:0.125em;position:relative} Warning\n注意是在开始菜单选择 Restart 而不能是选择 Shut Down 关机之后手动开机。\n 安装过程中系统会自动下载 Ubuntu 的子系统，重启后会弹出 ubuntu 的命令行初始界面，输入用户名和密码即可开始使用 ubuntu 子系统。\n执行下面的指令设置 wsl 默认版本为 wsl2：\nwsl --set-default-version 2 安装其他版本的子系统 如果你想要其他版本的子系统，可以执行如下指令获取可通过 wsl 指令直接安装的发行版列表：\nwsl --list --online 返回数据类似下面这样：\nThe following is a list of valid distributions that can be installed. Install using \u0026#39;wsl --install -d \u0026lt;Distro\u0026gt;\u0026#39;.  NAME FRIENDLY NAME Ubuntu Ubuntu Debian Debian GNU/Linux kali-linux Kali Linux Rolling openSUSE-42 openSUSE Leap 42 SLES-12 SUSE Linux Enterprise Server v12 Ubuntu-16.04 Ubuntu 16.04 LTS Ubuntu-18.04 Ubuntu 18.04 LTS Ubuntu-20.04 Ubuntu 20.04 LTS 如果想要安装某发行版，直接执行相应指令即可。例如可以通过下面的指令安装 debian 子系统：\nwsl --install -d Debian 当你安装了多个发行版，可以通过下面的指令指定默认发行版：\nwsl --setdefault \u0026lt;Distro\u0026gt; 例如，设置 Kali-linux 为默认发行版：\nwsl --setdefault Kali-linux 安装 fedora 35 wsl 提供的发行版中，并不包含 fedora 系统，所以只能手动安装。\n下载 fedora 镜像文件(rootfs image) 在 Fedora-Container-Base 选择需要的 fedora 版本下载。\n在保证 State 一栏为 complete 的前提下找到需要的版本。\nFedora 35 build\n我们要下载的文件是 xz 格式，同时选择正确的架构，如 x86_64。\n(点击下面的链接直接下载)\nFedora-Container-Base-35-20220221.0.x86_64.tar.xz\n下载好之后解压这个压缩文件，如果你不知道用什么软件，下载使用 7-Zip。\nWarning\n注意，解压为 tar 文件即可，不要继续解压 tar 文件。\n 此时，查看你刚刚得到的 tar 文件，在里面找到一个名为 layer.tar 的文件，单独解压它，他就是我们需要的 rootfs image。把它解压到一个容易找到的位置，比如 Downloads 目录。为了便于使用，你可以将它重命名为 fedora-35-rootfs.tar。\n如果你想要一些更加官方的系统镜像，可以在 docker-brew-fedora 项目中找到你想要的文件。\n直接在 仓库 中找到对应的版本和架构后下载对应的文件即可。比如，你可能下载了 fedora-35-x86_64.tar.xz，下载完成后，解压这个文件，得到 tar 文件，这个 tar 文件就是 rootfs image。如果愿意，你也可以将它重命名为 fedora-35-rootfs.tar。\n创建你的 wsl 存储目录 创建一个文件夹来保存你的 wsl 文件。\nmkdir $HOME\\wsl\\fedora 释放镜像文件 假设你想要将子系统命名为 fedora，想要把它保存在 $HOME\\wsl\\fedora 目录下，同时 rootfs 文件存储在 $HOME\\Downloads\\fedora-35-rootfs.tar，执行下面的指令：\nwsl --import fedora $HOME\\wsl\\fedora $HOME\\Downloads\\fedora-35-rootfs.tar 检查安装情况 wsl -l 使用 root 启动 fedora 子系统： wsl -d fedora 设置 fedora 为默认发行版 wsl -s fedora 修复问题 Info\n注：以下问题是否存在取决于你下载的 fedora 版本，如果你没有对应错误直接跳过即可。\n 挂载错误 如果你在第一次启动 fedora 时得到了以下错误：\nAn error occurred mounting one of your file systems. Please run \u0026#39;dmesg\u0026#39; for more details. 这是由于系统缺少 mount 指令造成的，如果你不需要 mount 指令也不在意错误，完全可以忽略这个错误（虽然还是建议修一下）。\n安装 util-linux 这个包即可。（如果你是一个极简主义者，安装 util-linux-core 这个包）\ndnf install -y util-linux 安装完成后关闭 fedora 重启即可。\nwsl -t fedora 配置你的 fedora 升级系统 dnf update 创建用户 继续之前，先安装下面的包：\ndnf install -y passwd cracklib-dicts 在 wheel 用户组下创建名为 myusername 的用户\nuseradd -G wheel myusername 为用户 myusername 设置密码\npasswd myusername 使用指定用户登录 wsl\nwsl -d fedora -u myusername 查看是否成功\nwhoami 检查是否具有 sudo 权限\nsudo cat /etc/shadow 设置默认用户 首先你的系统必须是 Windows build 18980 之后的版本，只需要 修改 wsl 配置文件 即可。\n如果你没有创建过 /etc/wsl.conf 文件，直接执行如下指令：\nprintf \u0026#34;\\n[user]\\ndefault = myusername\\n\u0026#34; | sudo tee -a /etc/wsl.conf 或者手动添加下面内容到 /etc/wsl.conf：\n[user] default = myusername 关闭 fedora 子系统。\nwsl -t fedora 在不指定用户的情况下启动 fedora 子系统，检查用户是否正确。\n容器 如果你需要运行容器，重新安装 shadow-utils 确保修复一些 rootfs 带来的错误：\nsudo dnf reinstall -y shadow-utils ping 如果你想要执行 ping 指令，执行下面的操作：\nsudo dnf install -y procps-ng iputils sudo sysctl -w net.ipv4.ping_group_range=\u0026#34;0 2000\u0026#34; 常用指令 安装下面的包来启用 Linux 下常用指令：\nsudo dnf -y install iproute findutils ncurses initscripts 编辑器 安装必要的编辑器，你可以按照喜好选择 vim nano 或 micro。\nsudo dnf install -y vim man 继续之前首先要确保 nodocs 选项没有被开启，你可以手动编辑 tsflags=nodocs 这一行，也可以直接执行下面的指令：\ngrep -v nodocs /etc/dnf/dnf.conf | sudo tee /etc/dnf/dnf.conf 接下来安装 man\nsudo dnf install -y man man-pages 安装完成之后，在这之后安装的软件就可以使用 man 指令查看文档了，但是之前已经安装好的软件，并不能查看文档，比如现在执行 man dnf 就不会得到任何结果。需要执行 sudo dnf reinstall -y dnf 重新安装 dnf 之后，才可以正确查看相关文档。\n执行下面的指令重新安装全部的包：\nWarning\n这一步非常费时，如果你不常用 man 可以选择跳过。\n for pkg in $(dnf repoquery --installed --qf \u0026#34;%{name}\u0026#34;); do sudo dnf reinstall -qy $pkg; done 允许调用 Windows 的浏览器 首先安装 wslu\nsudo dnf copr enable wslutilities/wslu sudo dnf install wslu 添加如下配置\nexport BROWSER=wslview 导出系统 为了方便之后安装，可以将系统导出。\n首先清理掉缓存文件：\nsudo dnf clean all 使用下面的指令导出 fedora 子系统到 $HOME\\Downloads\\fedora-wsl.tar 目录下。\nwsl --export fedora $HOME\\Downloads\\fedora-wsl.tar 之后要使用的时候，可以使用下面的指令导入：\nmkdir $HOME\\wsl\\freshfedora wsl --import freshfedora $HOME\\wsl\\freshfedora $HOME\\Downloads\\fedora-wsl.tar wsl 常用指令 查看当前正在运行的子系统 wsl --list --running 关闭指定子系统 wsl --terminate \u0026lt;Distro\u0026gt; 例如关闭正在运行的 Ubuntu 子系统：\nwsl --terminate Ubuntu 关闭全部子系统 wsl --shutdown 升级 wsl wsl --update 版本回滚 wsl --update --rollback 删除子系统 wsl --unregister \u0026lt;Distro\u0026gt; wsl 使用技巧 在文件资源管理器中输入 \\\\wsl$ 即可进入 wsl 的目录。可以将它添加到文件资源管理器的网络路径里便于访问。\n参考  Install Fedora 36 or earlier on Windows Subsystem for Linux (WSL)\n ","permalink":"https://aimerneige.com/zh/post/others/install-fedora35-on-wsl/","summary":"安装 wsl2 使用管理员身份开启 windows terminal.\n执行如下指令：\nwsl.exe --install 等待安装完成后在开始菜单执行重启(Restart)\n.notice{padding:18px;line-height:24px;margin-bottom:24px;border-radius:4px;color:#444;background:#e7f2fa}.notice p:last-child{margin-bottom:0}.notice-title{margin:-18px -18px 12px;padding:4px 18px;border-radius:4px 4px 0 0;font-weight:700;color:#fff;background:#6ab0de}.notice.warning .notice-title{background:rgba(217,83,79,.9)}.notice.warning{background:#fae2e2}.notice.info .notice-title{background:#f0b37e}.notice.info{background:#fff2db}.notice.note .notice-title{background:#6ab0de}.notice.note{background:#e7f2fA}.notice.tip .notice-title{background:rgba(92,184,92,.8)}.notice.tip{background:#e6f9e6}.icon-notice{display:inline-flex;align-self:center;margin-right:8px}.icon-notice img,.icon-notice svg{height:1em;width:1em;fill:currentColor}.icon-notice img,.icon-notice.baseline svg{top:0.125em;position:relative} Warning\n注意是在开始菜单选择 Restart 而不能是选择 Shut Down 关机之后手动开机。\n 安装过程中系统会自动下载 Ubuntu 的子系统，重启后会弹出 ubuntu 的命令行初始界面，输入用户名和密码即可开始使用 ubuntu 子系统。\n执行下面的指令设置 wsl 默认版本为 wsl2：\nwsl --set-default-version 2 安装其他版本的子系统 如果你想要其他版本的子系统，可以执行如下指令获取可通过 wsl 指令直接安装的发行版列表：\nwsl --list --online 返回数据类似下面这样：\nThe following is a list of valid distributions that can be installed. Install using \u0026#39;wsl --install -d \u0026lt;Distro\u0026gt;\u0026#39;.","title":"在 wsl 下安装 fedora 35"},{"content":"什么是 find 正如它的名字一样，find 指令用于查找文件。\n Linux find 命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则 find 命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。\n来源: 菜鸟教程\n  The find command in UNIX is a command line utility for walking a file hierarchy. It can be used to find files and directories and perform subsequent operations on them. It supports searching by file, folder, name, creation date, modification date, owner and permissions. By using the ‘-exec’ other UNIX commands can be executed on files or folders found.\nFrom: Geeks for Geeks\n 基础语法 find [options] [path...] [expression]   The options attribute controls the treatment of the symbolic links, debugging options, and optimization method. The path... attribute defines the starting directory or directories where find will search the files. The expression attribute is made up of options, search patterns, and actions separated by operators.  From: Linuxize\n [options] options 属性用于控制一些额外选项。\n.notice{padding:18px;line-height:24px;margin-bottom:24px;border-radius:4px;color:#444;background:#e7f2fa}.notice p:last-child{margin-bottom:0}.notice-title{margin:-18px -18px 12px;padding:4px 18px;border-radius:4px 4px 0 0;font-weight:700;color:#fff;background:#6ab0de}.notice.warning .notice-title{background:rgba(217,83,79,.9)}.notice.warning{background:#fae2e2}.notice.info .notice-title{background:#f0b37e}.notice.info{background:#fff2db}.notice.note .notice-title{background:#6ab0de}.notice.note{background:#e7f2fA}.notice.tip .notice-title{background:rgba(92,184,92,.8)}.notice.tip{background:#e6f9e6}.icon-notice{display:inline-flex;align-self:center;margin-right:8px}.icon-notice img,.icon-notice svg{height:1em;width:1em;fill:currentColor}.icon-notice img,.icon-notice.baseline svg{top:0.125em;position:relative} Note\n如果查询 man find，会得到这样一份语法说明:\nfind [-H] [-L] [-P] [-D debugopts] [-Olevel] [starting-point...] [expression] 本文将 [-H] [-L] [-P] [-D debugopts] [-Olevel] 这一部分抽象成了 options\n -H, -L and -P 用于控制对 symbolic link 的处理方法。\n[-D debugopts] 用于控制调试功能。\n[-Olevel] 用于控制优化方法。\n.heimu {color: black;background-color: black;}.heimu:hover {color: white;} 具体细节查 man 吧，这块也不常用，有空补。  [path\u0026hellip;] path 即开始查找的根目录。\n使用 find 时，这里可以是一个目录，也可以是多个目录。\nWarning\n用户必须有对应目录的读权限才可以正常执行，否则会返回错误信息。\n [expression] 包含各种选项，搜索模式和操作。比如可以指定文件名，文件大小，修改日期等选项来过滤查找内容。\n使用样例 搜索当前目录下全部名称为 avatar 的文件或文件夹 find . -name \u0026#34;avatar\u0026#34; 搜索当前目录下所有 go 源代码文件 find . -name \u0026#34;*.go\u0026#34; -type f Note\n如果没有 -type f，输出结果可能包含有以 *.go 结尾的文件夹。\n 查找最近 20 天内更新过的文件 find . -ctime -20 只搜索当前目录下的文件和文件夹而不递归搜索 find . -maxdepth 1 Warning\n-maxdepth 作为全局选项应该位于其他选项的前面。\n# 正确的做法 find . -maxdepth 1 -name \u0026#34;*avatar*\u0026#34; # 不当的做法（会有警告） find . -name \u0026#34;*avatar*\u0026#34; -maxdepth 1  删除当前目录下名为 temp 的文件 # 直接删 find . -type f -name \u0026#34;temp\u0026#34; -delete # 打印一下删了哪些文件 find . -type f -name \u0026#34;temp\u0026#34; -delete -print # 为了防止删错，还是确认一下吧 find . -type f -name \u0026#34;temp\u0026#34; -ok rm {} \\; 查找一下七天前的旧日志，并在删除之前询问它们 find ./log -type f -mtime +7 -ok rm {} \\; 查找指定目录下有哪些空文件 # 打印文件名 find /home/aimerneige /root -type f -size 0 # 调用 ls 看一下文件属性吧 find /home/aimerneige /root -type f -size 0 -exec ls -l {} \\; 查找当前目录下指定大小范围内的文件 # 大于 200k find . -type f -size +200k # 小于200k find . -type f -size -200k # 在 50k 与 200k 之间 find . -type f -size +50k -200k 查找全部 ntfs 硬盘中拷贝出的文件 # 查找权限为 777 的文件，并打印详细信息 find . -type f -perm 777 -exec ls -l {} \\; # 777 太讨厌了，权限改为默认的 664 find . -type f -perm 777 -exec chmod 664 {} \\; 看一下当前目录下文件占用情况 find . -type d -exec du -sh {} \\; 批量添加文件后缀 find . -type f -name \u0026#34;*.JPG\u0026#34; -exec mv {} {}.jpg \\; 使用 bat 查看当前目录下全部 go 源代码 find . -type f -name \u0026#34;*.go\u0026#34; -exec bat {} \\; 使用技巧 当搜索目标路径为当前目录.时，可以省略不写 find -type f -name \u0026#34;*.go\u0026#34; # 上面的指令和下面的等价 find . -type f -name \u0026#34;*.go\u0026#34; 当结果过多时，使用 xargs 代替 -exec find ~ -type f -name \u0026#34;*.cpp\u0026#34; -exec ls -l {} \\; exec 的原理是将查找结果一次性发送到后面的命令当中，如果结果过多会导致数据溢出而报错。\n使用管道以及 xargs 来避免这个问题：\nfind ~ -type f -name \u0026#34;*.cpp\u0026#34; | xargs ls -l 结果太多了不好看，我们把结果输出到一个文件里面。\nfind ~ -type f -name \u0026#34;*.cpp\u0026#34; | xargs ls -l \u0026gt; ./result.txt ","permalink":"https://aimerneige.com/zh/post/linux/basic-usage-of-find/","summary":"什么是 find 正如它的名字一样，find 指令用于查找文件。\n Linux find 命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则 find 命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。\n来源: 菜鸟教程\n  The find command in UNIX is a command line utility for walking a file hierarchy. It can be used to find files and directories and perform subsequent operations on them. It supports searching by file, folder, name, creation date, modification date, owner and permissions. By using the ‘-exec’ other UNIX commands can be executed on files or folders found.","title":"find 指令的基本用法"},{"content":"前言 毫无疑问，idea 是最好的 Java IDE 之一，它对 Spring 也有很好的支持，但是由于某高校的 JetBrains 授权被拉入黑名单，导致我无法继续使用正版授权，虽然可以通过给 JetBrains 写邮件，证明自己高校学生的身份后继续获取授权，但是实在是懒，而且我也不是很喜欢使用 IDE，于是就就打算使用 vscode 进行开发。\nVisual Studio Code 作为一款优秀的代码编辑器，有非常多的插件，经过配置后完全可以胜任大部分 IDE 的功能，本文章简要介绍如何构建 spring 的开发环境。\n配置 安装配置 Java 和 Maven .notice{padding:18px;line-height:24px;margin-bottom:24px;border-radius:4px;color:#444;background:#e7f2fa}.notice p:last-child{margin-bottom:0}.notice-title{margin:-18px -18px 12px;padding:4px 18px;border-radius:4px 4px 0 0;font-weight:700;color:#fff;background:#6ab0de}.notice.warning .notice-title{background:rgba(217,83,79,.9)}.notice.warning{background:#fae2e2}.notice.info .notice-title{background:#f0b37e}.notice.info{background:#fff2db}.notice.note .notice-title{background:#6ab0de}.notice.note{background:#e7f2fA}.notice.tip .notice-title{background:rgba(92,184,92,.8)}.notice.tip{background:#e6f9e6}.icon-notice{display:inline-flex;align-self:center;margin-right:8px}.icon-notice img,.icon-notice svg{height:1em;width:1em;fill:currentColor}.icon-notice img,.icon-notice.baseline svg{top:0.125em;position:relative} Tip\n正常流程配置 Java 和 Maven，如果你已经配置过可以直接跳过\n  下载所需的 JDK 并解压。 在环境变量中配置 JAVA_HOME 在系统环境变量 PATH 中添加 JAVA_HOME/bin 下载 Maven 并解压 在环境变量中配置 MAVEN_HOME 在系统环境变量 PATH 中添加 MAVEN_HOME/bin  安装必要插件  Extension Pack For Java Gradle Extension Pack Spring Boot Extension Pack SonarLint Java Code Generators XML Dependency Analytics  在 settings.json 中简单配置 {  \u0026#34;sonarlint.ls.javaHome\u0026#34;: \u0026#34;/home/aimerneige/.jdks/openjdk-17.0.1\u0026#34;,  \u0026#34;java.configuration.runtimes\u0026#34;: [  {  \u0026#34;name\u0026#34;: \u0026#34;JavaSE-17\u0026#34;,  \u0026#34;path\u0026#34;: \u0026#34;/home/aimerneige/.jdks/openjdk-17.0.1\u0026#34;,  \u0026#34;default\u0026#34;: true  },  {  \u0026#34;name\u0026#34;: \u0026#34;JavaSE-11\u0026#34;,  \u0026#34;path\u0026#34;: \u0026#34;/home/aimerneige/.jdks/corretto-11.0.13\u0026#34;  },  {  \u0026#34;name\u0026#34;: \u0026#34;JavaSE-1.8\u0026#34;,  \u0026#34;path\u0026#34;: \u0026#34;/home/aimerneige/.jdks/corretto-1.8.0_312\u0026#34;  }  ],  \u0026#34;spring.initializr.defaultLanguage\u0026#34;: \u0026#34;Java\u0026#34;,  \u0026#34;spring.initializr.defaultJavaVersion\u0026#34;: \u0026#34;8\u0026#34;,  \u0026#34;spring.initializr.defaultArtifactId\u0026#34;: \u0026#34;demo\u0026#34;,  \u0026#34;spring.initializr.defaultGroupId\u0026#34;: \u0026#34;com.aimerneige\u0026#34;,  \u0026#34;spring.initializr.serviceUrl\u0026#34;: [  \u0026#34;https://start.spring.io\u0026#34;  ],  \u0026#34;spring.initializr.defaultPackaging\u0026#34;: \u0026#34;JAR\u0026#34;,  \u0026#34;spring.initializr.defaultOpenProjectMethod\u0026#34;: \u0026#34;Open\u0026#34; } 以上配置的具体功能可以自行查看插件的官方文档\n创建新项目 通过 Ctrl + Shift + P 快捷键，输入指令 Spring Initializr 后选择创建 Gradle 或 Maven 项目，按照指引完成新项目的创建。\n","permalink":"https://aimerneige.com/zh/post/program/java/start-develop-spring-project-on-vscode/","summary":"前言 毫无疑问，idea 是最好的 Java IDE 之一，它对 Spring 也有很好的支持，但是由于某高校的 JetBrains 授权被拉入黑名单，导致我无法继续使用正版授权，虽然可以通过给 JetBrains 写邮件，证明自己高校学生的身份后继续获取授权，但是实在是懒，而且我也不是很喜欢使用 IDE，于是就就打算使用 vscode 进行开发。\nVisual Studio Code 作为一款优秀的代码编辑器，有非常多的插件，经过配置后完全可以胜任大部分 IDE 的功能，本文章简要介绍如何构建 spring 的开发环境。\n配置 安装配置 Java 和 Maven .notice{padding:18px;line-height:24px;margin-bottom:24px;border-radius:4px;color:#444;background:#e7f2fa}.notice p:last-child{margin-bottom:0}.notice-title{margin:-18px -18px 12px;padding:4px 18px;border-radius:4px 4px 0 0;font-weight:700;color:#fff;background:#6ab0de}.notice.warning .notice-title{background:rgba(217,83,79,.9)}.notice.warning{background:#fae2e2}.notice.info .notice-title{background:#f0b37e}.notice.info{background:#fff2db}.notice.note .notice-title{background:#6ab0de}.notice.note{background:#e7f2fA}.notice.tip .notice-title{background:rgba(92,184,92,.8)}.notice.tip{background:#e6f9e6}.icon-notice{display:inline-flex;align-self:center;margin-right:8px}.icon-notice img,.icon-notice svg{height:1em;width:1em;fill:currentColor}.icon-notice img,.icon-notice.baseline svg{top:0.125em;position:relative} Tip\n正常流程配置 Java 和 Maven，如果你已经配置过可以直接跳过\n  下载所需的 JDK 并解压。 在环境变量中配置 JAVA_HOME 在系统环境变量 PATH 中添加 JAVA_HOME/bin 下载 Maven 并解压 在环境变量中配置 MAVEN_HOME 在系统环境变量 PATH 中添加 MAVEN_HOME/bin  安装必要插件  Extension Pack For Java Gradle Extension Pack Spring Boot Extension Pack SonarLint Java Code Generators XML Dependency Analytics  在 settings.","title":"使用 vscode 开发 Spring 项目"},{"content":" 由于某些网络原因1，本文所提到的部分网站、下载链接可能在中国大陆地区无法访问，请自行查找解决方案，本文不再赘述。\n  如果你在阅读本文时遇到了任何问题，请查阅 go 语言官方网站。\n 下载预编译文件 在 Download Go 选择适合你平台的最新版本文件下载。\n本文不推荐使用一键安装包的方式安装 go 语言，即请不要直接下载下图所示的文件:\n我们在下面的 Stable versions 后找到最新版本的 go，选择适合自己电脑系统与架构的压缩包。要选择 Archive　而不要选择 Installer。\n.notice{padding:18px;line-height:24px;margin-bottom:24px;border-radius:4px;color:#444;background:#e7f2fa}.notice p:last-child{margin-bottom:0}.notice-title{margin:-18px -18px 12px;padding:4px 18px;border-radius:4px 4px 0 0;font-weight:700;color:#fff;background:#6ab0de}.notice.warning .notice-title{background:rgba(217,83,79,.9)}.notice.warning{background:#fae2e2}.notice.info .notice-title{background:#f0b37e}.notice.info{background:#fff2db}.notice.note .notice-title{background:#6ab0de}.notice.note{background:#e7f2fA}.notice.tip .notice-title{background:rgba(92,184,92,.8)}.notice.tip{background:#e6f9e6}.icon-notice{display:inline-flex;align-self:center;margin-right:8px}.icon-notice img,.icon-notice svg{height:1em;width:1em;fill:currentColor}.icon-notice img,.icon-notice.baseline svg{top:0.125em;position:relative} Tip\n当然使用 msi 等一键安装包安装也是完全可以的，如果你想要使用一键安装包的方式安装 go，请查阅其他资料。\n  如果你想要通过源码安装，请自行查阅 通过源码构建。\n 安装 \u0026amp; 配置 下面分别具体说明不同平台下安装和配置的方法。\nLinux  解压压缩文件  这里我们可以直接使用 官方安装指南 提供的指令来解压。\nrm -rf /usr/local/go \u0026amp;\u0026amp; tar -C /usr/local -xzf go1.17.linux-amd64.tar.gz 本指令会将 go 安装在 /usr/local/go 路径下，因此执行命令需要 root 权限。当然，如果想要将 go 安装在其他路径也是可以的，但是还是推荐安装在官方推荐的路径下。\nInfo\n如果你使用了其他的路径来安装 go，在之后的配置过程中记得要修改 GOROOT 变量修改为你所安装的路径。\n 执行命令前请先切换工作目录，确保当前路径下有刚刚下载好的压缩包。\nWarning\n压缩包名 go1.17.linux-amd64.tar.gz 可能有所不同，这取决于你安装的 go 版本和操作系统及处理器架构。\n  配置环境变量  成功解压后，如果你尝试直接在终端执行 go 指令，你会发现系统并没有识别到你刚安装的 go 二进制文件，这是因为我们还没有对 go 的环境变量进行配置。\n根据你所使用的不同的 shell，直接修改对应的配置文件，写入如下内容即可。\n例如在 bash 下要修改 ~/.bashrc，而在 zsh 下则需要修改 ~/.zshrc。\nexport GOROOT=/usr/local/go export GOPATH=$HOME/golang export PATH=$GOROOT/bin:$PATH export PATH=$GOPATH/bin:$PATH export GO111MODULE=on # export GOPROXY=https://goproxy.cn  export GOROOT=/usr/local/go 为 go 的安装目录，即之前的解压路径。 export GOPATH=$HOME/golang 为 go 的工作区目录，所有的源代码、代码包等会存放在这里，可以自己定义。 export PATH=$GOROOT/bin:$PATH 与 export PATH=$GOPATH/bin:$PATH 将可执行文件目录添加到环境变量。不需要修改。 export GO111MODULE=on 启用 GO111MODULE。建议启用。 export GOPROXY=https://goproxy.cn 使用 goproxy.cn 提供的代理服务，如果你有其他的代理服务可以注释掉它。  Tip\n上面的安装方式只有家目录对应的用户可以使用 go 指令，如果你想要全局注册，修改 /etc/profile 文件。\n 完成修改后，使用 source 指令应用更改，之后 go 就配置好了。\nWarning\n使用 source 指令时还要指定文件，如果你在使用 bash，修改了 ~/.bashrc，那么要执行 source ~/.bashrc，同理，可得使用 zsh，修改了 ~/.zshrc 需要执行 source ~/.zshrc。\n 不会真的有 Linux 小白只执行 source 吧，不会吧，不会吧。\n 可以在终端下查看 go env 指令是否有输出检查 go 是否可用。\nmac OS 与 Linux 类似，下载好压缩文件后将其解压，修改配置即可。\nNote\n在 macOS 下默认安装了 zsh，你可以直接修改 ~/.zshrc，如果你想要全局配置，修改 /etc/profile。\n Windows 首先解压下载好的压缩文件，记住自己解压的位置。一般地，我会将 go 安装在 C:\\sdk\\go 下。\n配置环境变量\nWarning\n下文中提到的 GOROOT GOPATH 等要按照自己的需求更改，不可直接复制。\n  打开“开始”并搜索“env” 选择“编辑系统环境变量” 点击“环境变量…”按钮 在“\u0026lt;你的用户名\u0026gt; 的用户变量”章节下（上半部分） 配置 GOROOT 点击“新建…”按钮 选择“变量名”输入框并输入“GOROOT” 选择“变量值”输入框并输入“C:\\sdk\\go” 点击“确定”按钮 配置 GOPATH 点击“新建…”按钮 选择“变量名”输入框并输入“GOPATH” 选择“变量值”输入框并输入“D:\\Code\\golang” 点击“确定”按钮 启用 GO111MODULE 点击“新建…”按钮 选择“变量名”输入框并输入“GO111MODULE” 选择“变量值”输入框并输入“on” 点击“确定”按钮 启用代理服务 点击“新建…”按钮 选择“变量名”输入框并输入“GOPROXY” 选择“变量值”输入框并输入“https://goproxy.cn” 点击“确定”按钮  最后记得把 %GOROOT%\\bin 和 %GOPATH%\\bin 添加进环境变量。\n检查 go env 的输出，验证安装是否成功。\n如何更新 go 重新执行之前的解压指令即可。即先删除 GOROOT 路径下所有文件，然后重新解压新版的 go 压缩文件。\n如果你在使用 Windows，删除后手动解压。\n  https://en.wikipedia.org/wiki/Great_Firewall\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"https://aimerneige.com/zh/post/program/go/go-env-setup-for-beginner/","summary":"由于某些网络原因1，本文所提到的部分网站、下载链接可能在中国大陆地区无法访问，请自行查找解决方案，本文不再赘述。\n  如果你在阅读本文时遇到了任何问题，请查阅 go 语言官方网站。\n 下载预编译文件 在 Download Go 选择适合你平台的最新版本文件下载。\n本文不推荐使用一键安装包的方式安装 go 语言，即请不要直接下载下图所示的文件:\n我们在下面的 Stable versions 后找到最新版本的 go，选择适合自己电脑系统与架构的压缩包。要选择 Archive　而不要选择 Installer。\n.notice{padding:18px;line-height:24px;margin-bottom:24px;border-radius:4px;color:#444;background:#e7f2fa}.notice p:last-child{margin-bottom:0}.notice-title{margin:-18px -18px 12px;padding:4px 18px;border-radius:4px 4px 0 0;font-weight:700;color:#fff;background:#6ab0de}.notice.warning .notice-title{background:rgba(217,83,79,.9)}.notice.warning{background:#fae2e2}.notice.info .notice-title{background:#f0b37e}.notice.info{background:#fff2db}.notice.note .notice-title{background:#6ab0de}.notice.note{background:#e7f2fA}.notice.tip .notice-title{background:rgba(92,184,92,.8)}.notice.tip{background:#e6f9e6}.icon-notice{display:inline-flex;align-self:center;margin-right:8px}.icon-notice img,.icon-notice svg{height:1em;width:1em;fill:currentColor}.icon-notice img,.icon-notice.baseline svg{top:0.125em;position:relative} Tip\n当然使用 msi 等一键安装包安装也是完全可以的，如果你想要使用一键安装包的方式安装 go，请查阅其他资料。\n  如果你想要通过源码安装，请自行查阅 通过源码构建。\n 安装 \u0026amp; 配置 下面分别具体说明不同平台下安装和配置的方法。\nLinux  解压压缩文件  这里我们可以直接使用 官方安装指南 提供的指令来解压。\nrm -rf /usr/local/go \u0026amp;\u0026amp; tar -C /usr/local -xzf go1.17.linux-amd64.tar.gz 本指令会将 go 安装在 /usr/local/go 路径下，因此执行命令需要 root 权限。当然，如果想要将 go 安装在其他路径也是可以的，但是还是推荐安装在官方推荐的路径下。","title":"配置 go 开发环境"},{"content":"今天学校不知道哪搞了个平台，让我们去上面做模拟实验，我点开一看，好嘛，没啥用的机器人、电焊，继续看下去还有题目，又懒得上网查答案，但是学校给的通知里有一行话引起了我的注意:\n 温馨提示:需要从实验空间进入实验,不可直接输入网址进入\n 不可直接输入网址？我仔细看了下，发现实验空间的作用就是添加一个 token，如果直接进去就是游客，没有办法登录。\n这下就好办了啊，虽然是游客，但是游客也可以做题啊，我用游客帐号先做了不就拿到答案了吗？\n这个系统果然把正确答案显示在前端了，但是不太好看，于是我就跑去 F12 看了。\n结果我在后台找到了下面的代码:\n$.ajax({ \turl: \u0026#34;/webApi/experimen/rig/getData\u0026#34;, \ttype: \u0026#34;GET\u0026#34;, \tdata: { courseId: courseId }, \tdataType: \u0026#34;JSON\u0026#34;, \tsuccess: function (res) {   // 省略的大量代码逻辑   })；  下面的注释是原来就有，不是我加的。\n对，这个系统没有对 js 做混淆甚至在代码里有详细的注释。\n // 单选 var answer = $(\u0026#39;.afterTesting .topic1 form\u0026#39;); for (var k = 0; k \u0026lt; answer.length; k++) {  var question1 = $(answer[k]).find(\u0026#34;.question1\u0026#34;);  var questionAnswer = question1.attr(\u0026#34;data-answer\u0026#34;);  var userAnswer = question1.find(\u0026#34;input[type=\u0026#39;radio\u0026#39;]:checked\u0026#34;).val();  var score = parseFloat(question1.attr(\u0026#34;data-score\u0026#34;));  if (questionAnswer.length \u0026gt; 1) {  var userdAnswer = question1.find(\u0026#34;input[type=\u0026#39;checkbox\u0026#39;]:checked\u0026#34;);  let userdAnswerStr = \u0026#39;\u0026#39;;  for (let i = 0; i \u0026lt; userdAnswer.length; i++) {  userdAnswerStr += $(userdAnswer[i]).val();  //console.log($(userdAnswer[i]).val());  }  //console.log(userdAnswerStr);  userAnswer = userdAnswerStr  }  var isok = \u0026#34;\u0026#34;;  if (questionAnswer == userAnswer) {  isok = \u0026#34;正确\u0026#34;;  question1.find(\u0026#34;.countItem span\u0026#34;).html(score);  resultafter += score  } else {  isok = \u0026#34;错误\u0026#34;;  question1.find(\u0026#34;.countItem span\u0026#34;).html(\u0026#34;0\u0026#34;); \t} \tquestion1.find(\u0026#34;.yourAnswer span\u0026#34;).html(isok); } 好家伙，前端直接向后台发请求拿答案数据，然后判断对错？这就好比考试的时候老师把答案和试卷都给你，让你自己写完试卷自己评分。\n直接发一个请求过去，果然拿到答案了。\n数据示例:\n{  \u0026#34;id\u0026#34;: \u0026#34;570239720236388352\u0026#34;,  \u0026#34;courseId\u0026#34;: null,  \u0026#34;title\u0026#34;: \u0026#34;07、机器人的运动速度与摇杆的偏转量 （）\u0026#34;,  \u0026#34;optionA\u0026#34;: \u0026#34;A、正比 \u0026#34;,  \u0026#34;optionB\u0026#34;: \u0026#34;B、反比 \u0026#34;,  \u0026#34;optionC\u0026#34;: \u0026#34;C、不成比例 \u0026#34;,  \u0026#34;optionD\u0026#34;: \u0026#34;D、以上均不正确\u0026#34;,  \u0026#34;optionE\u0026#34;: \u0026#34;\u0026#34;,  \u0026#34;optionF\u0026#34;: \u0026#34;\u0026#34;,  \u0026#34;optionG\u0026#34;: \u0026#34;\u0026#34;,  \u0026#34;optionH\u0026#34;: \u0026#34;\u0026#34;,  \u0026#34;answer\u0026#34;: \u0026#34;A\u0026#34;,  \u0026#34;tag\u0026#34;: \u0026#34;\u0026#34;,  \u0026#34;analysis\u0026#34;: \u0026#34;\u0026#34;,  \u0026#34;remarks\u0026#34;: \u0026#34;\u0026#34;,  \u0026#34;content\u0026#34;: \u0026#34;\u0026#34;,  \u0026#34;score\u0026#34;: 3.0,  \u0026#34;pid\u0026#34;: \u0026#34;550581359601651712_before\u0026#34;,  \u0026#34;countOfRow\u0026#34;: null } ","permalink":"https://aimerneige.com/zh/post/others/complaints-about-stupid-lab-platform/","summary":"今天学校不知道哪搞了个平台，让我们去上面做模拟实验，我点开一看，好嘛，没啥用的机器人、电焊，继续看下去还有题目，又懒得上网查答案，但是学校给的通知里有一行话引起了我的注意:\n 温馨提示:需要从实验空间进入实验,不可直接输入网址进入\n 不可直接输入网址？我仔细看了下，发现实验空间的作用就是添加一个 token，如果直接进去就是游客，没有办法登录。\n这下就好办了啊，虽然是游客，但是游客也可以做题啊，我用游客帐号先做了不就拿到答案了吗？\n这个系统果然把正确答案显示在前端了，但是不太好看，于是我就跑去 F12 看了。\n结果我在后台找到了下面的代码:\n$.ajax({ \turl: \u0026#34;/webApi/experimen/rig/getData\u0026#34;, \ttype: \u0026#34;GET\u0026#34;, \tdata: { courseId: courseId }, \tdataType: \u0026#34;JSON\u0026#34;, \tsuccess: function (res) {   // 省略的大量代码逻辑   })；  下面的注释是原来就有，不是我加的。\n对，这个系统没有对 js 做混淆甚至在代码里有详细的注释。\n // 单选 var answer = $(\u0026#39;.afterTesting .topic1 form\u0026#39;); for (var k = 0; k \u0026lt; answer.length; k++) {  var question1 = $(answer[k]).find(\u0026#34;.question1\u0026#34;);  var questionAnswer = question1.","title":"对于某实验平台的吐槽"},{"content":" 平时在使用 Linux 写代码的时候，总有一点让我很难受，那就是当我准备写中文注释的时候，输入 // 的时候，输入法总是希望我手动选择是要输入 / 还是中文的 、，随之弹出来的框非常影响代码编辑，经常打断我的思路，类似的还有反引号等符号，不厌其烦的我去查找了一些资料，终于彻底解决了这个问题。\n 准备 阅读本文前，你要保证你在使用 rime 输入法。遇到任何问题请多查阅 rime 提供的文档。\n本文所提到的内容在 fedora34 系统下，ibus-rime 包测试通过。\n找到 rime 用户资料夹 不同的平台下，rime 用户资料夹的位置会有所不同\n   平台 rime 用户资料夹位置     ibus ~/.config/ibus/rime   fcitx ~/.config/fcitx/rime   fcitx5 ~/.local/share/fcitx5/rime    创建你的配置文件 如果你从来没有配置过 rime，那么你可以直接在 rime 用户资料夹下创建名为 default.custom.yaml 的配置文件，写入如下内容:\npatch:  punctuator/full_shape:  \u0026#34;`\u0026#34;: \u0026#34;｀\u0026#34;  \u0026#34;~\u0026#34;: \u0026#34;～\u0026#34;  \u0026#34;!\u0026#34;: \u0026#34;！\u0026#34;  \u0026#34;@\u0026#34;: \u0026#34;＠\u0026#34;  \u0026#34;#\u0026#34;: \u0026#34;＃\u0026#34;  \u0026#34;$\u0026#34;: \u0026#34;￥\u0026#34;  \u0026#34;%\u0026#34;: \u0026#34;％\u0026#34;  \u0026#34;^\u0026#34;: \u0026#34;……\u0026#34;  \u0026#34;\u0026amp;\u0026#34;: \u0026#34;＆\u0026#34;  \u0026#34;*\u0026#34;: \u0026#34;×\u0026#34;  \u0026#34;(\u0026#34;: \u0026#34;（\u0026#34;  \u0026#34;)\u0026#34;: \u0026#34;）\u0026#34;  \u0026#34;_\u0026#34;: \u0026#34;——\u0026#34;  \u0026#34;+\u0026#34;: \u0026#34;＋\u0026#34;  \u0026#34;-\u0026#34;: \u0026#34;－\u0026#34;  \u0026#34;=\u0026#34;: \u0026#34;＝\u0026#34;  \u0026#34;[\u0026#34;: \u0026#34;【\u0026#34;  \u0026#34;]\u0026#34;: \u0026#34;】\u0026#34;  \u0026#34;{\u0026#34;: \u0026#34;｛\u0026#34;  \u0026#34;}\u0026#34;: \u0026#34;｝\u0026#34;  \u0026#34;|\u0026#34;: \u0026#34;｜\u0026#34;  \u0026#34;\\\\\u0026#34;: \u0026#34;、\u0026#34;  \u0026#34;/\u0026#34;: \u0026#34;、\u0026#34;  \u0026#34;;\u0026#34;: \u0026#34;；\u0026#34;  \u0026#34;\u0026#39;\u0026#34;: \u0026#34;‘\u0026#34;  \u0026#34;,\u0026#34;: \u0026#34;，\u0026#34;  \u0026#34;.\u0026#34;: \u0026#34;。\u0026#34;  \u0026#34;\u0026lt;\u0026#34;: \u0026#34;《\u0026#34;  \u0026#34;\u0026gt;\u0026#34;: \u0026#34;》\u0026#34;  \u0026#34;?\u0026#34;: \u0026#34;？\u0026#34;  punctuator/half_shape:  \u0026#34;`\u0026#34;: \u0026#34;`\u0026#34;  \u0026#34;~\u0026#34;: \u0026#34;~\u0026#34;  \u0026#34;!\u0026#34;: \u0026#34;！\u0026#34;  \u0026#34;@\u0026#34;: \u0026#34;@\u0026#34;  \u0026#34;#\u0026#34;: \u0026#34;#\u0026#34;  \u0026#34;$\u0026#34;: \u0026#34;￥\u0026#34;  \u0026#34;%\u0026#34;: \u0026#34;%\u0026#34;  \u0026#34;^\u0026#34;: \u0026#34;……\u0026#34;  \u0026#34;\u0026amp;\u0026#34;: \u0026#34;\u0026amp;\u0026#34;  \u0026#34;*\u0026#34;: \u0026#34;×\u0026#34;  \u0026#34;(\u0026#34;: \u0026#34;（\u0026#34;  \u0026#34;)\u0026#34;: \u0026#34;）\u0026#34;  \u0026#34;_\u0026#34;: \u0026#34;——\u0026#34;  \u0026#34;+\u0026#34;: \u0026#34;+\u0026#34;  \u0026#34;-\u0026#34;: \u0026#34;-\u0026#34;  \u0026#34;=\u0026#34;: \u0026#34;=\u0026#34;  \u0026#34;[\u0026#34;: \u0026#34;【\u0026#34;  \u0026#34;]\u0026#34;: \u0026#34;】\u0026#34;  \u0026#34;{\u0026#34;: \u0026#34;｛\u0026#34;  \u0026#34;}\u0026#34;: \u0026#34;｝\u0026#34;  \u0026#34;|\u0026#34;: \u0026#34;｜\u0026#34;  \u0026#34;\\\\\u0026#34;: \u0026#34;、\u0026#34;  \u0026#34;/\u0026#34;: \u0026#34;/\u0026#34;  \u0026#34;;\u0026#34;: \u0026#34;；\u0026#34;  \u0026#34;\u0026#39;\u0026#34;: \u0026#34;’\u0026#34;  \u0026#34;,\u0026#34;: \u0026#34;，\u0026#34;  \u0026#34;.\u0026#34;: \u0026#34;。\u0026#34;  \u0026#34;\u0026lt;\u0026#34;: \u0026#34;《\u0026#34;  \u0026#34;\u0026gt;\u0026#34;: \u0026#34;》\u0026#34;  \u0026#34;?\u0026#34;: \u0026#34;？\u0026#34; 以上配置的具体细节请查阅文档。\n应用配置 保存好你的配置文件之后，切换输入法到 rime，在托盘右击你的输入法（fedora 下左键单击也是一样的效果）选择 部署 ，稍等片刻，等待 rime 部署你的配置文件后，如果没有错误警告，那么恭喜你应用成功。之后在中文半角状态下输入 / 时会直接输入 / 而没有烦人的二级窗口提示你选择要输入的内容，可以愉快的写中文注释了。\n","permalink":"https://aimerneige.com/zh/post/linux/diy-your-rime-for-better-coding/","summary":"平时在使用 Linux 写代码的时候，总有一点让我很难受，那就是当我准备写中文注释的时候，输入 // 的时候，输入法总是希望我手动选择是要输入 / 还是中文的 、，随之弹出来的框非常影响代码编辑，经常打断我的思路，类似的还有反引号等符号，不厌其烦的我去查找了一些资料，终于彻底解决了这个问题。\n 准备 阅读本文前，你要保证你在使用 rime 输入法。遇到任何问题请多查阅 rime 提供的文档。\n本文所提到的内容在 fedora34 系统下，ibus-rime 包测试通过。\n找到 rime 用户资料夹 不同的平台下，rime 用户资料夹的位置会有所不同\n   平台 rime 用户资料夹位置     ibus ~/.config/ibus/rime   fcitx ~/.config/fcitx/rime   fcitx5 ~/.local/share/fcitx5/rime    创建你的配置文件 如果你从来没有配置过 rime，那么你可以直接在 rime 用户资料夹下创建名为 default.custom.yaml 的配置文件，写入如下内容:\npatch:  punctuator/full_shape:  \u0026#34;`\u0026#34;: \u0026#34;｀\u0026#34;  \u0026#34;~\u0026#34;: \u0026#34;～\u0026#34;  \u0026#34;!\u0026#34;: \u0026#34;！\u0026#34;  \u0026#34;@\u0026#34;: \u0026#34;＠\u0026#34;  \u0026#34;#\u0026#34;: \u0026#34;＃\u0026#34;  \u0026#34;$\u0026#34;: \u0026#34;￥\u0026#34;  \u0026#34;%\u0026#34;: \u0026#34;％\u0026#34;  \u0026#34;^\u0026#34;: \u0026#34;……\u0026#34;  \u0026#34;\u0026amp;\u0026#34;: \u0026#34;＆\u0026#34;  \u0026#34;*\u0026#34;: \u0026#34;×\u0026#34;  \u0026#34;(\u0026#34;: \u0026#34;（\u0026#34;  \u0026#34;)\u0026#34;: \u0026#34;）\u0026#34;  \u0026#34;_\u0026#34;: \u0026#34;——\u0026#34;  \u0026#34;+\u0026#34;: \u0026#34;＋\u0026#34;  \u0026#34;-\u0026#34;: \u0026#34;－\u0026#34;  \u0026#34;=\u0026#34;: \u0026#34;＝\u0026#34;  \u0026#34;[\u0026#34;: \u0026#34;【\u0026#34;  \u0026#34;]\u0026#34;: \u0026#34;】\u0026#34;  \u0026#34;{\u0026#34;: \u0026#34;｛\u0026#34;  \u0026#34;}\u0026#34;: \u0026#34;｝\u0026#34;  \u0026#34;|\u0026#34;: \u0026#34;｜\u0026#34;  \u0026#34;\\\\\u0026#34;: \u0026#34;、\u0026#34;  \u0026#34;/\u0026#34;: \u0026#34;、\u0026#34;  \u0026#34;;\u0026#34;: \u0026#34;；\u0026#34;  \u0026#34;\u0026#39;\u0026#34;: \u0026#34;‘\u0026#34;  \u0026#34;,\u0026#34;: \u0026#34;，\u0026#34;  \u0026#34;.","title":"定制你的 rime 提升编程体验"},{"content":"前言 距离上一次写博客文章已经很长时间了，因为经常重装系统，而每次在电脑上安装和配置 hexo 的博客都是一件比较麻烦的事情，于是就一直咕了。但是最近我发现了 hugo 这一简洁好用的博客系统，可以让我远离配置安装都又慢又麻烦的 hexo，使用下来体验很棒，而我恰好又打算换一个博客主题，于是决定使用 hugo 来搭建我的新博客。本文简要介绍如何安装和使用 hugo。\n安装 你可能需要  go 的开发环境 git 一个顺手的编辑器  你一定不需要  nodejs npm  安装 hugo 要安装 hugo 非常简单，以 fedora 系统为例，只需要执行如下指令：\nsudo dnf install hugo 创建站点文件夹 使用以下指令创建你的站点文件夹：\nhugo new site blog 切换到工作目录进行后续操作：\ncd blog 使用 git 进行版本控制：\ngit init 安装主题 挑选好合适的主题后，将其直接 clone 在 ./themes 文件夹下即可。\ngit clone https://github.com/adityatelange/hugo-PaperMod themes/PaperMod --depth=1  使用 --depth=1 参数会忽略历史 commit 记录。\n 当然，下载解压压缩包的方式也是可以的。\n如果想要方便版本控制和更新，使用如下指令添加 submodule：\ngit submodule add https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod --depth=1 当重新 clone 仓库后，执行如下指令 clone 主题子仓库：\ngit submodule update --init --recursive 更新主题：\ngit submodule update --remote --merge 配置 hugo 支持多种配置文件格式，由于 yaml 格式的配置文件更易读，下文将默认使用 yaml 配置。\n与 hexo 不同，hugo 的配置文件只有一个，按照你所使用的主题提供的文档来修改你的配置文件即可。\n应用主题 theme: \u0026#34;PaperMod\u0026#34; 修改主题配置 不同的主题会有不同的配置方法，具体查看主题提供的文档。\n请参考如下配置：\nbaseURL: \u0026#34;https://aimerneige.com/\u0026#34; languageCode: \u0026#34;en-us\u0026#34; title: \u0026#34;AimerNeige\u0026#39;s Blog\u0026#34; theme: \u0026#34;PaperMod\u0026#34;  enableRobotsTXT: true buildDrafts: false buildFuture: false buildExpired: false  defaultContentLanguage: en defaultContentLanguageInSubdir: true  languages:  en:  languageName: \u0026#34;English\u0026#34;  weight: 1  menu:  main:  - name: About  url: about/  weight: 5  - name: Friends  url: friends/  weight: 6  - name: Post  url: post/  weight: 7  - name: Archive  url: archives/  weight: 8  - name: Tags  url: tags/  weight: 9  - name: Categories  url: categories/  weight: 10  - name: Search  url: search/  weight: 11  zh:  languageName: \u0026#34;中文\u0026#34;  weight: 2  menu:  main:  - name: 关于  url: about/  weight: 5  - name: 朋友  url: friends/  weight: 6  - name: 文章  url: post/  weight: 7  - name: 归档  url: archives/  weight: 8  - name: 标签  url: tags/  weight: 9  - name: 分类  url: categories/  weight: 10  - name: 搜索  url: search/  weight: 11  params:  profileMode:  enabled: true  title: \u0026#34;Aimer Neige\u0026#34;  subtitle: \u0026#34;技术宅拯救世界\u0026#34;  imageUrl: \u0026#34;https://avatars.githubusercontent.com/u/51701792?v=4\u0026#34;  imageTitle: \u0026#34;avatar.jpeg\u0026#34;  imageWidth: 140  imageHeight: 140  params:  env: production  keywords: [Blog, OpenSource, Coding, Golang, Programming]  author: \u0026#34;Aimer Neige\u0026#34;  defaultTheme: auto  disableThemeToggle: false   ShowToc: true  TocOpen: false  ShowBreadCrumbs: true  ShowReadingTime: false  ShowPostNavLinks: true  ShowShareButtons: false  ShowCodeCopyButtons: true  displayFullLangName: true   editPost:  URL: \u0026#34;https://github.com/aimerneige/blog/content\u0026#34;  Text: \u0026#34;Suggest Changes\u0026#34;  appendFilePath: true   homeInfoParams:  Title: \u0026#34;Aimer Neige\u0026#34;  Content: \u0026#34;Tech Otakus Save The World\u0026#34;   profileMode:  enabled: true  title: \u0026#34;Aimer Neige\u0026#34;  subtitle: \u0026#34;Tech Otakus Save The World\u0026#34;  imageUrl: \u0026#34;https://avatars.githubusercontent.com/u/51701792?v=4\u0026#34;  imageTitle: \u0026#34;avatar.jpeg\u0026#34;  imageWidth: 140  imageHeight: 140   socialIcons:  - name: github  url: \u0026#34;https://github.com/AimerNeige\u0026#34;  - name: twitter  url: \u0026#34;https://twitter.com/NeigeAimer\u0026#34;  - name: steam  url: \u0026#34;https://steamcommunity.com/id/AimerNeige\u0026#34;  - name: Telegram  url: \u0026#34;https://t.me/AimerNeige\u0026#34;  - name: KoFi  url: \u0026#34;https://ko-fi.com/aimerneige\u0026#34;  - name: RsS  url: \u0026#34;index.xml\u0026#34;  taxonomies:  category: categories  tag: tags  series: series  outputs:  home:  - HTML  - RSS  - JSON 迁移 将原有文章复制到站点文件夹下，修改配置。\n测试 使用如下指令启动本地测试服务。\nhugo serve -D 部署 使用如下指令生成静态文件：\nhugo 之后上传到 github 即可：\ncd public git add -A git commit -m \u0026#34;commit message\u0026#34; git push ","permalink":"https://aimerneige.com/zh/post/others/hello-hugo/","summary":"前言 距离上一次写博客文章已经很长时间了，因为经常重装系统，而每次在电脑上安装和配置 hexo 的博客都是一件比较麻烦的事情，于是就一直咕了。但是最近我发现了 hugo 这一简洁好用的博客系统，可以让我远离配置安装都又慢又麻烦的 hexo，使用下来体验很棒，而我恰好又打算换一个博客主题，于是决定使用 hugo 来搭建我的新博客。本文简要介绍如何安装和使用 hugo。\n安装 你可能需要  go 的开发环境 git 一个顺手的编辑器  你一定不需要  nodejs npm  安装 hugo 要安装 hugo 非常简单，以 fedora 系统为例，只需要执行如下指令：\nsudo dnf install hugo 创建站点文件夹 使用以下指令创建你的站点文件夹：\nhugo new site blog 切换到工作目录进行后续操作：\ncd blog 使用 git 进行版本控制：\ngit init 安装主题 挑选好合适的主题后，将其直接 clone 在 ./themes 文件夹下即可。\ngit clone https://github.com/adityatelange/hugo-PaperMod themes/PaperMod --depth=1  使用 --depth=1 参数会忽略历史 commit 记录。\n 当然，下载解压压缩包的方式也是可以的。\n如果想要方便版本控制和更新，使用如下指令添加 submodule：\ngit submodule add https://github.","title":"Hello Hugo"},{"content":"前言 之前在学习安卓的时候，很想要给自己的软件增加一个云服务功能，但是苦于没有学过后端，于是开始在互联网上查找资料。但是遗憾的是，后端是一个很大的范围，我查找了很多后端的资料也几乎都是在讲解如何写网页，并没有专门用来给安卓写后端的教程，在广泛地学习了大量后端内容后，成功的为自己的程序开发了一个简单的 API。希望这篇文章能够帮到那些没有系统地学习过后端，但是却想要快速开发一款能用的 API 的安卓开发者。\n前期准备  你要了解互联网通讯原理 你要会一些基础的 JavaScript 你要有一台服务器 你会数据库操作 最好有一个域名（非必须） 掌握基础的终端操作  环境配置 本文章中后端开发使用的开发语言为 JavaScript 配合 nodejs。数据库采用常用的 mysql。\n 注： nodejs 开发常用的数据库是 mongodb，但是由于 mysql 比较常用这里就用 mysql 了，当然其他数据库也是可以的，你可以查找一下 nodejs 如何链接这些数据库，并将本文中 mysql 操作的部分替换掉就可以了。\n 本地测试客户端安装 你需要在自己用来开发的电脑上安装配置如下环境：\n nodejs npm  安装 nodejs Linux 下直接使用包管理安装即可。如果包管理安装的 node 很旧，可以自行谷歌一下安装方法，这里不再赘述。\n以 Ubuntu 为例，直接在终端执行如下指令：\nsudo apt install nodejs 安装完成后使用 node -v 查看 node 版本来确认安装是否成功。\n如果是 windows 用户就更加简单了，直接在 nodejs 官网 下载安装包运行即可。推荐使用长周期稳定版本。如果你想体验新特性，也可以考虑使用最新的版本。\n安装 npm 通常情况下，安装 nodejs 时会附带安装 npm，你可以直接使用 npm -v 来查看当前系统安装的 npm 版本来检测安装情况。\n如果没有安装，以 Ubuntu 系统为例，可以在终端执行下面的指令：\nsudo apt install npm windows 用户在执行完 node 的安装程序后 npm  会自动安装完成。\n服务器安装 你需要在服务器上安装配置如下环境：\n nodejs npm mysql nginx  安装 nodejs 与 npm 其中 nodejs 和 npm 的安装同客户端完全相同，这里不再赘述。\n安装 mysql mysql 可以一并安装在运行 node 项目的服务器上，也可以使用独立的数据库提供服务器。\n本文章主要讨论如何构建 API ，这里不再赘述如何安装配置 mysql。可以查看我的其他文章。\n安装 nginx nginx 用于将服务反向代理到 80 端口，以 Ubuntu 系统为例，直接在终端执行如下指令：\nsudo apt install nginx Windows 用户自行查阅相关资料。不会吧，不会吧，不会有人服务器用 windows 吧？？项目构建 使用模版 为了方便快速构建一个项目，我写了一个模版，你可以在 GitHub 上找到它。\n使用这个模版快速构建一个新的仓库，将它 clone 到本地，并进行下面的修改：\n 修改 package.json 修改 LICENSE 修改 README 在 src/config 下新建 db.js 写入数据库服务器的配置。  安装依赖 在项目路径下启动终端，执行如下指令：\nnpm i 这个指令是 npm install 的缩写，npm 会安装需要的依赖，本模版项目只依赖了俩个包：\n express mysql  依赖安装完成后，你会在项目路径下看到 node_modules 这个文件夹，它已经被写在 .gitignore 中，这个文件夹下是项目所需要的依赖，即使你意外地删掉了这个文件夹，再次执行 npm i 就可以将这些文件下载回来，所以你不应该在意这个文件夹中有什么内容，npm 会帮我们处理它。\n启动项目 使用 cd 命令切换到 src 目录下，执行下面的指令：\nnode app.js 之后你会在终端看到如下输出：\nServer start in development mode on http://localhost:4000; press Ctrl + C to terminated. 打开你的浏览器访问 http://localhost:4000/\n如果你看到下面的内容，说明项目成功启动了：\n{ \u0026#34;status\u0026#34;: 200, \u0026#34;info\u0026#34;: \u0026#34;If you see this, the server deploy success!\u0026#34; } 如果你在服务器启动项目，假设你的服务器 ip 为 43.192.82.215 并且配置了域名 api.aimerneige.com ，你可以通过在浏览器内访问下面的地址测试服务器：\n http://43.192.82.215:4000/ http://api.aimerneige.com:4000/  注意：\n 在本地测试启动的服务器只能通过 本地/内网 访问 在有公网 ip 的服务器上部署的服务可以在 任意浏览器内 打开  如果你在服务器测试，请注意以这样的方式运行仅能用来测试，不可以用作生产环境，后文会介绍如何在服务器部署项目。\n程序入口 项目可以启动后，说明环境配置无误，接下来可以开始写代码了。\n我们简单看一下程序的入口 app.js\n本项目依赖 express 构建，首先导入 express 的模块：\n// require const express = require(\u0026#34;express\u0026#34;); 接下来导入路由目录下的路由模块：\n// user require const indexRouter = require(\u0026#34;./routes/index\u0026#34;); 创建 express 对象：\n// express app var app = express(); 设置监听端口：\n// set port app.set(\u0026#34;port\u0026#34;, process.env.PORT || 4000); 添加可以支持 json 解析的中间件：\n// json parse app.use(express.json()); app.use(express.urlencoded({ extended: false })); 添加路由中间件：\n// routes app.use(\u0026#34;/\u0026#34;, indexRouter); 路由匹配失败后返回 404 错误：\n// catch 404 and forward to error handler app.use(function (req, res, next) {  var err = new Error(\u0026#34;Not Found\u0026#34;);  err.status = 404;  next(err); }); 处理错误信息：\n// error handler app.use(function (err, req, res, next) {  res.type(\u0026#34;application/json\u0026#34;);  res.status(err.status || 500);  res.send({  status: err.status || 500,  message: err.message,  }); }); 检测当前模块是否被直接执行，如果是则启动服务器，否者导出模块：\n// check if run app.js directly if (require.main === module) {  app.listen(app.get(\u0026#34;port\u0026#34;), function () {  console.log(  \u0026#34;Server start in \u0026#34; +  app.get(\u0026#34;env\u0026#34;) +  \u0026#34; mode on http://localhost:\u0026#34; +  app.get(\u0026#34;port\u0026#34;) +  \u0026#34;; press Ctrl + C to terminated.\u0026#34;  );  }); } else {  module.exports = app; } 其他的代码可以暂时不去理会，最重要的是路由这一部分：\n// 导入路由模块 const indexRouter = require(\u0026#34;./routes/index\u0026#34;); // 添加路由中间件 app.use(\u0026#34;/\u0026#34;, indexRouter); 在编写 api 时，只需要在 /src/routes 目录下新建路由模块，并在 app.js 下引用即可。\n添加路由 接下来我们看一下默认的路由模块 index.js ：\n导入 express 模块：\nconst express = require(\u0026#34;express\u0026#34;); const router = express.Router(); 配置路由规则：\nrouter.get(\u0026#34;/\u0026#34;, function (req, res, next) {  res.type(\u0026#34;application/json\u0026#34;);  res.status(200);  res.send({  status: 200,  info: \u0026#34;If you see this, the server deploy success!\u0026#34;,  }); }); 导出模块：\nmodule.exports = router; 其中重点即配置路由规则这一部分。\n我相信这几行代码还是很易懂的，相对地，如果我们想要使用 post 方法，访问路径为 /about 需要这样写：\nrouter.post(\u0026#34;/about\u0026#34;, fuction(){ /* function */ } ); 设置好请求方法和请求路径后，回调函数用来向客户端返回数据。\n设置返回数据类型，这里使用 json 进行数据传输：\nres.type(\u0026#34;application/json\u0026#34;); 设置返回状态码：\nres.status(200); 返回指定数据：\nres.send(return_data); 由于开发语言为 js ，而且本项目添加了解析 json 的中间件，如果想要返回 json，不需像其他语言那样要将对象解析为 json 字符串，直接返回一个对象即可，客户端会成功接收到正确的 json 字符串。\n// 服务器返回的对象 {  status: 200,  info: \u0026#34;If you see this, the server deploy success!\u0026#34;, } // 客户端拿到的字符串 { \u0026#34;status\u0026#34;: 200, \u0026#34;info\u0026#34;: \u0026#34;If you see this, the server deploy success!\u0026#34; } 书写好路由模块后在 app.js 中引用即可：\n// 导入模块 const indexRouter = require(\u0026#34;./routes/index\u0026#34;);  // ... 中间的其他代码  // 在 app 中应用路由模块 app.use(\u0026#34;/\u0026#34;, indexRouter); 要注意模块导入的位置，不能乱放。和模版保持一致即可。\n添加更多的路由信息 就像上面的例子中所写的，我们可以继续添加新的路由模块，也可以在同一个路由模块下添加更多的访问路径。\n src/app.js  // ...  const indexRouter = require(\u0026#34;./routes/index\u0026#34;); const userRouter = require(\u0026#34;./routes/user\u0026#34;);  // ...  app.use(\u0026#34;/\u0026#34;, indexRouter); app.use(\u0026#34;/user\u0026#34;, userRouter);  src/routes/index.js  // ...  // 访问路径 / router.get(\u0026#34;/\u0026#34;, fuction(){ /* function */ } );  // 访问路径 /about router.get(\u0026#34;/about\u0026#34;, function() { /* function */ });  // ...  src/routes/user.js  // ...  // 访问路径 /user/cat router.get(\u0026#34;/cat\u0026#34;, fuction(){ /* function */ } );  // 访问路径 /user/edit router.post(\u0026#34;/edit\u0026#34;, fuction(){ /* function */ } );  // 访问路径 /user/new router.psot(\u0026#34;/new\u0026#34;, fuction(){ /* function */ } );  // ... 获取客户端数据 获取请求参数信息 req.query 对象是由客户端请求参数构成的，在回调函数内，可以直接调用它来获取客户端请求参数，如果客户端传递了参数，我们就可以拿到对应的数据，否者我们只能得到 undefined。由此可以通过判空来确定客户端请求参数是否正确。\n例如我们的请求路径为 /data 所需请求参数为 id 和 class 可以这样写：\n 注： 对应的示例请求地址为 https://api.example.com/data?id=1930201\u0026amp;class=302\n router.get(\u0026#34;/data\u0026#34;, function (req, res) {  res.type(\u0026#34;application/json\u0026#34;);  if (req.query.class === undefined || req.query.id === undefined) {  res.status(400);  // 向客户端返回错误信息，提示客户端返回正确的参数  res.send({  status: 400,  info: \u0026#34;Wrong arguments!\u0026#34;,  });  } else {  // 向用户返回数据（通常会用客户端参数来调用数据库，为了简便这里返回一个类做简单示范）  res.status(200);  res.send({  status: 200,  info: {  class: req.query.class,  id: req.query.id,  },  });  } }); 我们可以通过判空来确定客户端请求参数是否正确，之后可以使用参数来进行其他操作，比如构建类，调取数据库等等。\n获取请求体信息 与请求参数类似，请求体信息也保存在一个类中，就是 req.body。使用方法和之前请求参数完全一致，这里只写一个示例，不多赘述。\nrouter.post(\u0026#34;/new\u0026#34;, function (req, res) {  res.type(\u0026#34;application/json\u0026#34;);  if (req.body.class === undefined || req.body.id === undefined) {  res.status(400);  // 向客户端返回错误信息，提示客户端返回正确的参数  res.send({  status: 400,  info: \u0026#34;Wrong arguments!\u0026#34;,  });  } else {  var new_student = {  class: req.body.class,  id: req.body.id,  };  // 向数据库内添加新的学生  res.status(200);  res.send({  status: 200,  info: \u0026#34;Student create successful!\u0026#34;,  });  } }); 获取更多信息 在回调函数中，req 对象中保存了所有来自客户请求的数据，前面介绍的只是比较常用的，其他内容可以查找文档。\n获取数据库信息 配置数据库信息 参考 db.js.example 创建 db.js 写入服务器的配置\nvar mysql = require(\u0026#34;mysql\u0026#34;);  var pool = mysql.createPool({  host: \u0026#34;host_ip\u0026#34;,  user: \u0026#34;user_name\u0026#34;,  password: \u0026#34;password\u0026#34;,  database: \u0026#34;data\u0026#34;,  port: 3306, });  function query(sql, callback) {  pool.getConnection(function (err, connection) {  connection.query(sql, function (err, rows) {  callback(err, rows);  connection.release();  });  }); }  exports.query = query; 配置好数据库服务器后，就可以通过下面的方法访问数据库的数据了：\nsql_command = \u0026#34;DROP DATABASE *;\u0026#34;; // ⚠️ 注意修改 db.query(sql_command, function (err, result, fields) {  if (err) {  // 如果数据库指令执行出现了错误，返回错误信息  requestSQLFailedLog(sql_command, err);  res.status(400);  res.send({ status: 400, info: err });  } else {  // 如果数据库指令执行成功，返回数据  requestSQLSuccessLog(sql_command, result);  res.status(200);  res.send(result);  } }); 服务部署  待完善，咕咕咕\n  将项目上传到服务器 修改 db.js 的配置 cd src node cluster.js 如果你想要后台运行，执行 nohup node cluster.js \u0026amp;  ","permalink":"https://aimerneige.com/zh/post/program/javascript/build-api-with-nodejs-quickly/","summary":"前言 之前在学习安卓的时候，很想要给自己的软件增加一个云服务功能，但是苦于没有学过后端，于是开始在互联网上查找资料。但是遗憾的是，后端是一个很大的范围，我查找了很多后端的资料也几乎都是在讲解如何写网页，并没有专门用来给安卓写后端的教程，在广泛地学习了大量后端内容后，成功的为自己的程序开发了一个简单的 API。希望这篇文章能够帮到那些没有系统地学习过后端，但是却想要快速开发一款能用的 API 的安卓开发者。\n前期准备  你要了解互联网通讯原理 你要会一些基础的 JavaScript 你要有一台服务器 你会数据库操作 最好有一个域名（非必须） 掌握基础的终端操作  环境配置 本文章中后端开发使用的开发语言为 JavaScript 配合 nodejs。数据库采用常用的 mysql。\n 注： nodejs 开发常用的数据库是 mongodb，但是由于 mysql 比较常用这里就用 mysql 了，当然其他数据库也是可以的，你可以查找一下 nodejs 如何链接这些数据库，并将本文中 mysql 操作的部分替换掉就可以了。\n 本地测试客户端安装 你需要在自己用来开发的电脑上安装配置如下环境：\n nodejs npm  安装 nodejs Linux 下直接使用包管理安装即可。如果包管理安装的 node 很旧，可以自行谷歌一下安装方法，这里不再赘述。\n以 Ubuntu 为例，直接在终端执行如下指令：\nsudo apt install nodejs 安装完成后使用 node -v 查看 node 版本来确认安装是否成功。\n如果是 windows 用户就更加简单了，直接在 nodejs 官网 下载安装包运行即可。推荐使用长周期稳定版本。如果你想体验新特性，也可以考虑使用最新的版本。\n安装 npm 通常情况下，安装 nodejs 时会附带安装 npm，你可以直接使用 npm -v 来查看当前系统安装的 npm 版本来检测安装情况。","title":"使用 nodejs 快速为 Android 程序构建 API"},{"content":"在多人协作的项目中，为了同一代码格式，可以使用 editorconfig 来定义，这样不仅可以帮助协作者快速了解当前项目要求的代码风格，也可以方便使用一些格式化工具保证代码风格按照预期格式化。\n快速了解  What is EditorConfig? EditorConfig helps maintain consistent coding styles for multiple developers working on the same project across various editors and IDEs. The EditorConfig project consists of a file format for defining coding styles and a collection of text editor plugins that enable editors to read the file format and adhere to defined styles. EditorConfig files are easily readable and they work nicely with version control systems. Source: https://editorconfig.org/\n 简单示例  示例来自 https://editorconfig.org/\n # EditorConfig is awesome: https://EditorConfig.org  # top-most EditorConfig file root = true  # Unix-style newlines with a newline ending every file [*] end_of_line = lf insert_final_newline = true  # Matches multiple files with brace expansion notation # Set default charset [*.{js,py}] charset = utf-8  # 4 space indentation [*.py] indent_style = space indent_size = 4  # Tab indentation (no size specified) [Makefile] indent_style = tab  # Indentation override for all JS under lib directory [lib/**.js] indent_style = space indent_size = 2  # Matches the exact files either package.json or .travis.yml [{package.json,.travis.yml}] indent_style = space indent_size = 2 使用方法 直接在项目目录下新建文件 .editorconfig 写入配置，安装对应插件后即可，保存文件时会按照配置文件自动格式化。\n额外地，如果你在 Windows 下如果使用 Windows Explorer 新建 .editorconfig 文件，需要将文件名写为 .editorconfig.，Windows 会自动重命名为 .editorconfig。\n特殊符号的含义    符号 含义     * 匹配任何字符串，除了路径分割符 (/)   ** 匹配任何字符串   ? 匹配任何单字符   [name] 匹配 name 中所包含的任一字符   [!name] 匹配不包含在 name 中的任一字符   {s1,s2,s3} 匹配任何给定单字符串 (用逗号分割) (在 EditorConfig Core 0.11.0 后受支持)   {num1..num2} 匹配任何在 num1 和 num2 之间的数字，num1 和 num2 可以是正数也可以是负数    支持的配置属性  indent_style 缩进样式 {tab, space} indent_size 每次缩进相当于多少列 {2,4,8\u0026hellip;} (当 indent_style 设置为 space 时使用) tab_width 每次缩进相当于多少列 {2,4,8\u0026hellip;} (当 indent_style 设置为 tab 时使用) end_of_line 换行 {lf, cr, crlf} charset 编码 {latin1, utf-16be, utf-16le, utf-8, utf-8-bom, unset} trim_trailing_whitespace {true, false} 是否删掉结尾的空白字符 insert_final_newline {true, false} 是否在结尾插入新行 root {true, false} 是否顶级配置文件  ","permalink":"https://aimerneige.com/zh/post/program/tool/editorconfig/","summary":"在多人协作的项目中，为了同一代码格式，可以使用 editorconfig 来定义，这样不仅可以帮助协作者快速了解当前项目要求的代码风格，也可以方便使用一些格式化工具保证代码风格按照预期格式化。\n快速了解  What is EditorConfig? EditorConfig helps maintain consistent coding styles for multiple developers working on the same project across various editors and IDEs. The EditorConfig project consists of a file format for defining coding styles and a collection of text editor plugins that enable editors to read the file format and adhere to defined styles. EditorConfig files are easily readable and they work nicely with version control systems.","title":"利用 EditorConfig 定义代码格式，统一代码风格"},{"content":"前言 Linux 下中文输入法一直是硬伤，各种方面都没有 windows 或 mac 下好用，最近在逛 github 的时候偶然翻到一个仓库 四叶草拼音输入方案，这个仓库提供的输入方案用起来十分舒服，但是在安装的时候也遇到一些坑，于是写了这篇文章来记录。\n 测试环境：\n.............. aimerneige@an  ..,;:ccc,. -------------  ......\u0026#39;\u0026#39;\u0026#39;;lxO. OS: Kali GNU/Linux Rolling x86_64 .....\u0026#39;\u0026#39;\u0026#39;\u0026#39;..........,:ld; Host: TM1701 .\u0026#39;;;;:::;,,.x, Kernel: 5.9.0-kali4-amd64  ..\u0026#39;\u0026#39;\u0026#39;. 0Xxoc:,. ... Uptime: 2 hours, 11 mins .... ,ONkc;,;cokOdc\u0026#39;,. Packages: 3537 (dpkg)  . OMo \u0026#39;:ddo. Shell: zsh 5.8 dMc :OO; Resolution: 1920x1080, 1440x2560 0M. .:o. DE: GNOME 3.38.2 ;Wd WM: Mutter ;XO, WM Theme: Kali-Dark ,d0Odlc;,.. Theme: Kali-Dark [GTK2/3] ..\u0026#39;,;:cdOOd::,. Icons: Flat-Remix-Blue-Dark [GTK2/\u0026gt; 3]  .:d;.\u0026#39;:;. Terminal: gnome-terminal \u0026#39;d, .\u0026#39; CPU: Intel i7-8550U (8) @ 4.000GHz ;l .. GPU: NVIDIA GeForce MX250 .o GPU: Intel UHD Graphics 620 c Memory: 3698MiB / 15899MiB .\u0026#39;  .  安装 fcitx5 sudo apt install fcitx5 启用 fcitx5 im-config 在开启的图形化界面中启用 fcitx5\n配置 fcitx5 编辑文件 ~/.xprofile 写入如下内容：\nexport GTK_IM_MODULE=fcitx5 export QT_IM_MODULE=fcitx5 export XMODIFIERS=\u0026#34;@im=fcitx5\u0026#34;  export LANG=\u0026#34;zh_CN.UTF-8\u0026#34; export LC_CTYPE=\u0026#34;zh_CN.UTF-8\u0026#34; 编辑完成后注销账户，重新启动桌面\n安装 rime sudo apt install fcitx5-rime 启用 rime 在托盘处点击配置，并添加 rime。\n如果你的系统和我一样是英文，取消勾选“Only Show Current Language”即可查看中文选项\n更快地，你可以直接在上面的搜索框搜索 Rime\n安装输入方案 安装 四叶草拼音输入方案 提供的输入方案\n具体安装方法查看 项目 wiki\n更换简体中文 按下 Ctrl + ` 将输入模式切换为简体中文\n你也可以按照自己的喜好更改全角/半角的设置\n后记 如果你在安装中遇到任何问题，请查阅 fcitx rime 四叶草拼音输入方案 提供的文档。\n或是在 Arch Wiki 上查阅相关内容。\n","permalink":"https://aimerneige.com/zh/post/linux/install-fcitx5-with-rime-on-linux/","summary":"前言 Linux 下中文输入法一直是硬伤，各种方面都没有 windows 或 mac 下好用，最近在逛 github 的时候偶然翻到一个仓库 四叶草拼音输入方案，这个仓库提供的输入方案用起来十分舒服，但是在安装的时候也遇到一些坑，于是写了这篇文章来记录。\n 测试环境：\n.............. aimerneige@an  ..,;:ccc,. -------------  ......\u0026#39;\u0026#39;\u0026#39;;lxO. OS: Kali GNU/Linux Rolling x86_64 .....\u0026#39;\u0026#39;\u0026#39;\u0026#39;..........,:ld; Host: TM1701 .\u0026#39;;;;:::;,,.x, Kernel: 5.9.0-kali4-amd64  ..\u0026#39;\u0026#39;\u0026#39;. 0Xxoc:,. ... Uptime: 2 hours, 11 mins .... ,ONkc;,;cokOdc\u0026#39;,. Packages: 3537 (dpkg)  . OMo \u0026#39;:ddo. Shell: zsh 5.8 dMc :OO; Resolution: 1920x1080, 1440x2560 0M. .:o. DE: GNOME 3.38.2 ;Wd WM: Mutter ;XO, WM Theme: Kali-Dark ,d0Odlc;,.. Theme: Kali-Dark [GTK2/3] .","title":"Linux 下安装 fcitx5 与 Rime"},{"content":"ifconfig ➜ ~ ifconfig enx2c16dba37d18: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1500  inet 10.0.117.154 netmask 255.255.255.0 broadcast 10.0.117.255  inet6 2001:250:c00:218:5bd6:795c:5b92:e787 prefixlen 64 scopeid 0x0\u0026lt;global\u0026gt;  inet6 fe80::2224:6ee:2527:f54d prefixlen 64 scopeid 0x20\u0026lt;link\u0026gt;  inet6 2001:250:c00:218:44fc:ad73:aeb8:b07d prefixlen 64 scopeid 0x0\u0026lt;global\u0026gt;  ether 2c:16:db:a3:7d:18 txqueuelen 1000 (Ethernet)  RX packets 110382 bytes 150904005 (150.9 MB)  RX errors 0 dropped 0 overruns 0 frame 0  TX packets 30811 bytes 3569027 (3.5 MB)  TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0  lo: flags=73\u0026lt;UP,LOOPBACK,RUNNING\u0026gt; mtu 65536  inet 127.0.0.1 netmask 255.0.0.0  inet6 ::1 prefixlen 128 scopeid 0x10\u0026lt;host\u0026gt;  loop txqueuelen 1000 (Local Loopback)  RX packets 26251 bytes 4892192 (4.8 MB)  RX errors 0 dropped 0 overruns 0 frame 0  TX packets 26251 bytes 4892192 (4.8 MB)  TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0  wlp2s0: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1500  inet 192.168.7.243 netmask 255.255.255.0 broadcast 192.168.7.255  inet6 fe80::1dea:1bcb:ae17:fa3b prefixlen 64 scopeid 0x20\u0026lt;link\u0026gt;  ether d0:c6:37:dd:91:95 txqueuelen 1000 (Ethernet)  RX packets 17759 bytes 19498138 (19.4 MB)  RX errors 0 dropped 7 overruns 0 frame 0  TX packets 6341 bytes 911629 (911.6 KB)  TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 ping Linux 服务器无法上网\n ping localhost\n侦测网卡安装或配置有问题 ping 网关\nip route show 查看网关\n侦测局域网中的网关或路由器是否正常 ping dns server\n在 /etc/resolv.conf 查看 dns 配置\ndns 解析是否可以解析 ping 远程地址\n与外部的连接是否正常  mtr 网络侦测工具\n My traceroute [v0.93] an-xiaomi-book-pro (10.0.117.154) 2020-11-10T10:08:42+0800 Keys: Help Display mode Restart statistics Order of fields quit Packets Pings Host Loss% Snt Last Avg Best Wrst StDev 1. _gateway 0.0% 156 1.2 1.8 0.8 16.4 2.6 2. 10.125.255.2 0.0% 156 0.6 0.5 0.4 0.8 0.1 3. 172.16.1.254 96.8% 156 2.5 5.7 1.7 18.3 7.1 4. 129.210.99.202.internet. 0.0% 156 2.1 3.4 1.7 12.4 2.2 5. 57.53.26.218.internet.sx 0.0% 156 2.7 4.1 2.1 12.9 1.9 6. 165.151.26.218.internet. 0.0% 156 25.9 25.6 24.0 32.0 0.9 7. 219.158.101.109 0.0% 155 17.2 14.0 10.1 18.5 2.3 8. 219.158.5.158 0.0% 155 17.7 15.5 10.9 33.9 3.2 9. 219.158.16.70 0.0% 155 13.1 15.7 11.7 20.8 2.4 10. 219.158.32.30 18.7% 155 121.5 165.3 108.3 226.9 34.2 11. ae-1.r31.tokyjp05.jp.bb. 0.0% 155 56.5 109.5 55.6 173.8 34.5 12. ae-3.r01.tokyjp08.jp.bb. 18.1% 155 109.4 161.9 108.5 222.7 35.2 13. ae-3.fastly.tokyjp08.jp. 20.6% 155 106.5 161.5 105.9 219.5 33.7 14. 185.199.109.153 0.6% 155 159.2 210.4 157.4 271.3 33.6  Loss 丢包率 Snt 发送的次数 Last 最近一次的返回时延 Avg 平均值 Best 最短的一次时间 Wrst 最长的一次时间 StDev 标准偏差  traceroute / tracepath ➜ ~ traceroute aimerneige.com traceroute to aimerneige.com (185.199.109.153), 30 hops max, 60 byte packets 1 10.0.117.1 (10.0.117.1) 11.848 ms 11.768 ms 11.719 ms 2 10.125.255.2 (10.125.255.2) 0.605 ms 0.578 ms 0.544 ms 3 * * * 4 129.210.99.202.internet.sx.cn (202.99.210.129) 2.015 ms 1.965 ms 1.920 ms 5 233.124.26.218.internet.sx.cn (218.26.124.233) 1.874 ms 2.345 ms 237.124.26.218.internet.sx.cn (218.26.124.237) 2.304 ms 6 245.131.26.218.router-switch.sx.cn (218.26.131.245) 2.902 ms 209.151.26.218.internet.sx.cn (218.26.151.209) 40.287 ms 245.131.26.218.router-switch.sx.cn (218.26.131.245) 2.713 ms 7 219.158.105.93 (219.158.105.93) 10.882 ms 219.158.102.249 (219.158.102.249) 9.079 ms 219.158.101.109 (219.158.101.109) 13.673 ms 8 219.158.5.158 (219.158.5.158) 11.302 ms 11.258 ms 219.158.4.174 (219.158.4.174) 20.035 ms 9 219.158.16.70 (219.158.16.70) 11.866 ms 19.391 ms 19.316 ms 10 219.158.32.30 (219.158.32.30) 216.576 ms 220.853 ms 215.579 ms 11 ae-0.r30.tokyjp05.jp.bb.gin.ntt.net (129.250.2.11) 162.897 ms 162.880 ms ae-1.r31.tokyjp05.jp.bb.gin.ntt.net (129.250.2.153) 163.532 ms 12 ae-3.r01.tokyjp08.jp.bb.gin.ntt.net (129.250.6.133) 215.634 ms ae-3.r00.tokyjp08.jp.bb.gin.ntt.net (129.250.6.129) 213.725 ms ae-2.r00.tokyjp08.jp.bb.gin.ntt.net (129.250.6.127) 169.350 ms 13 * * * 14 * * * 15 * * * 16 * * * 17 * * * 18 * * * 19 * * * 20 * * * 21 * * * 22 * * * 23 * * * 24 * * * 25 * * * 26 * * * 27 * * * 28 * * * 29 * * * 30 * * * ➜ ~ tracepath aimerneige.com  1?: [LOCALHOST] pmtu 1500  1: _gateway 1.048ms  1: _gateway 1.195ms  2: 10.125.255.2 0.588ms  3: 172.16.1.254 5.206ms  4: 129.210.99.202.internet.sx.cn 2.954ms  5: 145.53.26.218.internet.sx.cn 2.496ms  6: 245.131.26.218.router-switch.sx.cn 4.198ms  7: 219.158.11.113 13.225ms  8: 219.158.5.158 19.169ms  9: 219.158.16.70 11.860ms 10: 219.158.32.30 226.589ms 11: ae-1.r31.tokyjp05.jp.bb.gin.ntt.net 165.652ms 12: ae-3.r00.tokyjp08.jp.bb.gin.ntt.net 200.616ms 13: no reply 14: no reply 15: no reply 16: no reply 17: no reply 18: no reply 19: no reply 20: no reply 21: no reply 22: no reply 23: no reply 24: no reply 25: no reply 26: no reply 27: no reply 28: no reply 29: no reply 30: no reply  Too many hops: pmtu 1500  Resume: pmtu 1500 ip 查看网卡信息 ip addr show ➜ ~ ip addr show 1: lo: \u0026lt;LOOPBACK,UP,LOWER_UP\u0026gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000  link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00  inet 127.0.0.1/8 scope host lo  valid_lft forever preferred_lft forever  inet6 ::1/128 scope host  valid_lft forever preferred_lft forever 2: wlp2s0: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc noqueue state UP group default qlen 1000  link/ether d0:c6:37:dd:91:95 brd ff:ff:ff:ff:ff:ff  inet 192.168.7.243/24 brd 192.168.7.255 scope global dynamic noprefixroute wlp2s0  valid_lft 169205sec preferred_lft 169205sec  inet6 fe80::1dea:1bcb:ae17:fa3b/64 scope link noprefixroute  valid_lft forever preferred_lft forever 3: enx2c16dba37d18: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000  link/ether 2c:16:db:a3:7d:18 brd ff:ff:ff:ff:ff:ff  inet 10.0.117.154/24 brd 10.0.117.255 scope global dynamic noprefixroute enx2c16dba37d18  valid_lft 3601sec preferred_lft 3601sec  inet6 2001:250:c00:218:44fc:ad73:aeb8:b07d/64 scope global temporary dynamic  valid_lft 601397sec preferred_lft 82623sec  inet6 2001:250:c00:218:5bd6:795c:5b92:e787/64 scope global dynamic mngtmpaddr noprefixroute  valid_lft 2591976sec preferred_lft 604776sec  inet6 fe80::2224:6ee:2527:f54d/64 scope link noprefixroute  valid_lft forever preferred_lft forever 启用/禁用网卡 sudo ip link set enp0s3 up / dowm 为网卡分配地址 sudo ip addr add 192.168.0.50/255.255.255.0 dev enp0s3 sudo ip addr del 192.168.0.10/24 dev enp0s3 ip route 查看路由\nip route\n➜ ~ ip route default via 10.0.117.1 dev enx2c16dba37d18 proto dhcp metric 100 default via 192.168.7.1 dev wlp2s0 proto dhcp metric 600 10.0.117.0/24 dev enx2c16dba37d18 proto kernel scope link src 10.0.117.154 metric 100 169.254.0.0/16 dev enx2c16dba37d18 scope link metric 1000 192.168.7.0/24 dev wlp2s0 proto kernel scope link src 192.168.7.243 metric 600 添加静态路由\nsudo ip route add 172.16.32.32 via 192.168.0.150/24 dev enp0s3\n删除路由\nsudo ip route del 192.168.0.150/24\narp 查看 arp 记录\nip neigh\n➜ ~ ip neigh 192.168.7.2 dev wlp2s0 lladdr e8:39:35:1f:13:b1 STALE 192.168.7.1 dev wlp2s0 lladdr 28:d1:27:85:38:d7 REACHABLE 10.0.117.177 dev enx2c16dba37d18 lladdr e8:39:35:1f:14:fc STALE 192.168.7.38 dev wlp2s0 lladdr 2c:ff:ee:66:e2:01 STALE 10.0.117.1 dev enx2c16dba37d18 lladdr 58:69:6c:07:71:4b REACHABLE 192.168.7.160 dev wlp2s0 lladdr 3e:22:9c:ef:b8:d2 STALE fe80::5a69:6cff:fe07:714b dev enx2c16dba37d18 lladdr 58:69:6c:07:71:4b router STALE  PERM 永久有效并且只能被管理员删除 NOARP 记录有效，过期后可被删除 STALE 记录有效，但可能已经过期 REACHABLE 记录有效，但超时后就失效了  增加 arp 记录\nsudo ip neigh add 192.168.0.150 lladdr 33:1g:75:37:r3:84 dev enp0s3 nud perm\n删除 arp\nsudo ip neigh del 192.168.0.106 dev enp0s3\ncurl / wget curl aimerneige.com\nwget aimerneige.com\nnetstat 网络连接状态以及其相关信息的程序\n告诉用户哪些网络连接正在运作\n 列出所有端口 netstat -a 列出所有 tcp 端口 netstat -at 列出所有 udp 端口 netstat -au 显示进程 id 和名称 netstat -p 显示路由信息 netstat -r 显示所有监听的端口 netstat -tnl  ","permalink":"https://aimerneige.com/zh/post/linux/daily-linux-command/","summary":"ifconfig ➜ ~ ifconfig enx2c16dba37d18: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1500  inet 10.0.117.154 netmask 255.255.255.0 broadcast 10.0.117.255  inet6 2001:250:c00:218:5bd6:795c:5b92:e787 prefixlen 64 scopeid 0x0\u0026lt;global\u0026gt;  inet6 fe80::2224:6ee:2527:f54d prefixlen 64 scopeid 0x20\u0026lt;link\u0026gt;  inet6 2001:250:c00:218:44fc:ad73:aeb8:b07d prefixlen 64 scopeid 0x0\u0026lt;global\u0026gt;  ether 2c:16:db:a3:7d:18 txqueuelen 1000 (Ethernet)  RX packets 110382 bytes 150904005 (150.9 MB)  RX errors 0 dropped 0 overruns 0 frame 0  TX packets 30811 bytes 3569027 (3.5 MB)  TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0  lo: flags=73\u0026lt;UP,LOOPBACK,RUNNING\u0026gt; mtu 65536  inet 127.","title":"每天一个 Linux 指令"},{"content":"今天遇到一个奇怪的问题：\n一个 C 语言初学者写了这样的错误代码：\nswitch (a) {  case1:  // do something  break;  case2:  // do something  break;  case3:  // do something  break;  default:  break; } 错误很容易解决，但是，在编译这样的程序时，编译器居然没有报错？？！！\n那么 case1 case2 这些东西是哪里来的？\n几番求证无果，最后在翻阅《C 专家编程》这本书的时候突然发现了原因：\n首先像下面这样写是可以的：\nswitch (i) {  case 5 + 3: do_again:  case 2: printf(\u0026#34;I loop unremittingly\\n\u0026#34;); goto do_again;  default: i++;  case 3: ; } 这里定义了一个标签 do_again，并且通过 goto 跳转。\n原错误代码中 case1 case2 等被编译器理解为了标签。\n由于 goto 不被建议使用，博主居然已经忘记了标签和 goto 的用法。\n不管怎么说，问题解决了。\n这不是 Bug，而是 C 语言的特性。 #(滑稽)\n类似地，有如下代码：\n#include \u0026lt;stdio.h\u0026gt; int main() {  https://aimerneige.com  printf(\u0026#34;Hello World!\\n\u0026#34;);   return 0; } 这里的代码直接贴上了一个 url，但是编译器也没有报错，是因为 https 被识别为标签，而后面的内容被识别为注释。\n","permalink":"https://aimerneige.com/zh/post/program/c/this-is-not-bug/","summary":"今天遇到一个奇怪的问题：\n一个 C 语言初学者写了这样的错误代码：\nswitch (a) {  case1:  // do something  break;  case2:  // do something  break;  case3:  // do something  break;  default:  break; } 错误很容易解决，但是，在编译这样的程序时，编译器居然没有报错？？！！\n那么 case1 case2 这些东西是哪里来的？\n几番求证无果，最后在翻阅《C 专家编程》这本书的时候突然发现了原因：\n首先像下面这样写是可以的：\nswitch (i) {  case 5 + 3: do_again:  case 2: printf(\u0026#34;I loop unremittingly\\n\u0026#34;); goto do_again;  default: i++;  case 3: ; } 这里定义了一个标签 do_again，并且通过 goto 跳转。","title":"这不是 Bug，而是语言特性"},{"content":"函数指针在大型的 C 语言项目中十分重要，但是学校对它的介绍一带而过，国内一些介绍函数指针的文章十分粗浅甚至存在错误（这里就不点名了），因此博主写了这篇文章介绍函数指针，希望能够帮助一些 C 语言学习者。\n文章部分内容翻译引用于 https://www.geeksforgeeks.org/function-pointer-in-c/\n函数指针的概念 类似变量，函数也会被分配一段存储空间，这段存储空间的首地址即被称做这个函数的地址。而且函数名表示的就是这个地址。既然是地址，我们就可以定义一个指针变量来存放，这个指针变量就叫做函数指针变量，简称函数指针。\n函数指针的定义 下面的语句定义了一个指向函数的指针变量 p。其中 void *表示返回值，(*p) 表示 p 是一个指针变量， (int, float) 是函数的参数列表。\nvoid *(*p) (int, float); 这样我们就得到了一个指针变量 p，它的类型为 void * (*)(int, float)\n所以函数指针的定义方法为：\n函数返回类型 (*指针变量名) (函数参数列表); 这里的函数参数列表类似函数声明，只需写出变量类型即可，并不需要定义变量。\n即下面的俩种写法等价并且第二种写法中定义的变量并没有任何意义，建议使用第一种写法，不要使用第二种写法。\nvoid *(*p) (int, float); void *(*p) (int a, float b); 如何对函数指针赋值 int Func(int x); // 函数的声明  int (*p) (int x); // 函数指针的定义  p = \u0026amp;Func; // 函数指针的赋值 p = Func; // 另一种可行的写法 注：对于俩种赋值写法的详细说明见对函数赋值和调用的一些说明\n函数指针的调用 #include \u0026lt;stdio.h\u0026gt; int max(int a, int b); // 函数声明  int main(int argc, char const *argv[]) {  int a = 12;  int b = 32;   int (*p)(int, int); // 函数指针定义  p = \u0026amp;max; // 函数指针赋值   int c = (*p)(a, b); // 函数指针的调用  printf(\u0026#34;%d\\n\u0026#34;, c); // 输出 `32`   return 0; }  // 函数定义 int max(int a, int b) {  return a \u0026gt; b ? a : b; } 另一种可行的写法\n#include \u0026lt;stdio.h\u0026gt; int max(int a, int b); // 函数声明  int main(int argc, char const *argv[]) {  int a = 12;  int b = 32;   int (*p)(int, int); // 函数指针定义  p = max; // 函数指针赋值   int c = *p(a, b); // 函数指针的调用  printf(\u0026#34;%d\\n\u0026#34;, c); // 输出 `32`   return 0; }  // 函数定义 int max(int a, int b) {  return a \u0026gt; b ? a : b; } 注：对于这俩种调用的写法的详细说明见对函数赋值和调用的一些说明\n函数指针中要注意的一些内容  与一般的指针不同，函数指针指向代码而不是数据。通常，一个函数指针存储了可执行代码的起始位置。 与普通指针不同，我们使用函数指针时不需要分配和释放内存。 函数名也可以用来获取函数的地址。（详见对函数赋值和调用的一些说明） 类似普通的指针，我们也有函数指针数组。（详见函数指针数组示例） 函数指针可被用于 switch case 结构中，例如函数指针数组示例中的示例程序中，用户可以通过输入 0 ～ 2 来选择不同的操作。 就像普通数据的指针一样，一个函数指针同样可以被用作函数的参数和返回值，例如函数指针作为参数的示例中的程序中 wrapper() 函数接受 void (*fun)() 作为参数并且执行这个函数。这个特性有很多的应用，你可以在函数指针作为参数的应用中查看更多内容。 C++ 中的许多面向对象特性都是使用 C 中的函数指针实现的，例如虚函数，类方法是使用函数指针实现的另一个示例。  对函数赋值和调用的一些说明 通常，既然是指针赋值，我们会使用取地址操作来获取地址，然后使用 * 运算符调用，但是，对于函数来说，直接使用函数名也可以获得地址。即如下俩种写法等价：\np = \u0026amp;Func; (*p)(2, 3); p = Func; p(2, 3); 编译执行以下程序：\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; int max(int a, int b);  int main(int argc, char const *argv[]) {  printf(\u0026#34;%p\\n\u0026#34;, (max) );  printf(\u0026#34;%p\\n\u0026#34;, (\u0026amp;max) );  return 0; }  int max(int a, int b) {  return a \u0026gt; b ? a : b; } 你会发现 (max) (\u0026amp;max) 拥有相同的值，即直接使用函数名也可以获得地址。\n因此，我更推荐第二种没有 \u0026amp; 和 * 的写法，更加直观易用。\n函数指针数组示例 #include \u0026lt;stdio.h\u0026gt; void add(int a, int b) {  printf(\u0026#34;Addition is %d\\n\u0026#34;, a + b); }  void subtract(int a, int b) {  printf(\u0026#34;Subtraction is %d\\n\u0026#34;, a - b); }  void multiply(int a, int b) {  printf(\u0026#34;Multiplication is %d\\n\u0026#34;, a * b); }  int main() {  // fun_ptr_arr 是一个函数指针的数组  void (*fun_ptr_arr[])(int, int) = {add, subtract, multiply};  unsigned int ch, a = 15, b = 10;   printf(\u0026#34;Enter Choice: 0 for add, 1 for subtract and 2 for multiply\\n\u0026#34;);  scanf(\u0026#34;%d\u0026#34;, \u0026amp;ch);   if (ch \u0026gt; 2)  {  return 0;  }   (*fun_ptr_arr[ch])(a, b);   return 0; } 函数指针作为参数的示例 // 一个简单的 C 语言程序来演示使用函数指针作为参数 #include \u0026lt;stdio.h\u0026gt; // 俩个简单的函数 void fun1() { printf(\u0026#34;Fun1\\n\u0026#34;); } void fun2() { printf(\u0026#34;Fun2\\n\u0026#34;); }  // 一个接受函数作为参数并在内部执行这个函数的函数 void wrapper(void (*fun)()) {  fun(); }  int main() {  wrapper(fun1);  wrapper(fun2);  return 0; } 函数指针作为参数的应用 我们可以使用将函数指针作为参数来避免书写重复的代码，例如较为简单的函数 qsort() 可以被用来排序数组或其他任何的自定义结构体。不仅这些，有了函数指针和空指针，使用 qsort() 函数可以对任何数据类型进行排序。\n// 一个关于 qsort 和比较器的定义 #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; // 一个比较器示例函数 // 它被用对一个整数数组进行排序 // 为了对任何其他数据类型或条件的任何数组进行排序 // 我们需要编写更多的比较函数 // 这样我们就可以使用相同的 qsort() int compare(const void *a, const void *b) {  return (*(int *)a - *(int *)b); }  int main() {  int arr[] = {10, 5, 15, 12, 90, 80};  int n = sizeof(arr) / sizeof(arr[0]);   qsort(arr, n, sizeof(int), compare);   for (int i = 0; i \u0026lt; n; i++) {  printf(\u0026#34;%d \u0026#34;, arr[i]);  }  return 0; } 类似 qsort() 函数，我们可以定义自己的可以用于任何数据类型的函数来处理不同的任务。下面是一个搜索函数的示例，它可以被用于任何数据类型。事实上，我们可以通过写一个专门的比较函数使用这个搜索函数来找到相近的元素（低于某阈值）。\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdbool.h\u0026gt; // 一个被用来对整数数组进行搜索的比较函数 bool compare(const void *a, const void *b) {  return (*(int *)a == *(int *)b); }  // 可以被用来在一个长度为 arr_size 的数组 arr[] 中 // 搜索元素 *x 的通用 search() 函数。 // 注意这里使用 void 指针，这样函数就可以在调用 // 的时候传入任何类型的参数 // ele_size 是数组元素的大小 int search(void *arr, int arr_size, int ele_size, void *x,  bool compare(const void *, const void *)) {   // 因为 char 占用一个字节，因此我们使用 char 指针  // 来可以保证用于任何类型的指针运算都正确，我们  // 需要将 index 与元素的大小 ele_size 相乘  char *ptr = (char *)arr;   int i;  for (i = 0; i \u0026lt; arr_size; i++)  if (compare(ptr + i * ele_size, x))  return i;   // 如果没有找到元素  return -1; }  int main() {  int arr[] = {2, 5, 7, 90, 70};  int n = sizeof(arr) / sizeof(arr[0]);  int x = 7;  printf(\u0026#34;Returned index is %d \u0026#34;, search(arr, n,  sizeof(int), \u0026amp;x, compare));  return 0; } 这个函数可以被用于任何类型的数据，只要定义一个比较函数。\n如何使用 typedef 定义函数指针类型 与一般的定义不同，函数指针在使用 typedef 重命名时，新的变量名不是在末尾而是类似函数指针变量定义的写法。\n下面是一个简单的例子：\ntypedef int (*type_name) (const void *, double); 其中 int 为函数返回值类型， const void *, double 是函数接受的参数列表，(*type_name) 表明定义的是一个函数指针，它的类型为 int (*)(const void *, double)，新的类型名为 type_name，你可以使用 type_name 来定义一个类型为 int (*)(const void *, double) 的函数指针。\n也就是说，使用定义函数指针类型的格式如下：\ntypedef 函数返回值类型 (*类型名) (函数参数列表) 接下来看一下 qsort() 函数的源代码：\n首先是函数 qsort() 的声明：\nextern void qsort (void *__base, size_t __nmemb, size_t __size, \t__compar_fn_t __compar) __nonnull ((1, 4)); 这里有一个新的数据类型 __compar_fn_t，我们知道它是一个函数指针，我们找一下它的定义：\ntypedef int (*__compar_fn_t) (const void *, const void *); 上例中 search() 函数可以这样定义：\n// 类型定义 typedef bool (*compare_fun)(const void *, const void *); // 函数声明 int search(void *arr, int arr_size, int ele_size, void *x, compare_fun compare);  建议阅读： https://www.geeksforgeeks.org/function-pointer-in-c/\n","permalink":"https://aimerneige.com/zh/post/program/c/c-function-point/","summary":"函数指针在大型的 C 语言项目中十分重要，但是学校对它的介绍一带而过，国内一些介绍函数指针的文章十分粗浅甚至存在错误（这里就不点名了），因此博主写了这篇文章介绍函数指针，希望能够帮助一些 C 语言学习者。\n文章部分内容翻译引用于 https://www.geeksforgeeks.org/function-pointer-in-c/\n函数指针的概念 类似变量，函数也会被分配一段存储空间，这段存储空间的首地址即被称做这个函数的地址。而且函数名表示的就是这个地址。既然是地址，我们就可以定义一个指针变量来存放，这个指针变量就叫做函数指针变量，简称函数指针。\n函数指针的定义 下面的语句定义了一个指向函数的指针变量 p。其中 void *表示返回值，(*p) 表示 p 是一个指针变量， (int, float) 是函数的参数列表。\nvoid *(*p) (int, float); 这样我们就得到了一个指针变量 p，它的类型为 void * (*)(int, float)\n所以函数指针的定义方法为：\n函数返回类型 (*指针变量名) (函数参数列表); 这里的函数参数列表类似函数声明，只需写出变量类型即可，并不需要定义变量。\n即下面的俩种写法等价并且第二种写法中定义的变量并没有任何意义，建议使用第一种写法，不要使用第二种写法。\nvoid *(*p) (int, float); void *(*p) (int a, float b); 如何对函数指针赋值 int Func(int x); // 函数的声明  int (*p) (int x); // 函数指针的定义  p = \u0026amp;Func; // 函数指针的赋值 p = Func; // 另一种可行的写法 注：对于俩种赋值写法的详细说明见对函数赋值和调用的一些说明","title":"C 函数指针"},{"content":"线程于进程的对比\n          thread 线程 有共享内存   process 进程 没有共享内存    gcc file.c -lpthread 创建线程\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;pthread.h\u0026gt; void *myfunc(void *args) {  for (int i = 0; i \u0026lt; 50; i++)  {  printf(\u0026#34;%d\\n\u0026#34;, i);  }  return NULL; }  int main() {  pthread_t th1;  pthread_t th2;   pthread_create(\u0026amp;th1, NULL, myfunc, NULL);  pthread_create(\u0026amp;th2, NULL, myfunc, NULL);   pthread_join(th1, NULL);  pthread_join(th2, NULL);   return 0; } 传入参数\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;pthread.h\u0026gt; void *myfunc(void *args) {  char *name = (char *)args;  for (int i = 0; i \u0026lt; 50; i++)  {  printf(\u0026#34;%s %d\\n\u0026#34;, name, i);  }  return NULL; }  int main() {  pthread_t th1;  pthread_t th2;   pthread_create(\u0026amp;th1, NULL, myfunc, \u0026#34;th1\u0026#34;);  pthread_create(\u0026amp;th2, NULL, myfunc, \u0026#34;th2\u0026#34;);   pthread_join(th1, NULL);  pthread_join(th2, NULL);   return 0; } 分部计算\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;pthread.h\u0026gt; int arr[5000]; int s1 = 0; int s2 = 0;  void *myfunc1(void *args) {  for (int i = 0; i \u0026lt; 2500; i++)  {  s1 += arr[i];  }  return NULL; }  void *myfunc2(void *args) {  for (int i = 2500; i \u0026lt; 5000; i++)  {  s2 += arr[i];  }  return NULL; }  int main() {   for (int i = 0; i \u0026lt; 5000; i++)  {  arr[i] = rand() % 50;  }   pthread_t th1;  pthread_t th2;   pthread_create(\u0026amp;th1, NULL, myfunc1, NULL);  pthread_create(\u0026amp;th2, NULL, myfunc2, NULL);   pthread_join(th1, NULL);  pthread_join(th2, NULL);   int S = s1 + s2;  printf(\u0026#34;Result: %d\\n\u0026#34;, S);   return 0; } 单参数的写法\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;pthread.h\u0026gt; int arr[5000]; int s1 = 0; int s2 = 0;  void *myfunc(void *args) {  int a = 0 [(int *)args];  if (a == 1)  {  for (int i = 0; i \u0026lt; 2500; i++)  {  s1 += arr[i];  }  }  else  {  for (int i = 2500; i \u0026lt; 5000; i++)  {  s2 += arr[i];  }  }   return NULL; }  int main() {  for (int i = 0; i \u0026lt; 5000; i++)  {  arr[i] = rand() % 50;  }   pthread_t th1;  pthread_t th2;   pthread_create(\u0026amp;th1, NULL, myfunc, (int []){1});  pthread_create(\u0026amp;th2, NULL, myfunc, (int []){2});   pthread_join(th1, NULL);  pthread_join(th2, NULL);   int S = s1 + s2;  printf(\u0026#34;Result: %d\\n\u0026#34;, S);   return 0; } 传入结构体\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;pthread.h\u0026gt; typedef struct {  int first;  int last; } MY_ARGS;  int arr[5000]; int s1 = 0; int s2 = 0;  void *myfunc(void *args) {  MY_ARGS *arg = (MY_ARGS *)args;  for (int i = arg-\u0026gt;first; i \u0026lt; arg-\u0026gt;last; i++)  {  s1 += arr[i];  }  return NULL; }  int main() {  for (int i = 0; i \u0026lt; 5000; i++)  {  arr[i] = rand() % 50;  }   pthread_t th1;  pthread_t th2;   MY_ARGS args_1 = {0, 2500};  MY_ARGS args_2 = {2500, 5000};   pthread_create(\u0026amp;th1, NULL, myfunc, \u0026amp;args_1);  pthread_create(\u0026amp;th2, NULL, myfunc, \u0026amp;args_2);   pthread_join(th1, NULL);  pthread_join(th2, NULL);   int S = s1 + s2;  printf(\u0026#34;Result: %d\\n\u0026#34;, S);   return 0; } 结构体的更多参数\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;pthread.h\u0026gt; typedef struct {  int first;  int last;  int result; } MY_ARGS;  int arr[5000];  void *myfunc(void *args) {  MY_ARGS *arg = (MY_ARGS *)args;  for (int i = arg-\u0026gt;first; i \u0026lt; arg-\u0026gt;last; i++)  {  arg-\u0026gt;result += arr[i];  }  return NULL; }  int main() {  for (int i = 0; i \u0026lt; 5000; i++)  {  arr[i] = rand() % 50;  }   pthread_t th1;  pthread_t th2;   MY_ARGS args_1 = {0, 2500, 0};  MY_ARGS args_2 = {2500, 5000, 1};   pthread_create(\u0026amp;th1, NULL, myfunc, \u0026amp;args_1);  pthread_create(\u0026amp;th2, NULL, myfunc, \u0026amp;args_2);   pthread_join(th1, NULL);  pthread_join(th2, NULL);   int S = args_1.result + args_2.result;  printf(\u0026#34;Result: %d\\n\u0026#34;, S);   return 0; } 一些错误的写法\n它会造成 race condition\n// dangerous operation #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;pthread.h\u0026gt; int a = 0;  void *myfunc(void *args) {  for (int i = 0; i \u0026lt; 1000000; i++)  {  a++;  }  return NULL; }  int main() {  pthread_t pt1;  pthread_t pt2;   pthread_create(\u0026amp;pt1, NULL, myfunc, NULL);  pthread_create(\u0026amp;pt2, NULL, myfunc, NULL);   pthread_join(pt1, NULL);  pthread_join(pt2, NULL);   printf(\u0026#34;%d\\n\u0026#34;, a);   return 0; } 加锁\n// in this way, it is slow #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;pthread.h\u0026gt; #define MAX_SIZE 5000000  pthread_mutex_t lock; int a = 0;  void *myfunc(void *args) {  for (int i = 0; i \u0026lt; 100000; i++)  {  pthread_mutex_lock(\u0026amp;lock);  a++;  pthread_mutex_unlock(\u0026amp;lock);  }  return NULL; }  int main() {  pthread_t pt1;  pthread_t pt2;   pthread_mutex_init(\u0026amp;lock, NULL);   pthread_create(\u0026amp;pt1, NULL, myfunc, NULL);  pthread_create(\u0026amp;pt2, NULL, myfunc, NULL);   pthread_join(pt1, NULL);  pthread_join(pt2, NULL);   printf(\u0026#34;%d\\n\u0026#34;, a);   return 0; } 较为完整的写法\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;pthread.h\u0026gt; #define ZERO 0 #define HALF 2500000 #define MAX_SIZE 5000000  typedef struct {  int first;  int last;  int id; } MY_ARGS;  int *arr; int result[2];  void *myfunc(void *args) {  MY_ARGS *arg = (MY_ARGS *)args;  for (int i = arg-\u0026gt;first; i \u0026lt; arg-\u0026gt;last; i++)  {  result[arg-\u0026gt;id] += arr[i];  }  return NULL; }  int main() {  arr = (int *)malloc(sizeof(int) * MAX_SIZE);  for (int i = 0; i \u0026lt; MAX_SIZE; i++)  {  arr[i] = rand() % 5;  }   result[0] = 0;  result[1] = 0;   pthread_t th1;  pthread_t th2;   MY_ARGS args_1 = {ZERO, HALF, 0};  MY_ARGS args_2 = {HALF, MAX_SIZE, 1};   pthread_create(\u0026amp;th1, NULL, myfunc, \u0026amp;args_1);  pthread_create(\u0026amp;th2, NULL, myfunc, \u0026amp;args_2);   pthread_join(th1, NULL);  pthread_join(th2, NULL);   int S = result[0] + result[1];  printf(\u0026#34;Result: %d\\n\u0026#34;, S);   return 0; } ","permalink":"https://aimerneige.com/zh/post/program/c/c-thread-basic/","summary":"线程于进程的对比\n          thread 线程 有共享内存   process 进程 没有共享内存    gcc file.c -lpthread 创建线程\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;pthread.h\u0026gt; void *myfunc(void *args) {  for (int i = 0; i \u0026lt; 50; i++)  {  printf(\u0026#34;%d\\n\u0026#34;, i);  }  return NULL; }  int main() {  pthread_t th1;  pthread_t th2;   pthread_create(\u0026amp;th1, NULL, myfunc, NULL);  pthread_create(\u0026amp;th2, NULL, myfunc, NULL);   pthread_join(th1, NULL);  pthread_join(th2, NULL);   return 0; } 传入参数","title":"C 语言多线程基础"},{"content":"在 C 语言中，函数默认是全局的。在函数前加“static”关键字可以使一个函数变成静态函数。例如，下面的函数 fun() 是静态的：\nstatic int fun(void) {  printf(\u0026#34;I am a static funciton.\\n\u0026#34;); } 与 C 语言中的全局函数不同，对静态函数的访问仅限于声明它们的文件。因此，当我们想要限制函数的访问时，我们可以将函数定义为静态的。另外，如果我们想要在其他文件中使用相同的函数名，我们也可以将函数定义为静态的。\n例如，我们在文件 file.c 中存储了下面的程序：\n// in file `file1.c` #include \u0026lt;stdio.h\u0026gt; static void fun1() {  printf(\u0026#34;fun1 called.\\n\u0026#34;); } 然后，我们在文件 file2.c 中存储了这样的程序：\n// in file `file2.c` #include \u0026lt;stdio.h\u0026gt; int main(void) {  fun1();   return 0; } 接下来，如果我们按照如下的命令编译：\ngcc file2.c file1.c 你会得到这样的链接错误：\nundefined reference to `fun1\u0026#39; 这是因为 fun1() 函数在 file1.c 中被定义为静态，因而不能在 file2.c 中引用。\n","permalink":"https://aimerneige.com/zh/post/program/c/c-static-function/","summary":"在 C 语言中，函数默认是全局的。在函数前加“static”关键字可以使一个函数变成静态函数。例如，下面的函数 fun() 是静态的：\nstatic int fun(void) {  printf(\u0026#34;I am a static funciton.\\n\u0026#34;); } 与 C 语言中的全局函数不同，对静态函数的访问仅限于声明它们的文件。因此，当我们想要限制函数的访问时，我们可以将函数定义为静态的。另外，如果我们想要在其他文件中使用相同的函数名，我们也可以将函数定义为静态的。\n例如，我们在文件 file.c 中存储了下面的程序：\n// in file `file1.c` #include \u0026lt;stdio.h\u0026gt; static void fun1() {  printf(\u0026#34;fun1 called.\\n\u0026#34;); } 然后，我们在文件 file2.c 中存储了这样的程序：\n// in file `file2.c` #include \u0026lt;stdio.h\u0026gt; int main(void) {  fun1();   return 0; } 接下来，如果我们按照如下的命令编译：\ngcc file2.c file1.c 你会得到这样的链接错误：\nundefined reference to `fun1\u0026#39; 这是因为 fun1() 函数在 file1.c 中被定义为静态，因而不能在 file2.c 中引用。","title":"C 语言静态函数"},{"content":" 注意将本文章提到的路径中 AimerNeige 修改为自己的用户名，之后不再赘述。\n 安装 alacritty 按照自己的喜好 在 GitHub 下载最新版 release 或自己编译。\n本次演示中可执行文件存储目录：\nC:\\Tools\\Alacritty\\alacritty.exe\n配置 alacritty 将配置文件放置在如下目录：\nC:\\Users\\AimerNeige\\AppData\\Roaming\\alacritty\\alacritty.yml\n配置方法和 Linux 下类似。\n我的配置文件\n将 alacrity 注册为右键菜单启动 新建文本文件，填入如下内容，修改后缀为 .reg 运行，将配置写入注册表。\nWindows Registry Editor Version 5.00 [HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\alacritty] @=\u0026#34;Alacritty terminal here\u0026#34; \u0026#34;Icon\u0026#34;=\u0026#34;C:\\\\Tools\\\\Alacritty\\\\alacritty.ico\u0026#34; [HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\alacritty\\command] @=\u0026#34;C:\\\\Tools\\\\Alacritty\\\\alacritty.exe\u0026#34; 当然，你也可以按照自己的喜好手动编辑注册表。\n其中 Icon 这一行中使用的的图标文件可以在 GitHub 官方仓库 下载，或者也可以使用自己喜欢的内容。\n你也可以将 @=\u0026quot;Alacritty terminal here\u0026quot; 修改为自己喜欢的内容。\n","permalink":"https://aimerneige.com/zh/post/others/alacritty-on-windows/","summary":"注意将本文章提到的路径中 AimerNeige 修改为自己的用户名，之后不再赘述。\n 安装 alacritty 按照自己的喜好 在 GitHub 下载最新版 release 或自己编译。\n本次演示中可执行文件存储目录：\nC:\\Tools\\Alacritty\\alacritty.exe\n配置 alacritty 将配置文件放置在如下目录：\nC:\\Users\\AimerNeige\\AppData\\Roaming\\alacritty\\alacritty.yml\n配置方法和 Linux 下类似。\n我的配置文件\n将 alacrity 注册为右键菜单启动 新建文本文件，填入如下内容，修改后缀为 .reg 运行，将配置写入注册表。\nWindows Registry Editor Version 5.00 [HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\alacritty] @=\u0026#34;Alacritty terminal here\u0026#34; \u0026#34;Icon\u0026#34;=\u0026#34;C:\\\\Tools\\\\Alacritty\\\\alacritty.ico\u0026#34; [HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\alacritty\\command] @=\u0026#34;C:\\\\Tools\\\\Alacritty\\\\alacritty.exe\u0026#34; 当然，你也可以按照自己的喜好手动编辑注册表。\n其中 Icon 这一行中使用的的图标文件可以在 GitHub 官方仓库 下载，或者也可以使用自己喜欢的内容。\n你也可以将 @=\u0026quot;Alacritty terminal here\u0026quot; 修改为自己喜欢的内容。","title":"在 Windows10 安装和配置 alacritty"},{"content":"GCC 简介 GCC 是 Linux 下的编译工具集，是 GNU Compiler Collection 的缩写,包含 gcc 、 g++ 等编译器。这个工具集不仅包含编译器，还包含其他工具集，例如 ar 、 nm 等。\nGCC 工具集不仅能编译 C/C++ 语言，其他例如 Objective-C 、 Pascal 、 Fortran 、 Java 、 Ada 等语言均能进行编译。\nGCC 在可以根据不同的硬件平台进行编译，即能进行交叉编译，在 A 平台上编译 B 平台的程序，支持常见的 X86 、 ARM 、 PowerPC 、 mips 等，以及 Linux 、 Windows 等软件平台。\nGCC 的 C 编译器 是 gcc，其命令格式为 :\nUsage: gcc [options] file... GCC 下默认文扩展名的含义：\n   文件扩展名 GCC 所理解的含义     *.c 该类文件为 C 语言的源文件   *.h 该类文件为 C 语言的头文件   *.i 该类文件为预处理后的 C 文件   *.C 该类文件为 C++ 语言的源文件   *.cc 该类文件为 C++ 语言的源文件   *.cxx 该类文件为 C++ 语言的源文件   *.m 该类文件为 Objective-C 语言的源文件   *.s 该类文件为汇编语言的源文件   *.o 该类文件为汇编后的目标文件   *.a 该类文件为静态库   *.so 该类文件为共享库   a.out 该类文件为链接后的输出文件    GCC 下有很多编译器，可以支持 C 语言，C++语言等多种语言\n   GCC 编译器命令 含义     cc 指的是 C 语言编译器   cpp 指的是预处理编译器   gcc 指的是 C 语言编译器   g++ 指的是 C++语言编译器    编译程序的基本知识 GCC 编译器对程序的编译分为 4 个阶段：\n 预编译 编译和优化 汇编 链接  GCC 的编译器可以将这 4 个步骤合并成一个。\n源文件指存放可编辑代码的文件，如存放 C/C++ 和汇编语言的文件。\n目标文件是指经过编译器的编译生成的 CPU 可识别的二进制代码，但是目标文件一般不能执行，因为其中的一些函数过程没有相关的指示和说明。\n可执行文件就是目标文件与相关的库链接后的文件，它是可以执行的。\n预编译过程将程序中引用的头文件包含进源代码中，并对一些宏进行替换。\n编译过程将用户可识别的语言翻译成一组处理器可识别的操作码，生成目标文件，通常翻译成汇编语言，而汇编语言通常和机器操作码之间是一种一对一的关系。 GNU 中有 C/C++ 编译器 GCC 和汇编器 as。\n所有的目标文件必须用某种方式组合起来才能运行，这就是链接的作用。目标文件中通常仅解析了文件内部的变量和函数，对于引用的函数和变量还没有解析，这需要将其他已经编写好的目标文件引用进来，将没有解析的变量和函数进行解析，通常引用的目标是库。链接完成后会生成可执行文件。\n单个文件编译成执行文件 下面是一个示例程序的源代码：\n// hello.c #include \u0026lt;stdio.h\u0026gt; int main() {  printf(\u0026#34;Hello World!\\n\u0026#34;);   return 0; } 将其保存在 hello.c 文件中，运行如下命令将代码直接编译成可执行文件：\n$ gcc hello.c 上述命令没有指定生成执行文件的名称， GCC 将生成默认的文件名 a.out。 运行结果如下：\n$ ./a.out Hello World! 如果希望生成指定的可执行文件名，选项 -o 可以使编译程序生成指定文件名，例如将上述程序编译输出一个名称为 test 的执行程序：\n$ gcc -o test hello.c 上述命令把 hello.c 源文件编译成可执行文件 test。 运行可执行文件 test，向终端输出 \u0026quot;Hello World!\u0026quot; 字符串。运行结果如下：\n$ ./test Hello World! 编译生成目标文件 GCC 的 -c 选项可以用于生成目标文件，这一选项将源文件生成目标文件，而不是生成可执行文件。默认情况下生成的目标文件的文件名和源文件的名称一样，只是扩展名为 .o。例如，下面的命令会生成一个名字为 Hello.o 的目标文件：\n$ gcc -c hello.c 如果需要生成指定的文件名，可以使用 -o 选项。下面的命令将源文件 hello.c 编译成目标文件，文件名为 test.o：\n$ gcc -c -o test.o hello.c 可以用一条命令编译多个源文件，生成目标文件，这通常用于编写库文件或者一个项目中包含多个源文件。例如一个项目包含 filel.c 、 file2.c 和 file3.c, 下面的命令可以将源文件生成 3 个目标文件 : filel.o 、 file2.o 和 file3.o：\n$ gcc -c file1.c file2.c file3.c 多文件编译 GCC 可以自动链接多个文件，不管是目标文件还是源文件，都可以使用同一个命令编译到一个可执行文件中。例如一个项目包含俩个文件，文件 string.c 中有一个函数 StrLen 用于计算字符串的长度，而在 main.c 中调用这个函数将计算结果显示出来。\n源文件 string.c // string.c #define ENDSTRING \u0026#39;\\0\u0026#39; int StrLen(char *string) {  int len = 0;   while (*string++ != ENDSTRING) {  len++;  }  return len; } 源文件 main.c // main.c #include \u0026lt;stdio.h\u0026gt;extern int StrLen(char *str); int main() {  char src[] = \u0026#34;Hello AimerNeige!\\n\u0026#34;;  printf(\u0026#34;String length is: %d\\n\u0026#34;, StrLen(src));   return 0; } 编译运行 下面的命令将俩个源文件中的程序编译成一个执行文件，文件名为 test。\n$ gcc -o test strung.c main.c 执行编译出来的可执行文件 test，程序的运行结果如下：\n$ ./test String length is: 18 当然也可以先将源文件编成目标文件，然后进行链接。例如，下面的过程将 string.c 和 main.c 源文件编译成目标文件 string.o 和 main.o，然后将 string.o 和 main.o 链接生成 test ：\n$ gcc -c string.c main.c $ gcc -o test string.o main.o 预处理 在 C 语言程序中，通常需要包含头文件并会定义一些宏。 预处理过程将源文件中的头文件包含进源文件中，并且将文件中定义的宏进行扩展。\n编译程序时选项 -E 告诉编译器进行预编译操作。例如如下命令将文件 string.c 的预处理结果显示在计算机屏幕上 :\n$ gcc -E string.c 如果需要指定源文件编译后生成的中间结果文件名，需要使用选项 -o。例如，下面的代码将文件 string.c 进行预编译，生成文件 string.i。\n$ gcc -o string.i -E string.c 编译成汇编语言 生成汇编语言的 GCC 选项 是 -S，默认情况下生成的文件名和源文件一致，扩展名为 .s。例如，下面的命令将 C 语言源文件 string.c 编译成汇编语言，文件名为 string.s。\n$ gcc -S string.c 生成和使用静态链接库 静态库是 obj 文件的一个集合，通常静态库以 .a 为后缀。静态库由程序 ar 生成，现在静态库已经不像之前那么普遍了，这主要是由于程序都在使用动态库。\n静态库的优点是可以在不用重新编译程序库代码的情况下，进行程序的重新链接，这种方法节省了编译过程的时间（在编译大型程序的时候，需要花费很长时间）。但是由于现在系统的强大，编译的时间已经不是问题。静态库的另一个优势是开发者可以提供库文件给使用的人员，不用开放源代码，这是库函数提供者经常采用的手段。当然这也是程序模块化开发的一种手段，使每个软件开发人员的精力集中在自己的部分。在理论上，静态库的执行速度比共享库和动态库要快（1% ～ 5% ）。\n生成静态链接库 生成静态库，或者将一个 obj 文件加到已经存在的静态库的命令为 ar 库文件 obj文件1 obj文件2。创建静态库的最基本步骤是生成目标文件，这点前面已经介绍过。然后使用工具 ar 对目标文件进行归档。工具 ar 的 -r 选项，可以创建库，并把目标文件插入到指定库中。例如，将 string.o 打包为库文件 libstr.a 的命令为：\n$ ar -rcs libstr.a string.o 使用静态链接库 在编译程序的时候经常需要使用函数库，例如经常使用的 C 标准库等。GCC 链接时使用库函数和一般的 obj 文件的形式是一致的，例如对 main.c 进行链接的时候，需要使用之前已经编译好的静态链接库 libstr.a, 命令格式如下：\n$ gcc -o test main.c libstr.a 也可以使用命令 -l 库名 进行，库名是不包含函数库和扩展名的字符串。例如编译 main.c 链接静态库 libstr.a 的命令可以修改为：\n$ gcc -o test main.c -lstr 上面的命令将在系统默认的路径下查找 str 函数库，并把它链接到要生成的目标程序上。可能系统会提示无法找到库文件 str , 这是由于 str 库函数没有在系统默认的查找路径下，需要显示指定库函数的路径，例如库文件和当前编译文件在同一目录下：\n$ gcc -o test main.c -L./ -lstr 生成动态链接库 动态链接库是程序运行时加载的库，当动态链接库正确安装后，所有的程序都可以使用动态库来运行程序。动态链接库是目标文件的集合，目标文件在动态链接库中的组织方式是按照特殊方式形成的。库中函数和变量的地址是相对地址，不是绝对地址，其真实地址在调用动态库的程序加载时形成。\n动态链接库的名称有别名(soname)、真名(realname)和链接名(linker name)。别名由一个前缀 lib，然后是库的名字，再加上一个后缀 .so 构成。真名是动态链接库的真实名称，一般总是在别名的基础上加上一个小版本号、发布版本等构成。除此之外，还有一个链接名，即程序链接时使用的库的名字。在动态链接库安装的时候，总是复制库文件到某个目录下，然后用一个软链接生成别名，在库文件进行更新的时候，仅仅更新软链接即可。\n生成动态链接库 生成动态链接库的命令很简单，使用 -fPIC 选项或者 -fpic。 -fPIC 和 -fpic 选项的作用是使得 gcc 生成的代码是位置无关的，例如下面的命令将 string.c 编译生成动态链接库：\n$ gcc -shared -Wl,-soname,libstr.so -o libstr.so.1 string.c 其中，选项 -soname,libstr.so 表示生成动态库时的别名是 libstr.so； -o libstr.so.l 选项则表示是生成名字为 libstr.so.1 的实际动态链接库文件； -shared 告诉编译器生成一个动态链接库。\n生成动态链接库之后一个很重要的问题就是安装，一般情况下将生成的动态链接库复制到系统默认的动态链接库的搜索路径下，通常有/lib 、 /usr/lib 、 /usr/local/lib，放到以上任何一个目录下都可以。\n动态链接库的配置 动态链接库不能随意使用，要在运行的程序中使用动态链接库，需要指定系统的动态链接库搜索的路径，让系统找到运行所需的动态链接库才可以。系统中的配置文件 /etc/ld.so.conf 是动态链接库的搜索路径配置文件。在这个文件内，存放着可被 Linux 共享的动态链接库所在目录的名字（系统目录/lib 、/usr/lib 除外），多个目录名间以空白字符（空格、换行等）或冒号或逗号分隔。查看系统中的动态链接库配置文件的内容：\n$ cat /etc/ld.so.conf include /etc/ld.so.conf.d/*.conf 查看这个文件夹\n$ ls /etc/ld.so.conf.d fakeroot-x86_64-linux-gnu.conf x86_64-linux-gnu.conf i386-linux-gnu.conf zz_i386-biarch-compat.conf libc.conf 从上面的配置文件可以看出， 在系统的动态链接库配置中，包含了该动态库 /lib/i386-linux-gnu 、 /usr/lib/i386-linux-gnu 和 /lib/i686- linux-gnu 、 /usr/lib/i686-linux-gnu 四个目录。\n动态链接库管理命令 为了让新增加的动态链接库能够被系统共享，需要运行动态链接库的管理命令 ldconfig。 ldconfig 命令的作用是在系统的默认搜索路径，和动态链接库配置文件中所列出的目录里搜索动态链接库，创建动态链接装入程序需要的链接和缓存文件。搜索完毕后，将结果写入缓存文件 /etc/ld.so.cache 中，文件中保存的是已经排好序的动态链接库名字列表。ldconfig 命令行的用法如下：\nldconfig [-v|--verbose] [-n] [-N] [-X] [-f CONF] [-C CACHE] [-r ROOT] [-l] [-p|--print-cache] [-c FORMAT] [--format=FORMAT] [-V] [-?|--help|--usage] path... ldconfig 的选项含义：\n   选项 含义     -v 此选项打印 ldconfig 的当前版本号，显示所扫描的每一个目录和动态链接库   -n 此选项处理命令行指定的目录，不对系统的默认目录 /lib 、 /usr/lib 进行扫描，也不对配置文件 /etc/ld.so.conf 中所指定的目录进行扫描   -N 此选项 ldconfig 不会重建缓存文件   -X 此选项 ldconfig 不更新链接   -f CONF 此选项使用用户指定的配置文件代替默认文件 /etc/ld.so.conf   -C CACHE 此选项使用用户指定的缓存文件代替系统默认的缓存文件 /etc/ld.so.cache   -r ROOT 此选项改变当前应用程序的根目录   -l 此选项用于手动链接单个动态链接库   -p \u0026ndash;print-cache 此选项用于打印出缓存文件中共享库的名字    如果想知道系统中有哪些动态链接库，可以使用 ldconfig 的 -p 选项来列出缓存文件中的动态链接库列表。\n使用 ldconfig 命令，默认情况下并不将扫描的结果输出。使用 -v 选项会将 ldconfig 在运行过程中扫描到的目录和共享库信息输出到终端，用户可以看到运行的结果和中间的信息。在执行 ldconfig 后，将刷新缓存文件 /etc/ld.so.cache 。\n当用户的目录并不在系统动态链接库配置文件 etc/ld.so.conf 中指定的时候，可以使用 ldconfig 命令显示指定要扫描的目录，将用户指定目录中的动态链接库放入系统中进行共享。命令格式的形式为：\n$ ldconfig 目录名 这个命令将 ldconfig 指定的目录名中的动态链接库放入系统的缓存 /etc/ld.so.cache 中，从而可以被系统共享使用。\n下面的代码将扫描当前用户的 lib 目录，将其中的动态链接库加入系统：\n$ ldconfig ~/lib  如果在运行上还命令后，再次运行 ldconfig 而没有加参数，系统会将 /lib 、 /usr/lib 及 etc/ld.so.conf 中指定目录中的动态库加入缓存，这时候上述代码中的动态链接库可能不被系统共享了。\n 使用动态链接库 在编译程序时，使用动态链接库和静态链接库是一致的，使用 -l 库名 的方式，在生成可执行文件的时候会链接库文件。例如下面的命令将源文件 main.c 编译成可执行文件 test ，并链接库文件 libstr.a 或者 libstr.so：\n$ gcc -o test main.c -L./ -lstr -L 指定链接动态链接库的路径， -lstr 链接库函数 str 。但是运行 test 一般会出现如下问题：\n./test: error while loading shared libraries: libstr.so: cannot open shared object file: No such file or directory 这是由于程序运行时没有找到动态链接库造成的。程序编译时链接动态链接库和运行时使用动态链接库的概念是不同的，在运行时，程序链接的动态链接库需要在系统目录下才行。有以下几种办法可以解决此问题。\n 将动态链接库的目录放到程序搜索路径中，可以将库的路径加到环境变量 LD_LIBRARY_PATH 中实现，例如：  $ export LD_LIBRARY_PATH=/example/ex02: $LD_LIBRARY_PATH 将存放库文件 libstr.so 的路径 /example/ex02 加入到搜索路径中，再运行程序就没有之前的警告了。\n 另一种方法是使用 ld-Linux.so.2 来加载程序，命令格式为：  /lib/ld-Linux.so.2 --library-path 路径 程序名 加载 test 程序的命令为：\n/lib/ld-Linux.so.2 --library-path /example/ex02 test  如果系统的搜索路径下同时存在静态链接库和动态链接库，默认情况下会链接动态链接库。如果需要强制链接静态链接库， 需要加上 -static 选项，即上述的编译方法改为如下的方式：\n $ gcc -o test main.c -static -lstr 动态加载库 动态加载库和一般的动态链接库所不同的是，一般动态链接库在程序启动的时候就要寻找动态库，找到库函数；而动态加载库可以用程序的方法来控制什么时候加载。\n动态加载库主要有函数 dlopen() dlerror() dlsym() dlclose() 。\n打开动态库 dlopen() 函数 函数 dlopen() 按照用户指定的方式打开动态链接库，其中参数 filename 为动态链接库的文件名，flag为打开方式，一般为 RTLD_LASY， 函数的返回值为库的指针。其函数原型如下：\nvoid *dlopen(const char *filename, int flag); 例如，下面的代码使用 dlopen 打开当前目录下的动态库 libstr.so 。\nvoid *phandle = dlopen(\u0026#34;./libstr.so\u0026#34;, RTLD_LAZY); 获得函数指针 dlsym() 使用动态链接库的目的是调用其中的函数，完成特定的功能。函数 dlsym() 可以获得动态链接库中指定函数的指针，然后可以使用这个函数指针进行操作。函数 dlsym() 的原型如下：\nvoid *dlsym(void *handle, char *symbol); 其中参数 handle 为 dlopen() 打开动态库后返回的句柄，参数 symbol 为函数的名称，返回值为函数指针。\n使用动态加载库的一个例子 下面是一个动态加载库使用的例子。首先使用函数 dlopen() 来打开动态链接库，判断是否正常打开，可以使用函数 dlerror() 判断错误。如果上面的过程正常，使用函数 dlsym() 来获得动态链接库中的某个函数，可以使用这个函数来完成某些功能。其代码如下：\n#include \u0026lt;dlfcn.h\u0026gt; int main(void) {  char src[] = \u0026#34;Hello AimerNeige!\u0026#34;;  int (*pStrLenFun) (char *str);  void *phandle = NULL;  char *perr = NULL;  phandle = dlopen(\u0026#34;./libstr.so\u0026#34;, RTLD_LAZY);   if (!phandle)  {  printf(\u0026#34;Failed Load library!\\n\u0026#34;);  }  perr = dlerror();  if (perr != NULL)  {  printf(\u0026#34;%s\\n\u0026#34;, perr);  return 0;  }   pStrLenFun = dlsym(phandle, \u0026#34;StrLen\u0026#34;);  perr = dlerror();  if (perr != NULL)  {  printf(\u0026#34;%s\\n\u0026#34;, perr);  return 0;  }   printf(\u0026#34;The string length is: %d\\n\u0026#34;, pStrLenFun(src));   dlclose(phandle);  return 0; } 编译上述文件的时候需要链接动态库 libdl.so，使用如下的命令将上述代码编译成可执行文件 testdl。命令将 main.c 编译成可执行文件 testdl，并链接动态链接库 libdl.so。\n$ gcc -o testdl main.c libstr.so -ldl 执行文件 testdl 的结果为：\n$ ./testdl string length is: 18 GCC 常用选项 -DMACRO 选项 定义一个宏，在多种预定义的程序中会经常使用。如下代码根据系统是否定义 Linux 宏来执行不同代码。使用 -D 选项可以选择不同的代码段，例如 -DOS_LINUX 选项将执行代码段（1）。\n#ifdef OS_LINUX ...代码段（1） #else ...代码段（2） #endif  -Idir 将头文件的搜索路径扩大，包含 dir 目录。 -Ldir 将链接时使用的链接库搜索路径扩大，包含 dir 目录。gcc 都会优先使用共享程序库。 -static 仅选用静态程序库进行链接，如果一个目录中静态库和动态库都存在，则仅选用静态库。 -g 包括调试信息。 -On 优化程序，程序优化后执行速度会更快，程序的占用空间会更小。通常 gcc 会进行很小的优化，优化的级别可以选择，即 n。最常用的优化级别是 2。 -Wall 打开所有的 gcc 能够提供的、常用的警告信息。  GCC 常用选项及含义 -Wall 选项集合    GCC 的警告选项 含义     -Wchar-subscripts 这个选项针对数组的下标值，如果下标值是 char 类型的则给出警告。因为在一些平台上， char 类型的变量可能定义为 signed char, 是一个符号类型的整数，所以 char 类型的变量做下标时，当下标的值为负数时可能造成内存溢出。   -Wcomment 这个选项针对代码中的注释，如果出现不合适的注释格式的时候会出现警告。例如在 /*...*/ 中间出现 /*，或者在 //... 类型的注释末尾出现符号 \\ 的时候， GCC 给出警告   -Wformat 这个选项针对输入输出的格式，检查 printf 和 scanf 等格式化输入输出函数的格式字符串与参数类型的匹配情况，如果发现不匹配则发出警告   -Wimplicit 这个选项针对函数的声明，这个选项是选项 -Wimplicit-int 和选项 -Wimplicit-function-declaration 两个选项的集合。第一个选项在声明函数时如果没有指定返回值会给出警告；第二个参数如果在声明前调用函数会给出警告   -Wmissing-braces 这个选项针对结构类型或者数组初始化时的不合适格式。例如， int array[2][2] = {0, 0, 1, 1}; -Wm1ssmg-braces 由于初始化的表达式没有充分用 {} 括起来， GCC 会给出警告，应该采用下面的定义方法：int array[2][2] = { {0, 0}, {1, 1} };   -Wparentheses 这个选项针对多种优先级的操作符在一起或者代码结构难以看明白的操作，如果没有将操作进行明晰地分离， GCC 会给出警告。例如，`if (a \u0026amp;\u0026amp; b   -Wsequenve-point 这个选项针对顺序点，如果在代码中使用了有可能造成顺序点变化的语句， GCC 会给出警告。例如，代码 i = i++ 在不同的平台上 i 值的结果是不同的，如果使用了这样的代码，GCC 会给出警告   -Wswitch 这个选项针对 switch 语句，如果一个 switch 语句中没有 default 条件，GCC 会给出警告信息   -Wunused 这个选项针对代码中没有用到的变量、函数、值、转跳点等， 它是 -Wunused-function 、 -Wunused-label 、 -Wunused-variable 、 -Wunosed-value 选项的集合。 -Wunused-function 选项警告代码中存在没有使用的静态函数，或者只定义却没有实现的静态函数； -Wunused-label 选项警告代码中存在定义了却没有使用，或者使用了却没有定义的标签； -Wunused-variable 选项警告代码中存在定义了却没有使用的局部变量； -Wunused-value 选项警告代码中计算表达式的结果没有使用   -Wunused-parameter 这个选项针对函数参数，如果一个函数的参数在函数实现中没有用到， GCC 会给出警告信息   -Wuninitialized 这个选项针对没有初始化变量的使用，如果一个局部变量在使用之前没有初始化， GCC 会给出警告信息    非 -Wall 警告选项    GCC 的警告选项 含义     -Wflot-equal 这个选项针对浮点值相等的判定，由千浮点值的确切值难以得知，所以如果浮点值出现在相等判定的表达式中， GCC 会给出警告。浮点值的相等判定可以用浮点值的差与某个小值比较判定是否相等   -Wshadow 这个选项用千局部变量作用域内的同名变量，如果局部变量的作用域-Wshadow 范围内有其他同名变量时，局部变量会遮蔽全局变量，这时 GCC 会给出警告信息   -Wbad-functuin-cast 这个选项针对函数的返回值，当函数的返回值赋给不匹配的类型时，GCC 会给出警告信息   -Wsign-compare 这个选项针对有符号数和无符号数的比较，由于无符号数的优先级比有符号数的优先级高，二者进行比较运算的时候，会先将有符号数转换为无符号数。在负的有符号数和无符号数进行比较的时候，容易出现错误   -Waggregate-return 这个选项针对结构类型的函数返回值，如果函数的返回值为结构、联合等类型时， GCC 会给出警告信息   -Wmultichar 这个选项针对字符类型变量的错误赋值，当使用类似 char c = 'test' 这样的代码时， GCC 会给出警告   -Wunreachable-code 这个选项针对冗余代码，如果代码中有不能到达的代码时， GCC 会给出警告信息    其他    GCC 的警告选项 含义     -Wtraditional 选项 traditional 试图支待传统 C 编译器的某些方面    ANSI 兼容    GCC 的警告选项 含义     -ansi 与 ansi 的 C 语言兼容   -pedantic 允许发出 ANSI/ISO C 标准所列出的所有警告   -pedantic-errors 允许发出 ANSI/ISO C 标准所列出的所有错误    编译检查    GCC 的警告选项 含义     -fsynatax-only 仅进行编译检查而不实际编译程序     在编写代码的时候，不好的习惯会造成程序执行过程中发生错误。在一个比较大的项目中， 当程序运行起未后再查找这些错误是很困难的。因此一种好的习惯是使用编译选项将代码的警告信息显示出来，并对代码进行改正。例如，打开编译选项 -Wall 和 -W 来显示所有的警告信息，甚至更严格一些，打开 -Werror 将编译时的警告信息作为错误信息未处理，中断编译。\n ","permalink":"https://aimerneige.com/zh/post/program/tool/gcc-basic/","summary":"GCC 简介 GCC 是 Linux 下的编译工具集，是 GNU Compiler Collection 的缩写,包含 gcc 、 g++ 等编译器。这个工具集不仅包含编译器，还包含其他工具集，例如 ar 、 nm 等。\nGCC 工具集不仅能编译 C/C++ 语言，其他例如 Objective-C 、 Pascal 、 Fortran 、 Java 、 Ada 等语言均能进行编译。\nGCC 在可以根据不同的硬件平台进行编译，即能进行交叉编译，在 A 平台上编译 B 平台的程序，支持常见的 X86 、 ARM 、 PowerPC 、 mips 等，以及 Linux 、 Windows 等软件平台。\nGCC 的 C 编译器 是 gcc，其命令格式为 :\nUsage: gcc [options] file... GCC 下默认文扩展名的含义：\n   文件扩展名 GCC 所理解的含义     *.","title":"GCC 基础"},{"content":" 使用 Nginx 搭建静态网页服务本身是一件非常简单的事，但是我之前在 CSDN 找了几篇教程，弄了一下午也没弄好（不愧是屎山淘金），学了一段时间后端和 Linux 后，我大概只用了五分钟就弄好了，这里写一篇文章来帮助一下小白。\n 阅读须知 在阅读本文章前，你需要准备以下内容\n 掌握基础的 Linux 命令行操作 （本文章将介绍如何在 Linux 服务器上部署静态网页，需要进行终端操作，因此你必须掌握命令行的使用。如果你打算使用 Windows ，请查阅其他文章。） 拥有一台 Linux 服务器 （可以购买 VPS 也可以使用 虚拟机 本文章以 VPS 为例，并购置了域名 （域名非必须） ） 拥有一个静态网站的源码 （如果仅仅作为学习目的，你可以写一个简单的 HTML 文件，这里以使用 hexo 生成的静态网站为例。） 知道 Nginx 是什么，有什么用 （不需要掌握 Nginx）  不同 Linux 发行版下命令会有所区别，本文章以 Ubuntu20.04 为例\n准备服务器 如果你已经有了一台服务器并安装好了 Nginx ，你可以直接跳过这一部分，但是如果你的服务器是新的，没有经过任何配置，请参阅以下内容进行配置。\n升级系统 sudo apt update \u0026amp;\u0026amp; sudo apt upgrade 安装 Nginx sudo apt install nginx 启动 Nginx sudo systemctl start nginx # 开机自动启动 sudo systemctl enable nginx 测试服务 直接在浏览器访问你服务器的 ip，如果你部署了 DNS 服务的话，你也可以直接使用域名。如果哦看到 Nginx 的欢迎界面，服务器准备成功！\n将网站源码发送到服务器 这一步可以有很多的选择，你可以通过 github 来 clone，也可以直接使用一些 ftp 工具。这里演示使用 tar 打包并使用 scp 上传。\n打包压缩源文件 当然，你可以使用其他指令打包压缩或者不压缩，这里使用 xz 压缩以节省网络流量。\ntar -Jcv -f site.tar.xz public/ 将压缩包上传到服务器 scp site.tar.xz root@test.aimerneige.com:~/ 在服务器解压压缩包 通常，我们会将静态网站的源文件放置在 /var/www/ 这个目录下，但是你也可以放置在家目录或其他你喜欢的位置下。当然，你要保证你喜欢的目录没有问题。（喜欢放在 /tmp 下的给爷爬）tar -Jxv -f site.tar.xz -C ./ sudo mv public/ /var/www/blog 配置 Nginx  本文章并不会介绍如何使用 Nginx ，并且阅读本文章并不需要掌握 Nginx，你只需要了解 Nginx 有什么用即可。因为如果只是部署一个简单的静态网页，只需要简单修改默认配置即可。如果你想了解更多关于 Nginx 的内容请查阅其他文章。\n 修改配置 直接使用 vim 修改默认的配置文件即可。 如果你没有安装 vim ，执行 sudo apt install vim 来安装它，当然你也可以使用自己喜欢的编辑器。\nsudo vim /etc/nginx/sites-available/default 找到这一行：\n\troot /var/www/html; 修改为源文件所在目录：\n root /var/www/blog; 如果你需要配置域名，找到这一行：\n\tserver_name _; 将 _ 修改为你的域名。\n检查配置是否正确 sudo nginx -t 如果得到类似如下的输出，则证明配置文件没有错误。\nnginx: the configuration file /etc/nginx/nginx.conf syntax is ok nginx: configuration file /etc/nginx/nginx.conf test is successful 如果你的配置文件出现了问题，请重新修改。\n重启 Nginx sudo nginx -s reload 检查站点 重新访问你的服务器 ip 或域名，检查服务是否成功部署。\n 后记 为什么 Nginx 的配置文件要这样改 Nginx 的默认配置文件位于 /etc/nginx/ 目录下，主配置文件为 nginx.conf\n我们首先看一下默认的主配置文件\nuser www-data; worker_processes auto; pid /run/nginx.pid; include /etc/nginx/modules-enabled/*.conf;  events { \tworker_connections 768; \t# multi_accept on; }  http {  \t## \t# Basic Settings \t##  \tsendfile on; \ttcp_nopush on; \ttcp_nodelay on; \tkeepalive_timeout 65; \ttypes_hash_max_size 2048; \t# server_tokens off;  \t# server_names_hash_bucket_size 64; \t# server_name_in_redirect off;  \tinclude /etc/nginx/mime.types; \tdefault_type application/octet-stream;  \t## \t# SSL Settings \t##  \tssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3; # Dropping SSLv3, ref: POODLE \tssl_prefer_server_ciphers on;  \t## \t# Logging Settings \t##  \taccess_log /var/log/nginx/access.log; \terror_log /var/log/nginx/error.log;  \t## \t# Gzip Settings \t##  \tgzip on;  \t# gzip_vary on; \t# gzip_proxied any; \t# gzip_comp_level 6; \t# gzip_buffers 16 8k; \t# gzip_http_version 1.1; \t# gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;  \t## \t# Virtual Host Configs \t##  \tinclude /etc/nginx/conf.d/*.conf; \tinclude /etc/nginx/sites-enabled/*; }   #mail { #\t# See sample authentication script at: #\t# http://wiki.nginx.org/ImapAuthenticateWithApachePhpScript # #\t# auth_http localhost/auth.php; #\t# pop3_capabilities \u0026#34;TOP\u0026#34; \u0026#34;USER\u0026#34;; #\t# imap_capabilities \u0026#34;IMAP4rev1\u0026#34; \u0026#34;UIDPLUS\u0026#34;; # #\tserver { #\tlisten localhost:110; #\tprotocol pop3; #\tproxy on; #\t} # #\tserver { #\tlisten localhost:143; #\tprotocol imap; #\tproxy on; #\t} #} 去掉全部的注释\nuser www-data; worker_processes auto; pid /run/nginx.pid; include /etc/nginx/modules-enabled/*.conf;  events { \tworker_connections 768; }  http {  \tsendfile on; \ttcp_nopush on; \ttcp_nodelay on; \tkeepalive_timeout 65; \ttypes_hash_max_size 2048;  \tinclude /etc/nginx/mime.types; \tdefault_type application/octet-stream;  \tssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3; # Dropping SSLv3, ref: POODLE \tssl_prefer_server_ciphers on;  \taccess_log /var/log/nginx/access.log; \terror_log /var/log/nginx/error.log;  \tgzip on;  \txml application/xml application/xml+rss text/javascript;  \tinclude /etc/nginx/conf.d/*.conf; \tinclude /etc/nginx/sites-enabled/*; } 默认的服务为什么可以跑呢？注意这一行：\n\tinclude /etc/nginx/sites-enabled/*; 切换到 /etc/nginx/sites-enabled/ 目录下，并查看文件\ncd /etc/nginx/sites-enabled/ ls 我们会发现只有一个 default 文件\n查看它的内容：\n## # You should look at the following URL\u0026#39;s in order to grasp a solid understanding # of Nginx configuration files in order to fully unleash the power of Nginx. # https://www.nginx.com/resources/wiki/start/ # https://www.nginx.com/resources/wiki/start/topics/tutorials/config_pitfalls/ # https://wiki.debian.org/Nginx/DirectoryStructure # # In most cases, administrators will remove this file from sites-enabled/ and # leave it as reference inside of sites-available where it will continue to be # updated by the nginx packaging team. # # This file will automatically load configuration files provided by other # applications, such as Drupal or Wordpress. These applications will be made # available underneath a path with that package name, such as /drupal8. # # Please see /usr/share/doc/nginx-doc/examples/ for more detailed examples. ##  # Default server configuration # server { \tlisten 80 default_server; \tlisten [::]:80 default_server;  \t# SSL configuration \t# \t# listen 443 ssl default_server; \t# listen [::]:443 ssl default_server; \t# \t# Note: You should disable gzip for SSL traffic. \t# See: https://bugs.debian.org/773332 \t# \t# Read up on ssl_ciphers to ensure a secure configuration. \t# See: https://bugs.debian.org/765782 \t# \t# Self signed certs generated by the ssl-cert package \t# Don\u0026#39;t use them in a production server! \t# \t# include snippets/snakeoil.conf;  \troot /var/www/html;  \t# Add index.php to the list if you are using PHP \tindex index.html index.htm index.nginx-debian.html; \t# index test.json;  \tserver_name _;  \tlocation / { \t# First attempt to serve request as file, then \t# as directory, then fall back to displaying a 404. \ttry_files $uri $uri/ =404; \t}  \t# pass PHP scripts to FastCGI server \t# \t#location ~ \\.php$ { \t#\tinclude snippets/fastcgi-php.conf; \t# \t#\t# With php-fpm (or other unix sockets): \t#\tfastcgi_pass unix:/var/run/php/php7.4-fpm.sock; \t#\t# With php-cgi (or other tcp sockets): \t#\tfastcgi_pass 127.0.0.1:9000; \t#}  \t# deny access to .htaccess files, if Apache\u0026#39;s document root \t# concurs with nginx\u0026#39;s one \t# \t#location ~ /\\.ht { \t#\tdeny all; \t#} }   # Virtual Host configuration for example.com # # You can move that to a different file under sites-available/ and symlink that # to sites-enabled/ to enable it. # #server { #\tlisten 80; #\tlisten [::]:80; # #\tserver_name example.com; # #\troot /var/www/example.com; #\tindex index.html; # #\tlocation / { #\ttry_files $uri $uri/ =404; #\t} #} 去掉注释：\nserver { \tlisten 80 default_server; \tlisten [::]:80 default_server;  \troot /var/www/html;  \tindex index.html index.htm index.nginx-debian.html;  \tserver_name _;  \tlocation / { \ttry_files $uri $uri/ =404; \t} } 我相信哪怕没有学习过 Nginx 应该也能理解部分含义。\n接下来我们看一下 /var/www/html 这个目录\ncd /var/www/html ls 只有一个 index.nginx-debian.html 文件，正是欢迎界面的源代码。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Welcome to nginx!\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt;  body {  width: 48em;  margin: 0 auto;  font-family: Tahoma, Verdana, Arial, sans-serif;  } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Welcome to Nginx!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;If you see this page, the nginx web server is successfully installed and working. Further configuration is required.\u0026lt;/p\u0026gt;  \u0026lt;p\u0026gt;For online documentation and support please refer to \u0026lt;a href=\u0026#34;http://nginx.org/\u0026#34;\u0026gt;nginx.org\u0026lt;/a\u0026gt;.\u0026lt;br/\u0026gt; Commercial support is available at \u0026lt;a href=\u0026#34;http://nginx.com/\u0026#34;\u0026gt;nginx.com\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;  \u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Thank you for using nginx.\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 回到 /etc/nginx/sites-enabled/ 目录下，我想你应该明白应该修改什么了吧。\n","permalink":"https://aimerneige.com/zh/post/program/tool/deploy-web-page-with-nginx/","summary":"使用 Nginx 搭建静态网页服务本身是一件非常简单的事，但是我之前在 CSDN 找了几篇教程，弄了一下午也没弄好（不愧是屎山淘金），学了一段时间后端和 Linux 后，我大概只用了五分钟就弄好了，这里写一篇文章来帮助一下小白。\n 阅读须知 在阅读本文章前，你需要准备以下内容\n 掌握基础的 Linux 命令行操作 （本文章将介绍如何在 Linux 服务器上部署静态网页，需要进行终端操作，因此你必须掌握命令行的使用。如果你打算使用 Windows ，请查阅其他文章。） 拥有一台 Linux 服务器 （可以购买 VPS 也可以使用 虚拟机 本文章以 VPS 为例，并购置了域名 （域名非必须） ） 拥有一个静态网站的源码 （如果仅仅作为学习目的，你可以写一个简单的 HTML 文件，这里以使用 hexo 生成的静态网站为例。） 知道 Nginx 是什么，有什么用 （不需要掌握 Nginx）  不同 Linux 发行版下命令会有所区别，本文章以 Ubuntu20.04 为例\n准备服务器 如果你已经有了一台服务器并安装好了 Nginx ，你可以直接跳过这一部分，但是如果你的服务器是新的，没有经过任何配置，请参阅以下内容进行配置。\n升级系统 sudo apt update \u0026amp;\u0026amp; sudo apt upgrade 安装 Nginx sudo apt install nginx 启动 Nginx sudo systemctl start nginx # 开机自动启动 sudo systemctl enable nginx 测试服务 直接在浏览器访问你服务器的 ip，如果你部署了 DNS 服务的话，你也可以直接使用域名。如果哦看到 Nginx 的欢迎界面，服务器准备成功！","title":"使用 Nginx 搭建静态网页服务"},{"content":" 本文章项目地址 https://github.com/AimerNeige/Tutorial.git\n 计算机使用技巧 如果你是一个几乎没有接触过电脑但是却打算入门计算机专业，这篇文章将为你介绍一些基本的计算机使用技巧。\n主要介绍 Windows10 的一些使用技巧，如果你是 mac 用户，请自行查阅其他文章，但是如果你是 Linux 用户，我觉得你应该不需要看我的文章。\n杀毒软件 或许你会在较旧的电脑上见到诸如360 安全卫士，金山毒霸，电脑管家等杀毒软件，受其影响，你或许也会在电脑上安装这些软件，但是，对于计算机专业来说，这些软件不仅无用而且会给你的学习带来很多麻烦。请 务必 立即 删除它们。\n 但是，没有杀毒软件的话，电脑中毒怎么办啊？\n 如果你的电脑是刚到手的笔记本，我相信你的预装系统是 Windows10。 而 windows 本身会预装 Windows Defender ，对于一般的病毒，Windows Defender 完全可以保护你的电脑，而且如果使用习惯良好，不下载使用来源不明的文件的话，即使没有任何杀毒软件也是可以的。但是你非要有双保险才放心，一定要安装杀毒软件的话，我推荐 火绒杀毒 https://www.huorong.cn/ 。这款软件的个人版完全免费而且没用任何广告弹窗。\n 删了它们我怎么清理电脑垃圾啊？\n 在旧电脑上用的硬盘是机械硬盘，而机械硬盘的磁盘碎片会影响电脑系统运行速度，在旧电脑上清理垃圾确实有用且会提升电脑运行速度，但是现在的电脑用的都是固态硬盘，这些磁盘垃圾并不会影响电脑性能，不会影响系统的运行速度，最多只是占一些存储空间，如果你非要清理的话，我推荐你使用 CCleaner https://www.ccleaner.com/。\n 没有软件管家我不会下载软件了怎么办？\n 要养成去官网下载软件的好习惯，比如我们想要安装 QQ 就使用搜索引擎搜索 QQ 的官网，找到 QQ 的官网 http://im.qq.com/ ，然后在官网下载安装包。类是地，我们同样可以在 Visual Studio Code 的官网 https://code.visualstudio.com/ 上下载 Visual Studio Code 的安装包。如果一个软件没有官网，你也可以在一些受信任的网站上下载它，不过大部分软件都会有官网的，除非你在下载破解软件或者其他上古软件。\n 没有电脑管家我如何管理系统自启动啊？\n 禁用开机自启动：\n启动任务管理器，点击 启动 找到想要禁用的自启项，右击，选择禁用。\n设置开机自启动：\n按住 Win 键（左下角有 windows 徽标的按键）然后按 R, 在弹出的运行框中输入 shell:startup 将软件的 快捷方式 放在这个目录下即可。\n 我想要那个网速显示的悬浮窗！！\n 这个软件可能会帮到你 https://github.com/zhongyang219/TrafficMonitor。\n 没有加速球电脑会不会卡啊？\n 首先，如果你的电脑配置不是很差的话，写代码基本上不会发生卡顿现象，加速球的用处并不大，相反的，它还会占用系统资源，反而有可能导致电脑卡顿。\n 你说的有道理，但是我就是想点那个加速球怎么办啊？\n 慢慢习惯吧。\n 文章好棒，但是我就是只要不点加速球，不发射小火箭就浑身难受，习惯不了啊怎么办？\n ，，，，保安呢？保安在那里啊！这里有人捣乱，砸场子呢！！！\n浏览器 浏览器首推 Chrome 你可以在 Chrome 的官网 https://www.google.com/chrome/ 快速下载它，同时，我也推荐以下几款浏览器：\nChromium https://www.chromium.org/ Chrome 的开源版。\nCentBrowser 百分浏览器 http://www.centbrowser.com/ Chromium 的一个分支版本，有一些额外的小功能。\n当然，如果你无法访问谷歌的话，上面这几款浏览器没有同步还是很难受的，你同样可以选择这几款：\nFirefox https://www.mozilla.org/zh-CN/firefox/\n 注意不要下载国内定制版 https://www.firefox.com.cn/ FireFox (AD Pro Plus For China User)\n Edge https://www.microsoft.com/zh-cn/edge 注意是新版 Edge 不是 Win10 自带的那个。\n此外还有 Firefox Dev 版本 https://www.mozilla.org/zh-CN/firefox/developer/ 可以用来调试 web 程序。\n至于其他浏览器，诸如 QQ 浏览器，猎豹急速浏览器，360 安全浏览器之类的软件请立即卸载。\n更多 大概就说这么多吧，只要不安装国产的垃圾杀毒软件和浏览器，你的电脑使用起来绝对会很舒服。\n本仓库保持更新，想到其他内容之后会添加。\n如果你有好的内容欢迎 pr。\nhttps://github.com/AimerNeige/Tutorial.git\n","permalink":"https://aimerneige.com/zh/post/others/tips-using-windows10/","summary":"本文章项目地址 https://github.com/AimerNeige/Tutorial.git\n 计算机使用技巧 如果你是一个几乎没有接触过电脑但是却打算入门计算机专业，这篇文章将为你介绍一些基本的计算机使用技巧。\n主要介绍 Windows10 的一些使用技巧，如果你是 mac 用户，请自行查阅其他文章，但是如果你是 Linux 用户，我觉得你应该不需要看我的文章。\n杀毒软件 或许你会在较旧的电脑上见到诸如360 安全卫士，金山毒霸，电脑管家等杀毒软件，受其影响，你或许也会在电脑上安装这些软件，但是，对于计算机专业来说，这些软件不仅无用而且会给你的学习带来很多麻烦。请 务必 立即 删除它们。\n 但是，没有杀毒软件的话，电脑中毒怎么办啊？\n 如果你的电脑是刚到手的笔记本，我相信你的预装系统是 Windows10。 而 windows 本身会预装 Windows Defender ，对于一般的病毒，Windows Defender 完全可以保护你的电脑，而且如果使用习惯良好，不下载使用来源不明的文件的话，即使没有任何杀毒软件也是可以的。但是你非要有双保险才放心，一定要安装杀毒软件的话，我推荐 火绒杀毒 https://www.huorong.cn/ 。这款软件的个人版完全免费而且没用任何广告弹窗。\n 删了它们我怎么清理电脑垃圾啊？\n 在旧电脑上用的硬盘是机械硬盘，而机械硬盘的磁盘碎片会影响电脑系统运行速度，在旧电脑上清理垃圾确实有用且会提升电脑运行速度，但是现在的电脑用的都是固态硬盘，这些磁盘垃圾并不会影响电脑性能，不会影响系统的运行速度，最多只是占一些存储空间，如果你非要清理的话，我推荐你使用 CCleaner https://www.ccleaner.com/。\n 没有软件管家我不会下载软件了怎么办？\n 要养成去官网下载软件的好习惯，比如我们想要安装 QQ 就使用搜索引擎搜索 QQ 的官网，找到 QQ 的官网 http://im.qq.com/ ，然后在官网下载安装包。类是地，我们同样可以在 Visual Studio Code 的官网 https://code.visualstudio.com/ 上下载 Visual Studio Code 的安装包。如果一个软件没有官网，你也可以在一些受信任的网站上下载它，不过大部分软件都会有官网的，除非你在下载破解软件或者其他上古软件。\n 没有电脑管家我如何管理系统自启动啊？\n 禁用开机自启动：\n启动任务管理器，点击 启动 找到想要禁用的自启项，右击，选择禁用。","title":"写给小白的 win10 使用技巧"},{"content":"首先来看下 w3schools 的解释：\n Example Check if the number 5 is an integer:\nx = isinstance(5, int)  Definition and Usage The isinstance() function returns True if the specified object is of the specified type, otherwise False.\nIf the type parameter is a tuple, this function will return True if the object is one of the types in the tuple.\n Syntax isinstance(object, type)\nParameter Values    Parameter Description     object Required. An object.   type A type or a class, or a tuple of types and/or classes     More Examples Example Check if \u0026ldquo;Hello\u0026rdquo; is one of the types described in the type parameter:\nx = isinstance(\u0026#34;Hello\u0026#34;, (float, int, str, list, dict, tuple)) Example Check if y is an instance of myObj:\nclass myObj:  name = \u0026#34;John\u0026#34;  y = myObj()  x = isinstance(y, myObj)  Related Pages The issubclass() function, to check if an object is a subclass of another object.\n来源： https://www.w3schools.com/python/ref_func_isinstance.asp\n 帮助那些英语不好的 python 学习者翻译一下：\n 示例 检查数字 5 是否是一个整数。\nx = isinstance(5, int) 定义和用法 如果给定的对象是一个已知的对象类型，函数 isinstance() 返回 True ，否则返回False 。\n如果参数 type 是元组的话，当对象是元组中的一个类型时，这个函数会返回 True 。\n语法 isinstance(object, type) 参数    参数 描述     object 必须。 一个示例对象。   type 基本类型或者类，或是由他们组成的元组。    更多示例 示例 检查 \u0026ldquo;Hello\u0026rdquo; 是否是参数表中描述的类型之一。\nx = isinstance(\u0026#34;Hello\u0026#34;, (float, int, str, list, dict, tuple)) 示例 检查 y 是否是 myObj 的实例。\nclass myObj: name = \u0026#34;John\u0026#34;  y = myObj()  x = isinstance(y, myObj) 相关内容： issubclass() 函数用来检查一个对象是否是另一个对象的子类。\n 接下来看一下菜鸟教程的解释\n Python isinstance() 函数 描述 isinstance() 函数来判断一个对象是否是一个已知的类型，类似 type()。\n isinstance() 与 type() 区别：\n type() 不会认为子类是一种父类类型，不考虑继承关系。 isinstance() 会认为子类是一种父类类型，考虑继承关系。  如果要判断两个类型是否相同推荐使用 isinstance()。\n 语法 以下是 isinstance() 方法的语法:\nisinstance(object, classinfo) 参数  object \u0026ndash; 实例对象。 classinfo \u0026ndash; 可以是直接或间接类名、基本类型或者由它们组成的元组。  返回值 如果对象的类型与参数二的类型（classinfo）相同则返回 True，否则返回 False。。\n 实例 以下展示了使用 isinstance 函数的实例：\n\u0026gt;\u0026gt;\u0026gt; a = 2 \u0026gt;\u0026gt;\u0026gt; isinstance (a,int) True \u0026gt;\u0026gt;\u0026gt; isinstance (a,str) False \u0026gt;\u0026gt;\u0026gt; isinstance (a,(str,int,list)) # 是元组中的一个返回 True True type() 与 isinstance()区别： class A:  pass  class B(A):  pass  isinstance(A(), A) # returns True type(A()) == A # returns True isinstance(B(), A) # returns True type(B()) == A # returns False 来源： https://aimerneige.com/2020/05/29/Daily-Python-Tips-isinstance/\n 更多示例：\n# 检查传入的参数是否符合要求 def log(val:\u0026#39;str\u0026#39;): assert isinstance(val, str), \u0026#39;val is not str\u0026#39; print(val） ","permalink":"https://aimerneige.com/zh/post/program/python/daily-python-tips/","summary":"首先来看下 w3schools 的解释：\n Example Check if the number 5 is an integer:\nx = isinstance(5, int)  Definition and Usage The isinstance() function returns True if the specified object is of the specified type, otherwise False.\nIf the type parameter is a tuple, this function will return True if the object is one of the types in the tuple.\n Syntax isinstance(object, type)\nParameter Values    Parameter Description     object Required.","title":"每天一个 Python 小知识 isinstance"},{"content":"排名不分先后，按照添加时间排序。\n.friends { padding: 1em 0; border: 2px solid transparent; border-bottom: 1px dashed var(--color-contrast-low); display: flex; transition: all .5s; } .friends .friend { text-decoration: none; text-overflow: ellipsis; overflow: hidden; white-space: nowrap; } .friends .name { font-weight: bold; margin: 0.375em 0; } .friends .excerpt { font-size: 0.875em; text-overflow: ellipsis; overflow: hidden; white-space: nowrap; } .friends .avatar { width: 4em !important; height: 4em !important; margin: 0 1em 0 0 !important; z-index: 0; }  伞 一只咸鱼的学习记录    HelloWorld的小博客 这里是一个小白的博客    TangZ TangZ 的个人页面    Kenvix 党明学姐    HeoLis We need to go faster and deeper.    🔨 🔨のBlog    异国迷宫的十字路口 一位弱鸡带学生的个人博客    Gaein nidb Gaein nidb的网站    fzf404 fzf的网站    凛凛酱 傻逼凛凛    Web-Worker 道阻且长,行则将至。    vritser 半斤八两    Anduin Xue Software engineer at 𝙈𝙞𝙘𝙧𝙤𝙨𝙤𝙛𝙩.    Holk AI researcher    ","permalink":"https://aimerneige.com/zh/friends/","summary":"排名不分先后，按照添加时间排序。\n.friends { padding: 1em 0; border: 2px solid transparent; border-bottom: 1px dashed var(--color-contrast-low); display: flex; transition: all .5s; } .friends .friend { text-decoration: none; text-overflow: ellipsis; overflow: hidden; white-space: nowrap; } .friends .name { font-weight: bold; margin: 0.375em 0; } .friends .excerpt { font-size: 0.875em; text-overflow: ellipsis; overflow: hidden; white-space: nowrap; } .friends .avatar { width: 4em !important; height: 4em !important; margin: 0 1em 0 0 !important; z-index: 0; }  伞 一只咸鱼的学习记录    HelloWorld的小博客 这里是一个小白的博客    TangZ TangZ 的个人页面    Kenvix 党明学姐    HeoLis We need to go faster and deeper.","title":"Friends"},{"content":" 中北大学学生，学习物联网专业。Linux 用户，热爱开源和分享。\n 技能  使用的编程语言，软件和服务\n  golang python JavaScript Linux git mysql  工具  neovim VSCode VirtualBox Dbeaver Inkdrop Spotify  语言  中文 英语  教育  中北大学 宁武县高级中学 宁武一中  联系我 GitHub: https://github.com/AimerNeige/\n邮件: aimer.neige@aimerneige.com\n电报: @AimerNeige\n域名: aimerneige.com\n我的故乡 ","permalink":"https://aimerneige.com/zh/about/","summary":" 中北大学学生，学习物联网专业。Linux 用户，热爱开源和分享。\n 技能  使用的编程语言，软件和服务\n  golang python JavaScript Linux git mysql  工具  neovim VSCode VirtualBox Dbeaver Inkdrop Spotify  语言  中文 英语  教育  中北大学 宁武县高级中学 宁武一中  联系我 GitHub: https://github.com/AimerNeige/\n邮件: aimer.neige@aimerneige.com\n电报: @AimerNeige\n域名: aimerneige.com\n我的故乡 ","title":"关于我 👨‍💻"}]