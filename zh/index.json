[{"content":"前言 距离上一次写博客文章已经很长时间了，因为经常重装系统，而每次在电脑上安装和配置 hexo 的博客都是一件比较麻烦的事情，于是就一直咕了。但是最近我发现了 hugo 这一简洁好用的博客系统，可以让我远离配置安装都又慢又麻烦的 hexo，使用下来体验很棒，而我恰好又打算换一个博客主题，于是决定使用 hugo 来搭建我的新博客。本文简要介绍如何安装和使用 hugo。\n安装 你可能需要  go 的开发环境 git 一个顺手的编辑器  你一定不需要  nodejs npm  安装 hugo 要安装 hugo 非常简单，以 fedora 系统为例，只需要执行如下指令：\nsudo dnf install hugo 创建站点文件夹 使用以下指令创建你的站点文件夹：\nhugo new site blog 切换到工作目录进行后续操作：\ncd blog 使用 git 进行版本控制：\ngit init 安装主题 挑选好合适的主题后，将其直接 clone 在 ./themes 文件夹下即可。\ngit clone https://github.com/adityatelange/hugo-PaperMod themes/PaperMod --depth=1  使用 --depth=1 参数会忽略历史 commit 记录。\n 当然，下载解压压缩包的方式也是可以的。\n如果想要方便版本控制和更新，使用如下指令添加 submodule：\ngit submodule add https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod --depth=1 当重新 clone 仓库后，执行如下指令 clone 主题子仓库：\ngit submodule update --init --recursive 更新主题：\ngit submodule update --remote --merge 配置 hugo 支持多种配置文件格式，由于 yaml 格式的配置文件更易读，下文将默认使用 yaml 配置。\n与 hexo 不同，hugo 的配置文件只有一个，按照你所使用的主题提供的文档来修改你的配置文件即可。\n应用主题 theme: \u0026#34;PaperMod\u0026#34; 修改主题配置 不同的主题会有不同的配置方法，具体查看主题提供的文档。\n请参考如下配置：\nbaseURL: \u0026#34;https://aimerneige.com/\u0026#34; languageCode: \u0026#34;en-us\u0026#34; title: \u0026#34;AimerNeige\u0026#39;s Blog\u0026#34; theme: \u0026#34;PaperMod\u0026#34; enableRobotsTXT: true buildDrafts: false buildFuture: false buildExpired: false defaultContentLanguage: en defaultContentLanguageInSubdir: true languages: en: languageName: \u0026#34;English\u0026#34; weight: 1 menu: main: - name: About url: about/ weight: 5 - name: Friends url: friends/ weight: 6 - name: Post url: post/ weight: 7 - name: Archive url: archives/ weight: 8 - name: Tags url: tags/ weight: 9 - name: Categories url: categories/ weight: 10 - name: Search url: search/ weight: 11 zh: languageName: \u0026#34;中文\u0026#34; weight: 2 menu: main: - name: 关于 url: about/ weight: 5 - name: 朋友 url: friends/ weight: 6 - name: 文章 url: post/ weight: 7 - name: 归档 url: archives/ weight: 8 - name: 标签 url: tags/ weight: 9 - name: 分类 url: categories/ weight: 10 - name: 搜索 url: search/ weight: 11 params: profileMode: enabled: true title: \u0026#34;Aimer Neige\u0026#34; subtitle: \u0026#34;技术宅拯救世界\u0026#34; imageUrl: \u0026#34;https://avatars.githubusercontent.com/u/51701792?v=4\u0026#34; imageTitle: \u0026#34;avatar.jpeg\u0026#34; imageWidth: 140 imageHeight: 140 params: env: production keywords: [Blog, OpenSource, Coding, Golang, Programming] author: \u0026#34;Aimer Neige\u0026#34; defaultTheme: auto disableThemeToggle: false ShowToc: true TocOpen: false ShowBreadCrumbs: true ShowReadingTime: false ShowPostNavLinks: true ShowShareButtons: false ShowCodeCopyButtons: true displayFullLangName: true editPost: URL: \u0026#34;https://github.com/aimerneige/blog/content\u0026#34; Text: \u0026#34;Suggest Changes\u0026#34; appendFilePath: true homeInfoParams: Title: \u0026#34;Aimer Neige\u0026#34; Content: \u0026#34;Tech Otakus Save The World\u0026#34; profileMode: enabled: true title: \u0026#34;Aimer Neige\u0026#34; subtitle: \u0026#34;Tech Otakus Save The World\u0026#34; imageUrl: \u0026#34;https://avatars.githubusercontent.com/u/51701792?v=4\u0026#34; imageTitle: \u0026#34;avatar.jpeg\u0026#34; imageWidth: 140 imageHeight: 140 socialIcons: - name: github url: \u0026#34;https://github.com/AimerNeige\u0026#34; - name: twitter url: \u0026#34;https://twitter.com/NeigeAimer\u0026#34; - name: steam url: \u0026#34;https://steamcommunity.com/id/AimerNeige\u0026#34; - name: Telegram url: \u0026#34;https://t.me/AimerNeige\u0026#34; - name: KoFi url: \u0026#34;https://ko-fi.com/aimerneige\u0026#34; - name: RsS url: \u0026#34;index.xml\u0026#34; taxonomies: category: categories tag: tags series: series outputs: home: - HTML - RSS - JSON 迁移 将原有文章复制到站点文件夹下，修改配置。\n测试 使用如下指令启动本地测试服务。\nhugo serve -D 部署 使用如下指令生成静态文件：\nhugo 之后上传到 github 即可：\ncd public git add -A git commit -m \u0026#34;commit message\u0026#34; git push ","permalink":"https://aimerneige.com/zh/post/hello-hugo/","summary":"前言 距离上一次写博客文章已经很长时间了，因为经常重装系统，而每次在电脑上安装和配置 hexo 的博客都是一件比较麻烦的事情，于是就一直咕了。但是最近我发现了 hugo 这一简洁好用的博客系统，可以让我远离配置安装都又慢又麻烦的 hexo，使用下来体验很棒，而我恰好又打算换一个博客主题，于是决定使用 hugo 来搭建我的新博客。本文简要介绍如何安装和使用 hugo。\n安装 你可能需要  go 的开发环境 git 一个顺手的编辑器  你一定不需要  nodejs npm  安装 hugo 要安装 hugo 非常简单，以 fedora 系统为例，只需要执行如下指令：\nsudo dnf install hugo 创建站点文件夹 使用以下指令创建你的站点文件夹：\nhugo new site blog 切换到工作目录进行后续操作：\ncd blog 使用 git 进行版本控制：\ngit init 安装主题 挑选好合适的主题后，将其直接 clone 在 ./themes 文件夹下即可。\ngit clone https://github.com/adityatelange/hugo-PaperMod themes/PaperMod --depth=1  使用 --depth=1 参数会忽略历史 commit 记录。\n 当然，下载解压压缩包的方式也是可以的。\n如果想要方便版本控制和更新，使用如下指令添加 submodule：\ngit submodule add https://github.","title":"Hello Hugo"},{"content":"前言 之前在学习安卓的时候，很想要给自己的软件增加一个云服务功能，但是苦于没有学过后端，于是开始在互联网上查找资料。但是遗憾的是，后端是一个很大的范围，我查找了很多后端的资料也几乎都是在讲解如何写网页，并没有专门用来给安卓写后端的教程，在广泛地学习了大量后端内容后，成功的为自己的程序开发了一个简单的 API。希望这篇文章能够帮到那些没有系统地学习过后端，但是却想要快速开发一款能用的 API 的安卓开发者。\n前期准备  你要了解互联网通讯原理 你要会一些基础的 JavaScript 你要有一台服务器 你会数据库操作 最好有一个域名（非必须） 掌握基础的终端操作  环境配置 本文章中后端开发使用的开发语言为 JavaScript 配合 nodejs。数据库采用常用的 mysql。\n 注： nodejs 开发常用的数据库是 mongodb，但是由于 mysql 比较常用这里就用 mysql 了，当然其他数据库也是可以的，你可以查找一下 nodejs 如何链接这些数据库，并将本文中 mysql 操作的部分替换掉就可以了。\n 本地测试客户端安装 你需要在自己用来开发的电脑上安装配置如下环境：\n nodejs npm  安装 nodejs Linux 下直接使用包管理安装即可。如果包管理安装的 node 很旧，可以自行谷歌一下安装方法，这里不再赘述。\n以 Ubuntu 为例，直接在终端执行如下指令：\nsudo apt install nodejs 安装完成后使用 node -v 查看 node 版本来确认安装是否成功。\n如果是 windows 用户就更加简单了，直接在 nodejs 官网 下载安装包运行即可。推荐使用长周期稳定版本。如果你想体验新特性，也可以考虑使用最新的版本。\n安装 npm 通常情况下，安装 nodejs 时会附带安装 npm，你可以直接使用 npm -v 来查看当前系统安装的 npm 版本来检测安装情况。\n如果没有安装，以 Ubuntu 系统为例，可以在终端执行下面的指令：\nsudo apt install npm windows 用户在执行完 node 的安装程序后 npm  会自动安装完成。\n服务器安装 你需要在服务器上安装配置如下环境：\n nodejs npm mysql nginx  安装 nodejs 与 npm 其中 nodejs 和 npm 的安装同客户端完全相同，这里不再赘述。\n安装 mysql mysql 可以一并安装在运行 node 项目的服务器上，也可以使用独立的数据库提供服务器。\n本文章主要讨论如何构建 API ，这里不再赘述如何安装配置 mysql。可以查看我的其他文章。\n安装 nginx nginx 用于将服务反向代理到 80 端口，以 Ubuntu 系统为例，直接在终端执行如下指令：\nsudo apt install nginx Windows 用户自行查阅相关资料。不会吧，不会吧，不会有人服务器用 windows 吧？？项目构建 使用模版 为了方便快速构建一个项目，我写了一个模版，你可以在 GitHub 上找到它。\n使用这个模版快速构建一个新的仓库，将它 clone 到本地，并进行下面的修改：\n 修改 package.json 修改 LICENSE 修改 README 在 src/config 下新建 db.js 写入数据库服务器的配置。  安装依赖 在项目路径下启动终端，执行如下指令：\nnpm i 这个指令是 npm install 的缩写，npm 会安装需要的依赖，本模版项目只依赖了俩个包：\n express mysql  依赖安装完成后，你会在项目路径下看到 node_modules 这个文件夹，它已经被写在 .gitignore 中，这个文件夹下是项目所需要的依赖，即使你意外地删掉了这个文件夹，再次执行 npm i 就可以将这些文件下载回来，所以你不应该在意这个文件夹中有什么内容，npm 会帮我们处理它。\n启动项目 使用 cd 命令切换到 src 目录下，执行下面的指令：\nnode app.js 之后你会在终端看到如下输出：\nServer start in development mode on http://localhost:4000; press Ctrl + C to terminated. 打开你的浏览器访问 http://localhost:4000/\n如果你看到下面的内容，说明项目成功启动了：\n{ \u0026#34;status\u0026#34;: 200, \u0026#34;info\u0026#34;: \u0026#34;If you see this, the server deploy success!\u0026#34; } 如果你在服务器启动项目，假设你的服务器 ip 为 43.192.82.215 并且配置了域名 api.aimerneige.com ，你可以通过在浏览器内访问下面的地址测试服务器：\n http://43.192.82.215:4000/ http://api.aimerneige.com:4000/  注意：\n 在本地测试启动的服务器只能通过 本地/内网 访问 在有公网 ip 的服务器上部署的服务可以在 任意浏览器内 打开  如果你在服务器测试，请注意以这样的方式运行仅能用来测试，不可以用作生产环境，后文会介绍如何在服务器部署项目。\n程序入口 项目可以启动后，说明环境配置无误，接下来可以开始写代码了。\n我们简单看一下程序的入口 app.js\n本项目依赖 express 构建，首先导入 express 的模块：\n// require const express = require(\u0026#34;express\u0026#34;); 接下来导入路由目录下的路由模块：\n// user require const indexRouter = require(\u0026#34;./routes/index\u0026#34;); 创建 express 对象：\n// express app var app = express(); 设置监听端口：\n// set port app.set(\u0026#34;port\u0026#34;, process.env.PORT || 4000); 添加可以支持 json 解析的中间件：\n// json parse app.use(express.json()); app.use(express.urlencoded({ extended: false })); 添加路由中间件：\n// routes app.use(\u0026#34;/\u0026#34;, indexRouter); 路由匹配失败后返回 404 错误：\n// catch 404 and forward to error handler app.use(function (req, res, next) { var err = new Error(\u0026#34;Not Found\u0026#34;); err.status = 404; next(err); }); 处理错误信息：\n// error handler app.use(function (err, req, res, next) { res.type(\u0026#34;application/json\u0026#34;); res.status(err.status || 500); res.send({ status: err.status || 500, message: err.message, }); }); 检测当前模块是否被直接执行，如果是则启动服务器，否者导出模块：\n// check if run app.js directly if (require.main === module) { app.listen(app.get(\u0026#34;port\u0026#34;), function () { console.log( \u0026#34;Server start in \u0026#34; + app.get(\u0026#34;env\u0026#34;) + \u0026#34; mode on http://localhost:\u0026#34; + app.get(\u0026#34;port\u0026#34;) + \u0026#34;; press Ctrl + C to terminated.\u0026#34; ); }); } else { module.exports = app; } 其他的代码可以暂时不去理会，最重要的是路由这一部分：\n// 导入路由模块 const indexRouter = require(\u0026#34;./routes/index\u0026#34;); // 添加路由中间件 app.use(\u0026#34;/\u0026#34;, indexRouter); 在编写 api 时，只需要在 /src/routes 目录下新建路由模块，并在 app.js 下引用即可。\n添加路由 接下来我们看一下默认的路由模块 index.js ：\n导入 express 模块：\nconst express = require(\u0026#34;express\u0026#34;); const router = express.Router(); 配置路由规则：\nrouter.get(\u0026#34;/\u0026#34;, function (req, res, next) { res.type(\u0026#34;application/json\u0026#34;); res.status(200); res.send({ status: 200, info: \u0026#34;If you see this, the server deploy success!\u0026#34;, }); }); 导出模块：\nmodule.exports = router; 其中重点即配置路由规则这一部分。\n我相信这几行代码还是很易懂的，相对地，如果我们想要使用 post 方法，访问路径为 /about 需要这样写：\nrouter.post(\u0026#34;/about\u0026#34;, fuction(){ /* function */ } ); 设置好请求方法和请求路径后，回调函数用来向客户端返回数据。\n设置返回数据类型，这里使用 json 进行数据传输：\nres.type(\u0026#34;application/json\u0026#34;); 设置返回状态码：\nres.status(200); 返回指定数据：\nres.send(return_data); 由于开发语言为 js ，而且本项目添加了解析 json 的中间件，如果想要返回 json，不需像其他语言那样要将对象解析为 json 字符串，直接返回一个对象即可，客户端会成功接收到正确的 json 字符串。\n// 服务器返回的对象 { status: 200, info: \u0026#34;If you see this, the server deploy success!\u0026#34;, } // 客户端拿到的字符串 { \u0026#34;status\u0026#34;: 200, \u0026#34;info\u0026#34;: \u0026#34;If you see this, the server deploy success!\u0026#34; } 书写好路由模块后在 app.js 中引用即可：\n// 导入模块 const indexRouter = require(\u0026#34;./routes/index\u0026#34;); // ... 中间的其他代码  // 在 app 中应用路由模块 app.use(\u0026#34;/\u0026#34;, indexRouter); 要注意模块导入的位置，不能乱放。和模版保持一致即可。\n添加更多的路由信息 就像上面的例子中所写的，我们可以继续添加新的路由模块，也可以在同一个路由模块下添加更多的访问路径。\n src/app.js  // ...  const indexRouter = require(\u0026#34;./routes/index\u0026#34;); const userRouter = require(\u0026#34;./routes/user\u0026#34;); // ...  app.use(\u0026#34;/\u0026#34;, indexRouter); app.use(\u0026#34;/user\u0026#34;, userRouter);  src/routes/index.js  // ...  // 访问路径 / router.get(\u0026#34;/\u0026#34;, fuction(){ /* function */ } ); // 访问路径 /about router.get(\u0026#34;/about\u0026#34;, function() { /* function */ }); // ...  src/routes/user.js  // ...  // 访问路径 /user/cat router.get(\u0026#34;/cat\u0026#34;, fuction(){ /* function */ } ); // 访问路径 /user/edit router.post(\u0026#34;/edit\u0026#34;, fuction(){ /* function */ } ); // 访问路径 /user/new router.psot(\u0026#34;/new\u0026#34;, fuction(){ /* function */ } ); // ... 获取客户端数据 获取请求参数信息 req.query 对象是由客户端请求参数构成的，在回调函数内，可以直接调用它来获取客户端请求参数，如果客户端传递了参数，我们就可以拿到对应的数据，否者我们只能得到 undefined。由此可以通过判空来确定客户端请求参数是否正确。\n例如我们的请求路径为 /data 所需请求参数为 id 和 class 可以这样写：\n 注： 对应的示例请求地址为 https://api.example.com/data?id=1930201\u0026amp;class=302\n router.get(\u0026#34;/data\u0026#34;, function (req, res) { res.type(\u0026#34;application/json\u0026#34;); if (req.query.class === undefined || req.query.id === undefined) { res.status(400); // 向客户端返回错误信息，提示客户端返回正确的参数  res.send({ status: 400, info: \u0026#34;Wrong arguments!\u0026#34;, }); } else { // 向用户返回数据（通常会用客户端参数来调用数据库，为了简便这里返回一个类做简单示范）  res.status(200); res.send({ status: 200, info: { class: req.query.class, id: req.query.id, }, }); } }); 我们可以通过判空来确定客户端请求参数是否正确，之后可以使用参数来进行其他操作，比如构建类，调取数据库等等。\n获取请求体信息 与请求参数类似，请求体信息也保存在一个类中，就是 req.body。使用方法和之前请求参数完全一致，这里只写一个示例，不多赘述。\nrouter.post(\u0026#34;/new\u0026#34;, function (req, res) { res.type(\u0026#34;application/json\u0026#34;); if (req.body.class === undefined || req.body.id === undefined) { res.status(400); // 向客户端返回错误信息，提示客户端返回正确的参数  res.send({ status: 400, info: \u0026#34;Wrong arguments!\u0026#34;, }); } else { var new_student = { class: req.body.class, id: req.body.id, }; // 向数据库内添加新的学生  res.status(200); res.send({ status: 200, info: \u0026#34;Student create successful!\u0026#34;, }); } }); 获取更多信息 在回调函数中，req 对象中保存了所有来自客户请求的数据，前面介绍的只是比较常用的，其他内容可以查找文档。\n获取数据库信息 配置数据库信息 参考 db.js.example 创建 db.js 写入服务器的配置\nvar mysql = require(\u0026#34;mysql\u0026#34;); var pool = mysql.createPool({ host: \u0026#34;host_ip\u0026#34;, user: \u0026#34;user_name\u0026#34;, password: \u0026#34;password\u0026#34;, database: \u0026#34;data\u0026#34;, port: 3306, }); function query(sql, callback) { pool.getConnection(function (err, connection) { connection.query(sql, function (err, rows) { callback(err, rows); connection.release(); }); }); } exports.query = query; 配置好数据库服务器后，就可以通过下面的方法访问数据库的数据了：\nsql_command = \u0026#34;DROP DATABASE *;\u0026#34;; // ⚠️ 注意修改 db.query(sql_command, function (err, result, fields) { if (err) { // 如果数据库指令执行出现了错误，返回错误信息  requestSQLFailedLog(sql_command, err); res.status(400); res.send({ status: 400, info: err }); } else { // 如果数据库指令执行成功，返回数据  requestSQLSuccessLog(sql_command, result); res.status(200); res.send(result); } }); 服务部署  待完善，咕咕咕\n  将项目上传到服务器 修改 db.js 的配置 cd src node cluster.js 如果你想要后台运行，执行 nohup node cluster.js \u0026amp;  ","permalink":"https://aimerneige.com/zh/post/build-api-with-nodejs-quickly/","summary":"前言 之前在学习安卓的时候，很想要给自己的软件增加一个云服务功能，但是苦于没有学过后端，于是开始在互联网上查找资料。但是遗憾的是，后端是一个很大的范围，我查找了很多后端的资料也几乎都是在讲解如何写网页，并没有专门用来给安卓写后端的教程，在广泛地学习了大量后端内容后，成功的为自己的程序开发了一个简单的 API。希望这篇文章能够帮到那些没有系统地学习过后端，但是却想要快速开发一款能用的 API 的安卓开发者。\n前期准备  你要了解互联网通讯原理 你要会一些基础的 JavaScript 你要有一台服务器 你会数据库操作 最好有一个域名（非必须） 掌握基础的终端操作  环境配置 本文章中后端开发使用的开发语言为 JavaScript 配合 nodejs。数据库采用常用的 mysql。\n 注： nodejs 开发常用的数据库是 mongodb，但是由于 mysql 比较常用这里就用 mysql 了，当然其他数据库也是可以的，你可以查找一下 nodejs 如何链接这些数据库，并将本文中 mysql 操作的部分替换掉就可以了。\n 本地测试客户端安装 你需要在自己用来开发的电脑上安装配置如下环境：\n nodejs npm  安装 nodejs Linux 下直接使用包管理安装即可。如果包管理安装的 node 很旧，可以自行谷歌一下安装方法，这里不再赘述。\n以 Ubuntu 为例，直接在终端执行如下指令：\nsudo apt install nodejs 安装完成后使用 node -v 查看 node 版本来确认安装是否成功。\n如果是 windows 用户就更加简单了，直接在 nodejs 官网 下载安装包运行即可。推荐使用长周期稳定版本。如果你想体验新特性，也可以考虑使用最新的版本。\n安装 npm 通常情况下，安装 nodejs 时会附带安装 npm，你可以直接使用 npm -v 来查看当前系统安装的 npm 版本来检测安装情况。","title":"使用 nodejs 快速为 Android 程序构建 API"},{"content":"在多人协作的项目中，为了同一代码格式，可以使用 editorconfig 来定义，这样不仅可以帮助协作者快速了解当前项目要求的代码风格，也可以方便使用一些格式化工具保证代码风格按照预期格式化。\n快速了解  What is EditorConfig? EditorConfig helps maintain consistent coding styles for multiple developers working on the same project across various editors and IDEs. The EditorConfig project consists of a file format for defining coding styles and a collection of text editor plugins that enable editors to read the file format and adhere to defined styles. EditorConfig files are easily readable and they work nicely with version control systems. Source: https://editorconfig.org/\n 简单示例  示例来自 https://editorconfig.org/\n # EditorConfig is awesome: https://EditorConfig.org # top-most EditorConfig file root = true # Unix-style newlines with a newline ending every file [*] end_of_line = lf insert_final_newline = true # Matches multiple files with brace expansion notation # Set default charset [*.{js,py}] charset = utf-8 # 4 space indentation [*.py] indent_style = space indent_size = 4 # Tab indentation (no size specified) [Makefile] indent_style = tab # Indentation override for all JS under lib directory [lib/**.js] indent_style = space indent_size = 2 # Matches the exact files either package.json or .travis.yml [{package.json,.travis.yml}] indent_style = space indent_size = 2 使用方法 直接在项目目录下新建文件 .editorconfig 写入配置，安装对应插件后即可，保存文件时会按照配置文件自动格式化。\n额外地，如果你在 Windows 下如果使用 Windows Explorer 新建 .editorconfig 文件，需要将文件名写为 .editorconfig.，Windows 会自动重命名为 .editorconfig。\n特殊符号的含义    符号 含义     * 匹配任何字符串，除了路径分割符 (/)   ** 匹配任何字符串   ? 匹配任何单字符   [name] 匹配 name 中所包含的任一字符   [!name] 匹配不包含在 name 中的任一字符   {s1,s2,s3} 匹配任何给定单字符串 (用逗号分割) (在 EditorConfig Core 0.11.0 后受支持)   {num1..num2} 匹配任何在 num1 和 num2 之间的数字，num1 和 num2 可以是正数也可以是负数    支持的配置属性  indent_style 缩进样式 {tab, space} indent_size 每次缩进相当于多少列 {2,4,8\u0026hellip;} (当 indent_style 设置为 space 时使用) tab_width 每次缩进相当于多少列 {2,4,8\u0026hellip;} (当 indent_style 设置为 tab 时使用) end_of_line 换行 {lf, cr, crlf} charset 编码 {latin1, utf-16be, utf-16le, utf-8, utf-8-bom, unset} trim_trailing_whitespace {true, false} 是否删掉结尾的空白字符 insert_final_newline {true, false} 是否在结尾插入新行 root {true, false} 是否顶级配置文件  ","permalink":"https://aimerneige.com/zh/post/editorconfig/","summary":"在多人协作的项目中，为了同一代码格式，可以使用 editorconfig 来定义，这样不仅可以帮助协作者快速了解当前项目要求的代码风格，也可以方便使用一些格式化工具保证代码风格按照预期格式化。\n快速了解  What is EditorConfig? EditorConfig helps maintain consistent coding styles for multiple developers working on the same project across various editors and IDEs. The EditorConfig project consists of a file format for defining coding styles and a collection of text editor plugins that enable editors to read the file format and adhere to defined styles. EditorConfig files are easily readable and they work nicely with version control systems.","title":"利用 EditorConfig 定义代码格式，统一代码风格"},{"content":"前言 Linux 下中文输入法一直是硬伤，各种方面都没有 windows 或 mac 下好用，最近在逛 github 的时候偶然翻到一个仓库 四叶草拼音输入方案，这个仓库提供的输入方案用起来十分舒服，但是在安装的时候也遇到一些坑，于是写了这篇文章来记录。\n 测试环境：\n.............. aimerneige@an ..,;:ccc,. ------------- ......\u0026#39;\u0026#39;\u0026#39;;lxO. OS: Kali GNU/Linux Rolling x86_64 .....\u0026#39;\u0026#39;\u0026#39;\u0026#39;..........,:ld; Host: TM1701 .\u0026#39;;;;:::;,,.x, Kernel: 5.9.0-kali4-amd64 ..\u0026#39;\u0026#39;\u0026#39;. 0Xxoc:,. ... Uptime: 2 hours, 11 mins .... ,ONkc;,;cokOdc\u0026#39;,. Packages: 3537 (dpkg) . OMo \u0026#39;:ddo. Shell: zsh 5.8 dMc :OO; Resolution: 1920x1080, 1440x2560 0M. .:o. DE: GNOME 3.38.2 ;Wd WM: Mutter ;XO, WM Theme: Kali-Dark ,d0Odlc;,.. Theme: Kali-Dark [GTK2/3] ..\u0026#39;,;:cdOOd::,. Icons: Flat-Remix-Blue-Dark [GTK2/\u0026gt; 3] .:d;.\u0026#39;:;. Terminal: gnome-terminal \u0026#39;d, .\u0026#39; CPU: Intel i7-8550U (8) @ 4.000GHz ;l .. GPU: NVIDIA GeForce MX250 .o GPU: Intel UHD Graphics 620 c Memory: 3698MiB / 15899MiB .\u0026#39; .  安装 fcitx5 sudo apt install fcitx5 启用 fcitx5 im-config 在开启的图形化界面中启用 fcitx5\n配置 fcitx5 编辑文件 ~/.xprofile 写入如下内容：\nexport GTK_IM_MODULE=fcitx5 export QT_IM_MODULE=fcitx5 export XMODIFIERS=\u0026#34;@im=fcitx5\u0026#34; export LANG=\u0026#34;zh_CN.UTF-8\u0026#34; export LC_CTYPE=\u0026#34;zh_CN.UTF-8\u0026#34; 编辑完成后注销账户，重新启动桌面\n安装 rime sudo apt install fcitx5-rime 启用 rime 在托盘处点击配置，并添加 rime。\n如果你的系统和我一样是英文，取消勾选“Only Show Current Language”即可查看中文选项\n更快地，你可以直接在上面的搜索框搜索 Rime\n安装输入方案 安装 四叶草拼音输入方案 提供的输入方案\n具体安装方法查看 项目 wiki\n更换简体中文 按下 Ctrl + ` 将输入模式切换为简体中文\n你也可以按照自己的喜好更改全角/半角的设置\n后记 如果你在安装中遇到任何问题，请查阅 fcitx rime 四叶草拼音输入方案 提供的文档。\n或是在 Arch Wiki 上查阅相关内容。\n","permalink":"https://aimerneige.com/zh/post/install-fcitx5-with-rime-on-linux/","summary":"前言 Linux 下中文输入法一直是硬伤，各种方面都没有 windows 或 mac 下好用，最近在逛 github 的时候偶然翻到一个仓库 四叶草拼音输入方案，这个仓库提供的输入方案用起来十分舒服，但是在安装的时候也遇到一些坑，于是写了这篇文章来记录。\n 测试环境：\n.............. aimerneige@an ..,;:ccc,. ------------- ......\u0026#39;\u0026#39;\u0026#39;;lxO. OS: Kali GNU/Linux Rolling x86_64 .....\u0026#39;\u0026#39;\u0026#39;\u0026#39;..........,:ld; Host: TM1701 .\u0026#39;;;;:::;,,.x, Kernel: 5.9.0-kali4-amd64 ..\u0026#39;\u0026#39;\u0026#39;. 0Xxoc:,. ... Uptime: 2 hours, 11 mins .... ,ONkc;,;cokOdc\u0026#39;,. Packages: 3537 (dpkg) . OMo \u0026#39;:ddo. Shell: zsh 5.8 dMc :OO; Resolution: 1920x1080, 1440x2560 0M. .:o. DE: GNOME 3.38.2 ;Wd WM: Mutter ;XO, WM Theme: Kali-Dark ,d0Odlc;,.. Theme: Kali-Dark [GTK2/3] ..\u0026#39;,;:cdOOd::,. Icons: Flat-Remix-Blue-Dark [GTK2/\u0026gt; 3] .","title":"Linux 下安装 fcitx5 与 Rime"},{"content":"函数指针在大型的 C 语言项目中十分重要，但是学校对它的介绍一带而过，国内一些介绍函数指针的文章十分粗浅甚至存在错误（这里就不点名了），因此博主写了这篇文章介绍函数指针，希望能够帮助一些 C 语言学习者。\n文章部分内容翻译引用于 https://www.geeksforgeeks.org/function-pointer-in-c/\n函数指针的概念 类似变量，函数也会被分配一段存储空间，这段存储空间的首地址即被称做这个函数的地址。而且函数名表示的就是这个地址。既然是地址，我们就可以定义一个指针变量来存放，这个指针变量就叫做函数指针变量，简称函数指针。\n函数指针的定义 下面的语句定义了一个指向函数的指针变量 p。其中 void *表示返回值，(*p) 表示 p 是一个指针变量， (int, float) 是函数的参数列表。\nvoid *(*p) (int, float); 这样我们就得到了一个指针变量 p，它的类型为 void * (*)(int, float)\n所以函数指针的定义方法为：\n函数返回类型 (*指针变量名) (函数参数列表); 这里的函数参数列表类似函数声明，只需写出变量类型即可，并不需要定义变量。\n即下面的俩种写法等价并且第二种写法中定义的变量并没有任何意义，建议使用第一种写法，不要使用第二种写法。\nvoid *(*p) (int, float); void *(*p) (int a, float b); 如何对函数指针赋值 int Func(int x); // 函数的声明  int (*p) (int x); // 函数指针的定义  p = \u0026amp;Func; // 函数指针的赋值 p = Func; // 另一种可行的写法 注：对于俩种赋值写法的详细说明见对函数赋值和调用的一些说明\n函数指针的调用 #include \u0026lt;stdio.h\u0026gt; int max(int a, int b); // 函数声明  int main(int argc, char const *argv[]) { int a = 12; int b = 32; int (*p)(int, int); // 函数指针定义  p = \u0026amp;max; // 函数指针赋值  int c = (*p)(a, b); // 函数指针的调用  printf(\u0026#34;%d\\n\u0026#34;, c); // 输出 `32`  return 0; } // 函数定义 int max(int a, int b) { return a \u0026gt; b ? a : b; } 另一种可行的写法\n#include \u0026lt;stdio.h\u0026gt; int max(int a, int b); // 函数声明  int main(int argc, char const *argv[]) { int a = 12; int b = 32; int (*p)(int, int); // 函数指针定义  p = max; // 函数指针赋值  int c = *p(a, b); // 函数指针的调用  printf(\u0026#34;%d\\n\u0026#34;, c); // 输出 `32`  return 0; } // 函数定义 int max(int a, int b) { return a \u0026gt; b ? a : b; } 注：对于这俩种调用的写法的详细说明见对函数赋值和调用的一些说明\n函数指针中要注意的一些内容  与一般的指针不同，函数指针指向代码而不是数据。通常，一个函数指针存储了可执行代码的起始位置。 与普通指针不同，我们使用函数指针时不需要分配和释放内存。 函数名也可以用来获取函数的地址。（详见对函数赋值和调用的一些说明） 类似普通的指针，我们也有函数指针数组。（详见函数指针数组示例） 函数指针可被用于 switch case 结构中，例如函数指针数组示例中的示例程序中，用户可以通过输入 0 ～ 2 来选择不同的操作。 就像普通数据的指针一样，一个函数指针同样可以被用作函数的参数和返回值，例如函数指针作为参数的示例中的程序中 wrapper() 函数接受 void (*fun)() 作为参数并且执行这个函数。这个特性有很多的应用，你可以在函数指针作为参数的应用中查看更多内容。 C++ 中的许多面向对象特性都是使用 C 中的函数指针实现的，例如虚函数，类方法是使用函数指针实现的另一个示例。  对函数赋值和调用的一些说明 通常，既然是指针赋值，我们会使用取地址操作来获取地址，然后使用 * 运算符调用，但是，对于函数来说，直接使用函数名也可以获得地址。即如下俩种写法等价：\np = \u0026amp;Func; (*p)(2, 3); p = Func; p(2, 3); 编译执行以下程序：\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; int max(int a, int b); int main(int argc, char const *argv[]) { printf(\u0026#34;%p\\n\u0026#34;, (max) ); printf(\u0026#34;%p\\n\u0026#34;, (\u0026amp;max) ); return 0; } int max(int a, int b) { return a \u0026gt; b ? a : b; } 你会发现 (max) (\u0026amp;max) 拥有相同的值，即直接使用函数名也可以获得地址。\n因此，我更推荐第二种没有 \u0026amp; 和 * 的写法，更加直观易用。\n函数指针数组示例 #include \u0026lt;stdio.h\u0026gt; void add(int a, int b) { printf(\u0026#34;Addition is %d\\n\u0026#34;, a + b); } void subtract(int a, int b) { printf(\u0026#34;Subtraction is %d\\n\u0026#34;, a - b); } void multiply(int a, int b) { printf(\u0026#34;Multiplication is %d\\n\u0026#34;, a * b); } int main() { // fun_ptr_arr 是一个函数指针的数组  void (*fun_ptr_arr[])(int, int) = {add, subtract, multiply}; unsigned int ch, a = 15, b = 10; printf(\u0026#34;Enter Choice: 0 for add, 1 for subtract and 2 for multiply\\n\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;ch); if (ch \u0026gt; 2) { return 0; } (*fun_ptr_arr[ch])(a, b); return 0; } 函数指针作为参数的示例 // 一个简单的 C 语言程序来演示使用函数指针作为参数 #include \u0026lt;stdio.h\u0026gt; // 俩个简单的函数 void fun1() { printf(\u0026#34;Fun1\\n\u0026#34;); } void fun2() { printf(\u0026#34;Fun2\\n\u0026#34;); } // 一个接受函数作为参数并在内部执行这个函数的函数 void wrapper(void (*fun)()) { fun(); } int main() { wrapper(fun1); wrapper(fun2); return 0; } 函数指针作为参数的应用 我们可以使用将函数指针作为参数来避免书写重复的代码，例如较为简单的函数 qsort() 可以被用来排序数组或其他任何的自定义结构体。不仅这些，有了函数指针和空指针，使用 qsort() 函数可以对任何数据类型进行排序。\n// 一个关于 qsort 和比较器的定义 #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; // 一个比较器示例函数 // 它被用对一个整数数组进行排序 // 为了对任何其他数据类型或条件的任何数组进行排序 // 我们需要编写更多的比较函数 // 这样我们就可以使用相同的 qsort() int compare(const void *a, const void *b) { return (*(int *)a - *(int *)b); } int main() { int arr[] = {10, 5, 15, 12, 90, 80}; int n = sizeof(arr) / sizeof(arr[0]); qsort(arr, n, sizeof(int), compare); for (int i = 0; i \u0026lt; n; i++) { printf(\u0026#34;%d \u0026#34;, arr[i]); } return 0; } 类似 qsort() 函数，我们可以定义自己的可以用于任何数据类型的函数来处理不同的任务。下面是一个搜索函数的示例，它可以被用于任何数据类型。事实上，我们可以通过写一个专门的比较函数使用这个搜索函数来找到相近的元素（低于某阈值）。\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdbool.h\u0026gt; // 一个被用来对整数数组进行搜索的比较函数 bool compare(const void *a, const void *b) { return (*(int *)a == *(int *)b); } // 可以被用来在一个长度为 arr_size 的数组 arr[] 中 // 搜索元素 *x 的通用 search() 函数。 // 注意这里使用 void 指针，这样函数就可以在调用 // 的时候传入任何类型的参数 // ele_size 是数组元素的大小 int search(void *arr, int arr_size, int ele_size, void *x, bool compare(const void *, const void *)) { // 因为 char 占用一个字节，因此我们使用 char 指针  // 来可以保证用于任何类型的指针运算都正确，我们  // 需要将 index 与元素的大小 ele_size 相乘  char *ptr = (char *)arr; int i; for (i = 0; i \u0026lt; arr_size; i++) if (compare(ptr + i * ele_size, x)) return i; // 如果没有找到元素  return -1; } int main() { int arr[] = {2, 5, 7, 90, 70}; int n = sizeof(arr) / sizeof(arr[0]); int x = 7; printf(\u0026#34;Returned index is %d \u0026#34;, search(arr, n, sizeof(int), \u0026amp;x, compare)); return 0; } 这个函数可以被用于任何类型的数据，只要定义一个比较函数。\n如何使用 typedef 定义函数指针类型 与一般的定义不同，函数指针在使用 typedef 重命名时，新的变量名不是在末尾而是类似函数指针变量定义的写法。\n下面是一个简单的例子：\ntypedef int (*type_name) (const void *, double); 其中 int 为函数返回值类型， const void *, double 是函数接受的参数列表，(*type_name) 表明定义的是一个函数指针，它的类型为 int (*)(const void *, double)，新的类型名为 type_name，你可以使用 type_name 来定义一个类型为 int (*)(const void *, double) 的函数指针。\n也就是说，使用定义函数指针类型的格式如下：\ntypedef 函数返回值类型 (*类型名) (函数参数列表) 接下来看一下 qsort() 函数的源代码：\n首先是函数 qsort() 的声明：\nextern void qsort (void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar) __nonnull ((1, 4)); 这里有一个新的数据类型 __compar_fn_t，我们知道它是一个函数指针，我们找一下它的定义：\ntypedef int (*__compar_fn_t) (const void *, const void *); 上例中 search() 函数可以这样定义：\n// 类型定义 typedef bool (*compare_fun)(const void *, const void *); // 函数声明 int search(void *arr, int arr_size, int ele_size, void *x, compare_fun compare);  建议阅读： https://www.geeksforgeeks.org/function-pointer-in-c/\n","permalink":"https://aimerneige.com/zh/post/c-function-point/","summary":"函数指针在大型的 C 语言项目中十分重要，但是学校对它的介绍一带而过，国内一些介绍函数指针的文章十分粗浅甚至存在错误（这里就不点名了），因此博主写了这篇文章介绍函数指针，希望能够帮助一些 C 语言学习者。\n文章部分内容翻译引用于 https://www.geeksforgeeks.org/function-pointer-in-c/\n函数指针的概念 类似变量，函数也会被分配一段存储空间，这段存储空间的首地址即被称做这个函数的地址。而且函数名表示的就是这个地址。既然是地址，我们就可以定义一个指针变量来存放，这个指针变量就叫做函数指针变量，简称函数指针。\n函数指针的定义 下面的语句定义了一个指向函数的指针变量 p。其中 void *表示返回值，(*p) 表示 p 是一个指针变量， (int, float) 是函数的参数列表。\nvoid *(*p) (int, float); 这样我们就得到了一个指针变量 p，它的类型为 void * (*)(int, float)\n所以函数指针的定义方法为：\n函数返回类型 (*指针变量名) (函数参数列表); 这里的函数参数列表类似函数声明，只需写出变量类型即可，并不需要定义变量。\n即下面的俩种写法等价并且第二种写法中定义的变量并没有任何意义，建议使用第一种写法，不要使用第二种写法。\nvoid *(*p) (int, float); void *(*p) (int a, float b); 如何对函数指针赋值 int Func(int x); // 函数的声明  int (*p) (int x); // 函数指针的定义  p = \u0026amp;Func; // 函数指针的赋值 p = Func; // 另一种可行的写法 注：对于俩种赋值写法的详细说明见对函数赋值和调用的一些说明","title":"C 函数指针"},{"content":"装修中\u0026hellip;\n各位大佬一定看了 yaml 就可以自动脑补一份完美的 html 吧。。。\n- { title: \u0026#39;伞\u0026#39;, intro: \u0026#39;一只咸鱼的学习记录\u0026#39;, link: \u0026#39;https://farewell12345.github.io/\u0026#39;, github: \u0026#39;https://github.com/farewell12345\u0026#39;, image: \u0026#39;https://avatars.githubusercontent.com/u/53655863?v=4\u0026#39; } - { title: \u0026#39;HelloWorld的小博客\u0026#39;, intro: \u0026#39;这里是一个小白的博客\u0026#39;, link: \u0026#39;https://mzdluo123.github.io/\u0026#39;, github: \u0026#39;https://github.com/mzdluo123\u0026#39;, image: \u0026#39;https://avatars.githubusercontent.com/u/23146087?v=4\u0026#39; } - { title: \u0026#39;TangZ\u0026#39;, intro: \u0026#39;TangZ 的个人页面\u0026#39;, link: \u0026#39;https://wstzj.github.io/\u0026#39;, github: \u0026#39;https://github.com/wstzj\u0026#39;, image: \u0026#39;https://avatars.githubusercontent.com/u/55931768?v=4\u0026#39; } - { title: \u0026#39;Kenvix\u0026#39;, intro: \u0026#39;党明学姐\u0026#39;, link: \u0026#39;https://kenvix.com/\u0026#39;, github: \u0026#39;https://github.com/kenvix\u0026#39;, image: \u0026#39;https://avatars.githubusercontent.com/u/4546175?v=4\u0026#39; } - { title: \u0026#39;HeoLis\u0026#39;, intro: \u0026#39;We need to go faster and deeper.\u0026#39;, link: \u0026#39;http://ishero.net/\u0026#39;, github: \u0026#39;https://github.com/wmpscc\u0026#39;, image: \u0026#39;https://avatars.githubusercontent.com/u/29891793?v=4\u0026#39; } - { title: \u0026#39;🔨\u0026#39;, intro: \u0026#39;🔨のBlog\u0026#39;, link: \u0026#39;https://geekhe-p.github.io/\u0026#39;, github: \u0026#39;https://github.com/geekhe-p\u0026#39;, image: \u0026#39;https://avatars.githubusercontent.com/u/55914926?v=4\u0026#39; } - { title: \u0026#39;异国迷宫的十字路口\u0026#39;, intro: \u0026#39;一位弱鸡带学生的个人博客\u0026#39;, link: \u0026#39;https://blog.fivezha.cn/\u0026#39;, github: \u0026#39;https://github.com/xmmmmmovo\u0026#39;, image: \u0026#39;https://avatars.githubusercontent.com/u/32405482?v=4\u0026#39; } - { title: \u0026#39;Gaein nidb\u0026#39;, intro: \u0026#39;Gaein nidb的网站\u0026#39;, link: \u0026#39;https://www.gaein.cn/\u0026#39;, github: \u0026#39;https://github.com/nidbCN\u0026#39;, image: \u0026#39;https://avatars.githubusercontent.com/u/36162655?v=4\u0026#39; } - { title: \u0026#39;fzf404\u0026#39;, intro: \u0026#39;fzf的网站\u0026#39;, link: \u0026#39;https://fzf404.top/\u0026#39;, github: \u0026#39;https://github.com/fzf404\u0026#39;, image: \u0026#39;https://avatars.githubusercontent.com/u/40832831?v=4\u0026#39; } - { title: \u0026#39;凛凛酱\u0026#39;, intro: \u0026#39;傻逼凛凛\u0026#39;, link: \u0026#39;https://baolong24.github.io/\u0026#39;, github: \u0026#39;https://github.com/baolong24\u0026#39;, image: \u0026#39;https://avatars.githubusercontent.com/u/30337499?v=4\u0026#39; } - { title: \u0026#39;Web-Worker\u0026#39;, intro: \u0026#39;道阻且长,行则将至。\u0026#39;, link: \u0026#39;https://web-worker.cn/\u0026#39;, github: \u0026#39;https://github.com/Star-caorui\u0026#39;, image: \u0026#39;https://avatars.githubusercontent.com/u/51264180?v=4\u0026#39; } - { title: \u0026#39;vritser\u0026#39;, intro: \u0026#39;半斤八两\u0026#39;, link: \u0026#39;https://vritser.github.io/\u0026#39;, github: \u0026#39;https://github.com/vritser\u0026#39;, image: \u0026#39;https://avatars.githubusercontent.com/u/16340478?v=4\u0026#39; } ","permalink":"https://aimerneige.com/zh/friends/","summary":"装修中\u0026hellip;\n各位大佬一定看了 yaml 就可以自动脑补一份完美的 html 吧。。。\n- { title: \u0026#39;伞\u0026#39;, intro: \u0026#39;一只咸鱼的学习记录\u0026#39;, link: \u0026#39;https://farewell12345.github.io/\u0026#39;, github: \u0026#39;https://github.com/farewell12345\u0026#39;, image: \u0026#39;https://avatars.githubusercontent.com/u/53655863?v=4\u0026#39; } - { title: \u0026#39;HelloWorld的小博客\u0026#39;, intro: \u0026#39;这里是一个小白的博客\u0026#39;, link: \u0026#39;https://mzdluo123.github.io/\u0026#39;, github: \u0026#39;https://github.com/mzdluo123\u0026#39;, image: \u0026#39;https://avatars.githubusercontent.com/u/23146087?v=4\u0026#39; } - { title: \u0026#39;TangZ\u0026#39;, intro: \u0026#39;TangZ 的个人页面\u0026#39;, link: \u0026#39;https://wstzj.github.io/\u0026#39;, github: \u0026#39;https://github.com/wstzj\u0026#39;, image: \u0026#39;https://avatars.githubusercontent.com/u/55931768?v=4\u0026#39; } - { title: \u0026#39;Kenvix\u0026#39;, intro: \u0026#39;党明学姐\u0026#39;, link: \u0026#39;https://kenvix.com/\u0026#39;, github: \u0026#39;https://github.com/kenvix\u0026#39;, image: \u0026#39;https://avatars.githubusercontent.com/u/4546175?v=4\u0026#39; } - { title: \u0026#39;HeoLis\u0026#39;, intro: \u0026#39;We need to go faster and deeper.","title":"Friends"},{"content":" 中北大学学生，学习物联网专业。Linux 用户，热爱开源和分享。\n 技能  使用的编程语言，软件和服务\n  golang python JavaScript vala Linux git mysql  工具  neovim VSCode VirtualBox Dbeaver Joplin Spotify  语言  中文 英语  教育  中北大学 宁武县高级中学 宁武一中  联系我 GitHub: https://github.com/AimerNeige/\n邮件: aimer.neige@aimerneige.com\n电报: @AimerNeige\n域名: aimerneige.com neige.icu\n","permalink":"https://aimerneige.com/zh/about/","summary":"中北大学学生，学习物联网专业。Linux 用户，热爱开源和分享。\n 技能  使用的编程语言，软件和服务\n  golang python JavaScript vala Linux git mysql  工具  neovim VSCode VirtualBox Dbeaver Joplin Spotify  语言  中文 英语  教育  中北大学 宁武县高级中学 宁武一中  联系我 GitHub: https://github.com/AimerNeige/\n邮件: aimer.neige@aimerneige.com\n电报: @AimerNeige\n域名: aimerneige.com neige.icu","title":"关于我 👨‍💻"}]