[{"content":"前言 距离上一次写博客文章已经很长时间了，因为经常重装系统，而每次在电脑上安装和配置 hexo 的博客都是一件比较麻烦的事情，于是就一直咕了。但是最近我发现了 hugo 这一简洁好用的博客系统，可以让我远离配置安装都又慢又麻烦的 hexo，使用下来体验很棒，而我恰好又打算换一个博客主题，于是决定使用 hugo 来搭建我的新博客。本文简要介绍如何安装和使用 hugo。\n安装 你可能需要  go 的开发环境 git 一个顺手的编辑器  你一定不需要  nodejs npm  安装 hugo 要安装 hugo 非常简单，以 fedora 系统为例，只需要执行如下指令：\nsudo dnf install hugo 创建站点文件夹 使用以下指令创建你的站点文件夹：\nhugo new site blog 切换到工作目录进行后续操作：\ncd blog 使用 git 进行版本控制：\ngit init 安装主题 挑选好合适的主题后，将其直接 clone 在 ./themes 文件夹下即可。\ngit clone https://github.com/adityatelange/hugo-PaperMod themes/PaperMod --depth=1  使用 --depth=1 参数会忽略历史 commit 记录。\n 当然，下载解压压缩包的方式也是可以的。\n如果想要方便版本控制和更新，使用如下指令添加 submodule：\ngit submodule add https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod --depth=1 当重新 clone 仓库后，执行如下指令 clone 主题子仓库：\ngit submodule update --init --recursive 更新主题：\ngit submodule update --remote --merge 配置 hugo 支持多种配置文件格式，由于 yaml 格式的配置文件更易读，下文将默认使用 yaml 配置。\n与 hexo 不同，hugo 的配置文件只有一个，按照你所使用的主题提供的文档来修改你的配置文件即可。\n应用主题 theme: \u0026#34;PaperMod\u0026#34; 修改主题配置 不同的主题会有不同的配置方法，具体查看主题提供的文档。\n请参考如下配置：\nbaseURL: \u0026#34;https://aimerneige.com/\u0026#34; languageCode: \u0026#34;en-us\u0026#34; title: \u0026#34;AimerNeige\u0026#39;s Blog\u0026#34; theme: \u0026#34;PaperMod\u0026#34; enableRobotsTXT: true buildDrafts: false buildFuture: false buildExpired: false defaultContentLanguage: en defaultContentLanguageInSubdir: true languages: en: languageName: \u0026#34;English\u0026#34; weight: 1 menu: main: - name: About url: about/ weight: 5 - name: Friends url: friends/ weight: 6 - name: Post url: post/ weight: 7 - name: Archive url: archives/ weight: 8 - name: Tags url: tags/ weight: 9 - name: Categories url: categories/ weight: 10 - name: Search url: search/ weight: 11 zh: languageName: \u0026#34;中文\u0026#34; weight: 2 menu: main: - name: 关于 url: about/ weight: 5 - name: 朋友 url: friends/ weight: 6 - name: 文章 url: post/ weight: 7 - name: 归档 url: archives/ weight: 8 - name: 标签 url: tags/ weight: 9 - name: 分类 url: categories/ weight: 10 - name: 搜索 url: search/ weight: 11 params: profileMode: enabled: true title: \u0026#34;Aimer Neige\u0026#34; subtitle: \u0026#34;技术宅拯救世界\u0026#34; imageUrl: \u0026#34;https://avatars.githubusercontent.com/u/51701792?v=4\u0026#34; imageTitle: \u0026#34;avatar.jpeg\u0026#34; imageWidth: 140 imageHeight: 140 params: env: production keywords: [Blog, OpenSource, Coding, Golang, Programming] author: \u0026#34;Aimer Neige\u0026#34; defaultTheme: auto disableThemeToggle: false ShowToc: true TocOpen: false ShowBreadCrumbs: true ShowReadingTime: false ShowPostNavLinks: true ShowShareButtons: false ShowCodeCopyButtons: true displayFullLangName: true editPost: URL: \u0026#34;https://github.com/aimerneige/blog/content\u0026#34; Text: \u0026#34;Suggest Changes\u0026#34; appendFilePath: true homeInfoParams: Title: \u0026#34;Aimer Neige\u0026#34; Content: \u0026#34;Tech Otakus Save The World\u0026#34; profileMode: enabled: true title: \u0026#34;Aimer Neige\u0026#34; subtitle: \u0026#34;Tech Otakus Save The World\u0026#34; imageUrl: \u0026#34;https://avatars.githubusercontent.com/u/51701792?v=4\u0026#34; imageTitle: \u0026#34;avatar.jpeg\u0026#34; imageWidth: 140 imageHeight: 140 socialIcons: - name: github url: \u0026#34;https://github.com/AimerNeige\u0026#34; - name: twitter url: \u0026#34;https://twitter.com/NeigeAimer\u0026#34; - name: steam url: \u0026#34;https://steamcommunity.com/id/AimerNeige\u0026#34; - name: Telegram url: \u0026#34;https://t.me/AimerNeige\u0026#34; - name: KoFi url: \u0026#34;https://ko-fi.com/aimerneige\u0026#34; - name: RsS url: \u0026#34;index.xml\u0026#34; taxonomies: category: categories tag: tags series: series outputs: home: - HTML - RSS - JSON 迁移 将原有文章复制到站点文件夹下，修改配置。\n测试 使用如下指令启动本地测试服务。\nhugo serve -D 部署 使用如下指令生成静态文件：\nhugo 之后上传到 github 即可：\ncd public git add -A git commit -m \u0026#34;commit message\u0026#34; git push ","permalink":"https://aimerneige.com/zh/post/hello-hugo/","summary":"前言 距离上一次写博客文章已经很长时间了，因为经常重装系统，而每次在电脑上安装和配置 hexo 的博客都是一件比较麻烦的事情，于是就一直咕了。但是最近我发现了 hugo 这一简洁好用的博客系统，可以让我远离配置安装都又慢又麻烦的 hexo，使用下来体验很棒，而我恰好又打算换一个博客主题，于是决定使用 hugo 来搭建我的新博客。本文简要介绍如何安装和使用 hugo。\n安装 你可能需要  go 的开发环境 git 一个顺手的编辑器  你一定不需要  nodejs npm  安装 hugo 要安装 hugo 非常简单，以 fedora 系统为例，只需要执行如下指令：\nsudo dnf install hugo 创建站点文件夹 使用以下指令创建你的站点文件夹：\nhugo new site blog 切换到工作目录进行后续操作：\ncd blog 使用 git 进行版本控制：\ngit init 安装主题 挑选好合适的主题后，将其直接 clone 在 ./themes 文件夹下即可。\ngit clone https://github.com/adityatelange/hugo-PaperMod themes/PaperMod --depth=1  使用 --depth=1 参数会忽略历史 commit 记录。\n 当然，下载解压压缩包的方式也是可以的。\n如果想要方便版本控制和更新，使用如下指令添加 submodule：\ngit submodule add https://github.","title":"Hello Hugo"},{"content":"函数指针在大型的 C 语言项目中十分重要，但是学校对它的介绍一带而过，国内一些介绍函数指针的文章十分粗浅甚至存在错误（这里就不点名了），因此博主写了这篇文章介绍函数指针，希望能够帮助一些 C 语言学习者。\n文章部分内容翻译引用于 https://www.geeksforgeeks.org/function-pointer-in-c/\n函数指针的概念 类似变量，函数也会被分配一段存储空间，这段存储空间的首地址即被称做这个函数的地址。而且函数名表示的就是这个地址。既然是地址，我们就可以定义一个指针变量来存放，这个指针变量就叫做函数指针变量，简称函数指针。\n函数指针的定义 下面的语句定义了一个指向函数的指针变量 p。其中 void *表示返回值，(*p) 表示 p 是一个指针变量， (int, float) 是函数的参数列表。\nvoid *(*p) (int, float); 这样我们就得到了一个指针变量 p，它的类型为 void * (*)(int, float)\n所以函数指针的定义方法为：\n函数返回类型 (*指针变量名) (函数参数列表); 这里的函数参数列表类似函数声明，只需写出变量类型即可，并不需要定义变量。\n即下面的俩种写法等价并且第二种写法中定义的变量并没有任何意义，建议使用第一种写法，不要使用第二种写法。\nvoid *(*p) (int, float); void *(*p) (int a, float b); 如何对函数指针赋值 int Func(int x); // 函数的声明  int (*p) (int x); // 函数指针的定义  p = \u0026amp;Func; // 函数指针的赋值 p = Func; // 另一种可行的写法 注：对于俩种赋值写法的详细说明见对函数赋值和调用的一些说明\n函数指针的调用 #include \u0026lt;stdio.h\u0026gt; int max(int a, int b); // 函数声明  int main(int argc, char const *argv[]) { int a = 12; int b = 32; int (*p)(int, int); // 函数指针定义  p = \u0026amp;max; // 函数指针赋值  int c = (*p)(a, b); // 函数指针的调用  printf(\u0026#34;%d\\n\u0026#34;, c); // 输出 `32`  return 0; } // 函数定义 int max(int a, int b) { return a \u0026gt; b ? a : b; } 另一种可行的写法\n#include \u0026lt;stdio.h\u0026gt; int max(int a, int b); // 函数声明  int main(int argc, char const *argv[]) { int a = 12; int b = 32; int (*p)(int, int); // 函数指针定义  p = max; // 函数指针赋值  int c = *p(a, b); // 函数指针的调用  printf(\u0026#34;%d\\n\u0026#34;, c); // 输出 `32`  return 0; } // 函数定义 int max(int a, int b) { return a \u0026gt; b ? a : b; } 注：对于这俩种调用的写法的详细说明见对函数赋值和调用的一些说明\n函数指针中要注意的一些内容  与一般的指针不同，函数指针指向代码而不是数据。通常，一个函数指针存储了可执行代码的起始位置。 与普通指针不同，我们使用函数指针时不需要分配和释放内存。 函数名也可以用来获取函数的地址。（详见对函数赋值和调用的一些说明） 类似普通的指针，我们也有函数指针数组。（详见函数指针数组示例） 函数指针可被用于 switch case 结构中，例如函数指针数组示例中的示例程序中，用户可以通过输入 0 ～ 2 来选择不同的操作。 就像普通数据的指针一样，一个函数指针同样可以被用作函数的参数和返回值，例如函数指针作为参数的示例中的程序中 wrapper() 函数接受 void (*fun)() 作为参数并且执行这个函数。这个特性有很多的应用，你可以在函数指针作为参数的应用中查看更多内容。 C++ 中的许多面向对象特性都是使用 C 中的函数指针实现的，例如虚函数，类方法是使用函数指针实现的另一个示例。  对函数赋值和调用的一些说明 通常，既然是指针赋值，我们会使用取地址操作来获取地址，然后使用 * 运算符调用，但是，对于函数来说，直接使用函数名也可以获得地址。即如下俩种写法等价：\np = \u0026amp;Func; (*p)(2, 3); p = Func; p(2, 3); 编译执行以下程序：\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; int max(int a, int b); int main(int argc, char const *argv[]) { printf(\u0026#34;%p\\n\u0026#34;, (max) ); printf(\u0026#34;%p\\n\u0026#34;, (\u0026amp;max) ); return 0; } int max(int a, int b) { return a \u0026gt; b ? a : b; } 你会发现 (max) (\u0026amp;max) 拥有相同的值，即直接使用函数名也可以获得地址。\n因此，我更推荐第二种没有 \u0026amp; 和 * 的写法，更加直观易用。\n函数指针数组示例 #include \u0026lt;stdio.h\u0026gt; void add(int a, int b) { printf(\u0026#34;Addition is %d\\n\u0026#34;, a + b); } void subtract(int a, int b) { printf(\u0026#34;Subtraction is %d\\n\u0026#34;, a - b); } void multiply(int a, int b) { printf(\u0026#34;Multiplication is %d\\n\u0026#34;, a * b); } int main() { // fun_ptr_arr 是一个函数指针的数组  void (*fun_ptr_arr[])(int, int) = {add, subtract, multiply}; unsigned int ch, a = 15, b = 10; printf(\u0026#34;Enter Choice: 0 for add, 1 for subtract and 2 for multiply\\n\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;ch); if (ch \u0026gt; 2) { return 0; } (*fun_ptr_arr[ch])(a, b); return 0; } 函数指针作为参数的示例 // 一个简单的 C 语言程序来演示使用函数指针作为参数 #include \u0026lt;stdio.h\u0026gt; // 俩个简单的函数 void fun1() { printf(\u0026#34;Fun1\\n\u0026#34;); } void fun2() { printf(\u0026#34;Fun2\\n\u0026#34;); } // 一个接受函数作为参数并在内部执行这个函数的函数 void wrapper(void (*fun)()) { fun(); } int main() { wrapper(fun1); wrapper(fun2); return 0; } 函数指针作为参数的应用 我们可以使用将函数指针作为参数来避免书写重复的代码，例如较为简单的函数 qsort() 可以被用来排序数组或其他任何的自定义结构体。不仅这些，有了函数指针和空指针，使用 qsort() 函数可以对任何数据类型进行排序。\n// 一个关于 qsort 和比较器的定义 #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; // 一个比较器示例函数 // 它被用对一个整数数组进行排序 // 为了对任何其他数据类型或条件的任何数组进行排序 // 我们需要编写更多的比较函数 // 这样我们就可以使用相同的 qsort() int compare(const void *a, const void *b) { return (*(int *)a - *(int *)b); } int main() { int arr[] = {10, 5, 15, 12, 90, 80}; int n = sizeof(arr) / sizeof(arr[0]); qsort(arr, n, sizeof(int), compare); for (int i = 0; i \u0026lt; n; i++) { printf(\u0026#34;%d \u0026#34;, arr[i]); } return 0; } 类似 qsort() 函数，我们可以定义自己的可以用于任何数据类型的函数来处理不同的任务。下面是一个搜索函数的示例，它可以被用于任何数据类型。事实上，我们可以通过写一个专门的比较函数使用这个搜索函数来找到相近的元素（低于某阈值）。\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdbool.h\u0026gt; // 一个被用来对整数数组进行搜索的比较函数 bool compare(const void *a, const void *b) { return (*(int *)a == *(int *)b); } // 可以被用来在一个长度为 arr_size 的数组 arr[] 中 // 搜索元素 *x 的通用 search() 函数。 // 注意这里使用 void 指针，这样函数就可以在调用 // 的时候传入任何类型的参数 // ele_size 是数组元素的大小 int search(void *arr, int arr_size, int ele_size, void *x, bool compare(const void *, const void *)) { // 因为 char 占用一个字节，因此我们使用 char 指针  // 来可以保证用于任何类型的指针运算都正确，我们  // 需要将 index 与元素的大小 ele_size 相乘  char *ptr = (char *)arr; int i; for (i = 0; i \u0026lt; arr_size; i++) if (compare(ptr + i * ele_size, x)) return i; // 如果没有找到元素  return -1; } int main() { int arr[] = {2, 5, 7, 90, 70}; int n = sizeof(arr) / sizeof(arr[0]); int x = 7; printf(\u0026#34;Returned index is %d \u0026#34;, search(arr, n, sizeof(int), \u0026amp;x, compare)); return 0; } 这个函数可以被用于任何类型的数据，只要定义一个比较函数。\n如何使用 typedef 定义函数指针类型 与一般的定义不同，函数指针在使用 typedef 重命名时，新的变量名不是在末尾而是类似函数指针变量定义的写法。\n下面是一个简单的例子：\ntypedef int (*type_name) (const void *, double); 其中 int 为函数返回值类型， const void *, double 是函数接受的参数列表，(*type_name) 表明定义的是一个函数指针，它的类型为 int (*)(const void *, double)，新的类型名为 type_name，你可以使用 type_name 来定义一个类型为 int (*)(const void *, double) 的函数指针。\n也就是说，使用定义函数指针类型的格式如下：\ntypedef 函数返回值类型 (*类型名) (函数参数列表) 接下来看一下 qsort() 函数的源代码：\n首先是函数 qsort() 的声明：\nextern void qsort (void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar) __nonnull ((1, 4)); 这里有一个新的数据类型 __compar_fn_t，我们知道它是一个函数指针，我们找一下它的定义：\ntypedef int (*__compar_fn_t) (const void *, const void *); 上例中 search() 函数可以这样定义：\n// 类型定义 typedef bool (*compare_fun)(const void *, const void *); // 函数声明 int search(void *arr, int arr_size, int ele_size, void *x, compare_fun compare);  建议阅读： https://www.geeksforgeeks.org/function-pointer-in-c/\n","permalink":"https://aimerneige.com/zh/post/c-function-point/","summary":"函数指针在大型的 C 语言项目中十分重要，但是学校对它的介绍一带而过，国内一些介绍函数指针的文章十分粗浅甚至存在错误（这里就不点名了），因此博主写了这篇文章介绍函数指针，希望能够帮助一些 C 语言学习者。\n文章部分内容翻译引用于 https://www.geeksforgeeks.org/function-pointer-in-c/\n函数指针的概念 类似变量，函数也会被分配一段存储空间，这段存储空间的首地址即被称做这个函数的地址。而且函数名表示的就是这个地址。既然是地址，我们就可以定义一个指针变量来存放，这个指针变量就叫做函数指针变量，简称函数指针。\n函数指针的定义 下面的语句定义了一个指向函数的指针变量 p。其中 void *表示返回值，(*p) 表示 p 是一个指针变量， (int, float) 是函数的参数列表。\nvoid *(*p) (int, float); 这样我们就得到了一个指针变量 p，它的类型为 void * (*)(int, float)\n所以函数指针的定义方法为：\n函数返回类型 (*指针变量名) (函数参数列表); 这里的函数参数列表类似函数声明，只需写出变量类型即可，并不需要定义变量。\n即下面的俩种写法等价并且第二种写法中定义的变量并没有任何意义，建议使用第一种写法，不要使用第二种写法。\nvoid *(*p) (int, float); void *(*p) (int a, float b); 如何对函数指针赋值 int Func(int x); // 函数的声明  int (*p) (int x); // 函数指针的定义  p = \u0026amp;Func; // 函数指针的赋值 p = Func; // 另一种可行的写法 注：对于俩种赋值写法的详细说明见对函数赋值和调用的一些说明","title":"C 函数指针"},{"content":"关于我\n","permalink":"https://aimerneige.com/zh/about/","summary":"关于我","title":"About Me"},{"content":"装修中\u0026hellip;\n各位大佬一定看了 yaml 就可以自动脑补一份完美的 html 吧。。。\n- { title: \u0026#39;伞\u0026#39;, intro: \u0026#39;一只咸鱼的学习记录\u0026#39;, link: \u0026#39;https://farewell12345.github.io/\u0026#39;, github: \u0026#39;https://github.com/farewell12345\u0026#39;, image: \u0026#39;https://avatars.githubusercontent.com/u/53655863?v=4\u0026#39; } - { title: \u0026#39;HelloWorld的小博客\u0026#39;, intro: \u0026#39;这里是一个小白的博客\u0026#39;, link: \u0026#39;https://mzdluo123.github.io/\u0026#39;, github: \u0026#39;https://github.com/mzdluo123\u0026#39;, image: \u0026#39;https://avatars.githubusercontent.com/u/23146087?v=4\u0026#39; } - { title: \u0026#39;TangZ\u0026#39;, intro: \u0026#39;TangZ 的个人页面\u0026#39;, link: \u0026#39;https://wstzj.github.io/\u0026#39;, github: \u0026#39;https://github.com/wstzj\u0026#39;, image: \u0026#39;https://avatars.githubusercontent.com/u/55931768?v=4\u0026#39; } - { title: \u0026#39;Kenvix\u0026#39;, intro: \u0026#39;党明学姐\u0026#39;, link: \u0026#39;https://kenvix.com/\u0026#39;, github: \u0026#39;https://github.com/kenvix\u0026#39;, image: \u0026#39;https://avatars.githubusercontent.com/u/4546175?v=4\u0026#39; } - { title: \u0026#39;HeoLis\u0026#39;, intro: \u0026#39;We need to go faster and deeper.\u0026#39;, link: \u0026#39;http://ishero.net/\u0026#39;, github: \u0026#39;https://github.com/wmpscc\u0026#39;, image: \u0026#39;https://avatars.githubusercontent.com/u/29891793?v=4\u0026#39; } - { title: \u0026#39;🔨\u0026#39;, intro: \u0026#39;🔨のBlog\u0026#39;, link: \u0026#39;https://geekhe-p.github.io/\u0026#39;, github: \u0026#39;https://github.com/geekhe-p\u0026#39;, image: \u0026#39;https://avatars.githubusercontent.com/u/55914926?v=4\u0026#39; } - { title: \u0026#39;异国迷宫的十字路口\u0026#39;, intro: \u0026#39;一位弱鸡带学生的个人博客\u0026#39;, link: \u0026#39;https://blog.fivezha.cn/\u0026#39;, github: \u0026#39;https://github.com/xmmmmmovo\u0026#39;, image: \u0026#39;https://avatars.githubusercontent.com/u/32405482?v=4\u0026#39; } - { title: \u0026#39;Gaein nidb\u0026#39;, intro: \u0026#39;Gaein nidb的网站\u0026#39;, link: \u0026#39;https://www.gaein.cn/\u0026#39;, github: \u0026#39;https://github.com/nidbCN\u0026#39;, image: \u0026#39;https://avatars.githubusercontent.com/u/36162655?v=4\u0026#39; } - { title: \u0026#39;fzf404\u0026#39;, intro: \u0026#39;fzf的网站\u0026#39;, link: \u0026#39;https://fzf404.top/\u0026#39;, github: \u0026#39;https://github.com/fzf404\u0026#39;, image: \u0026#39;https://avatars.githubusercontent.com/u/40832831?v=4\u0026#39; } - { title: \u0026#39;凛凛酱\u0026#39;, intro: \u0026#39;傻逼凛凛\u0026#39;, link: \u0026#39;https://baolong24.github.io/\u0026#39;, github: \u0026#39;https://github.com/baolong24\u0026#39;, image: \u0026#39;https://avatars.githubusercontent.com/u/30337499?v=4\u0026#39; } - { title: \u0026#39;Web-Worker\u0026#39;, intro: \u0026#39;道阻且长,行则将至。\u0026#39;, link: \u0026#39;https://web-worker.cn/\u0026#39;, github: \u0026#39;https://github.com/Star-caorui\u0026#39;, image: \u0026#39;https://avatars.githubusercontent.com/u/51264180?v=4\u0026#39; } - { title: \u0026#39;vritser\u0026#39;, intro: \u0026#39;半斤八两\u0026#39;, link: \u0026#39;https://vritser.github.io/\u0026#39;, github: \u0026#39;https://github.com/vritser\u0026#39;, image: \u0026#39;https://avatars.githubusercontent.com/u/16340478?v=4\u0026#39; } ","permalink":"https://aimerneige.com/zh/friends/","summary":"装修中\u0026hellip;\n各位大佬一定看了 yaml 就可以自动脑补一份完美的 html 吧。。。\n- { title: \u0026#39;伞\u0026#39;, intro: \u0026#39;一只咸鱼的学习记录\u0026#39;, link: \u0026#39;https://farewell12345.github.io/\u0026#39;, github: \u0026#39;https://github.com/farewell12345\u0026#39;, image: \u0026#39;https://avatars.githubusercontent.com/u/53655863?v=4\u0026#39; } - { title: \u0026#39;HelloWorld的小博客\u0026#39;, intro: \u0026#39;这里是一个小白的博客\u0026#39;, link: \u0026#39;https://mzdluo123.github.io/\u0026#39;, github: \u0026#39;https://github.com/mzdluo123\u0026#39;, image: \u0026#39;https://avatars.githubusercontent.com/u/23146087?v=4\u0026#39; } - { title: \u0026#39;TangZ\u0026#39;, intro: \u0026#39;TangZ 的个人页面\u0026#39;, link: \u0026#39;https://wstzj.github.io/\u0026#39;, github: \u0026#39;https://github.com/wstzj\u0026#39;, image: \u0026#39;https://avatars.githubusercontent.com/u/55931768?v=4\u0026#39; } - { title: \u0026#39;Kenvix\u0026#39;, intro: \u0026#39;党明学姐\u0026#39;, link: \u0026#39;https://kenvix.com/\u0026#39;, github: \u0026#39;https://github.com/kenvix\u0026#39;, image: \u0026#39;https://avatars.githubusercontent.com/u/4546175?v=4\u0026#39; } - { title: \u0026#39;HeoLis\u0026#39;, intro: \u0026#39;We need to go faster and deeper.","title":"Friends"}]