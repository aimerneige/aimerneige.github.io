[{"content":"前言 由于电子设备比较多，蓝牙耳机配对的设备也比较多，这就引起了一个问题，本来连着手机听歌听的好好的，电脑开机之后就会自动抢占蓝牙耳机的信号，导致我还得重新在手机上连接耳机，严重影响听歌体验，于是就查询了如何禁用电脑自动连接的行为，希望这篇文章对你也有用。\n如何操作 编辑 /etc/bluetooth/main.conf 这个文件：\nsudo vim /etc/bluetooth/main.conf 找到这些内容：\n# AutoEnable defines option to enable all controllers when they are found. # This includes adapters present on start as well as adapters that are plugged # in later on. Defaults to \u0026#39;true\u0026#39;. # AutoEnable=true 修改配置文件，禁用自动连接：\nAutoEnable=false 重启设备，测试效果。\n","permalink":"https://aimerneige.com/zh/post/linux/how-to-disable-auto-bluetooth-connection-on-computer-startup/","summary":"前言 由于电子设备比较多，蓝牙耳机配对的设备也比较多，这就引起了一个问题，本来连着手机听歌听的好好的，电脑开机之后就会自动抢占蓝牙耳机的信号，导致我还得重新在手机上连接耳机，严重影响听歌体验，于是就查询了如何禁用电脑自动连接的行为，希望这篇文章对你也有用。\n如何操作 编辑 /etc/bluetooth/main.conf 这个文件：\nsudo vim /etc/bluetooth/main.conf 找到这些内容：\n# AutoEnable defines option to enable all controllers when they are found. # This includes adapters present on start as well as adapters that are plugged # in later on. Defaults to \u0026#39;true\u0026#39;. # AutoEnable=true 修改配置文件，禁用自动连接：\nAutoEnable=false 重启设备，测试效果。","title":"如何禁止电脑开机时自动连接蓝牙耳机"},{"content":"PaperMod 是一个非常棒的博客主题，但是它不支持友链，所以你要自己写一些代码。\n完整代码 把下面的代码存储在 layouts/shortcodes/friends.html\n用法 在 data/friends.yml 中添加你的友链数据，示例：\n- title: \u0026#34;伞\u0026#34; intro: \u0026#34;一只咸鱼的学习记录\u0026#34; link: \u0026#34;https://umb.ink/\u0026#34; image: \u0026#34;https://avatars.githubusercontent.com/u/53655863?v=4\u0026#34; - title: \u0026#34;HelloWorld的小博客\u0026#34; intro: \u0026#34;这里是一个小白的博客\u0026#34; link: \u0026#34;https://mzdluo123.github.io/\u0026#34; image: \u0026#34;https://avatars.githubusercontent.com/u/23146087?v=4\u0026#34; ","permalink":"https://aimerneige.com/zh/post/web/add-friend-link-in-papermod-blog/","summary":"PaperMod 是一个非常棒的博客主题，但是它不支持友链，所以你要自己写一些代码。\n完整代码 把下面的代码存储在 layouts/shortcodes/friends.html\n用法 在 data/friends.yml 中添加你的友链数据，示例：\n- title: \u0026#34;伞\u0026#34; intro: \u0026#34;一只咸鱼的学习记录\u0026#34; link: \u0026#34;https://umb.ink/\u0026#34; image: \u0026#34;https://avatars.githubusercontent.com/u/53655863?v=4\u0026#34; - title: \u0026#34;HelloWorld的小博客\u0026#34; intro: \u0026#34;这里是一个小白的博客\u0026#34; link: \u0026#34;https://mzdluo123.github.io/\u0026#34; image: \u0026#34;https://avatars.githubusercontent.com/u/23146087?v=4\u0026#34; ","title":"在 PaperMod 博客中添加友链"},{"content":"下载字体 下载你需要的字体，并存储在 static/fonts\n导入字体 @font-face { font-family: \u0026#34;LXGWWenKai-Regular\u0026#34;; src: url(\u0026#34;/fonts/lxgw-wenkai/LXGWWenKai-Regular.ttf\u0026#34;) format(\u0026#34;truetype\u0026#34;); } 应用字体 body { font-family: LXGWWenKai-Regular; } 在 PaperMod 中应用 把你自己的 css 文件文件放在 assets/css/extended/custom_fonts.css\n导入多字重的字体文件 @font-face { font-family: \u0026#34;LXGWWenKai\u0026#34;; src: url(\u0026#34;/fonts/lxgw-wenkai/LXGWWenKai-Light.ttf\u0026#34;) format(\u0026#34;truetype\u0026#34;); font-weight: lighter; font-style: normal; } @font-face { font-family: \u0026#34;LXGWWenKai\u0026#34;; src: url(\u0026#34;/fonts/lxgw-wenkai/LXGWWenKai-Regular.ttf\u0026#34;) format(\u0026#34;truetype\u0026#34;); font-weight: normal; font-style: normal; } @font-face { font-family: \u0026#34;LXGWWenKai\u0026#34;; src: url(\u0026#34;/fonts/lxgw-wenkai/LXGWWenKai-Bold.ttf\u0026#34;) format(\u0026#34;truetype\u0026#34;); font-weight: bold; font-style: normal; } 使用 CDN @import url(\u0026#39;https://cdn.jsdelivr.net/npm/jetbrains-mono@1.0.6/css/jetbrains-mono.min.css\u0026#39;); code { font-family: \u0026#39;JetBrains Mono\u0026#39;; } 参考链接 Sulv\u0026rsquo;s Blog - Hugo博客自定义字体 PaperMod - FAQs StackOverflow - Using custom fonts using CSS? StackOverflow - Multiple font-weights, one @font-face query GitHub - lxgw/LxgwWenKai ","permalink":"https://aimerneige.com/zh/post/web/set-custom-fonts-in-papermod-site/","summary":"下载字体 下载你需要的字体，并存储在 static/fonts\n导入字体 @font-face { font-family: \u0026#34;LXGWWenKai-Regular\u0026#34;; src: url(\u0026#34;/fonts/lxgw-wenkai/LXGWWenKai-Regular.ttf\u0026#34;) format(\u0026#34;truetype\u0026#34;); } 应用字体 body { font-family: LXGWWenKai-Regular; } 在 PaperMod 中应用 把你自己的 css 文件文件放在 assets/css/extended/custom_fonts.css\n导入多字重的字体文件 @font-face { font-family: \u0026#34;LXGWWenKai\u0026#34;; src: url(\u0026#34;/fonts/lxgw-wenkai/LXGWWenKai-Light.ttf\u0026#34;) format(\u0026#34;truetype\u0026#34;); font-weight: lighter; font-style: normal; } @font-face { font-family: \u0026#34;LXGWWenKai\u0026#34;; src: url(\u0026#34;/fonts/lxgw-wenkai/LXGWWenKai-Regular.ttf\u0026#34;) format(\u0026#34;truetype\u0026#34;); font-weight: normal; font-style: normal; } @font-face { font-family: \u0026#34;LXGWWenKai\u0026#34;; src: url(\u0026#34;/fonts/lxgw-wenkai/LXGWWenKai-Bold.ttf\u0026#34;) format(\u0026#34;truetype\u0026#34;); font-weight: bold; font-style: normal; } 使用 CDN @import url(\u0026#39;https://cdn.jsdelivr.net/npm/jetbrains-mono@1.0.6/css/jetbrains-mono.min.css\u0026#39;); code { font-family: \u0026#39;JetBrains Mono\u0026#39;; } 参考链接 Sulv\u0026rsquo;s Blog - Hugo博客自定义字体 PaperMod - FAQs StackOverflow - Using custom fonts using CSS?","title":"在 PaperMod 博客中设置自定义字体"},{"content":" 本来很简单的东西，但是老忘，干脆写个博客吧\n错误写法 type Page struct { PageId string `bson:\u0026#34;pageId\u0026#34;,json:\u0026#34;pageId\u0026#34;` Meta map[string]interface{} `bson:\u0026#34;meta\u0026#34;,json:\u0026#34;pageId\u0026#34;` } 正确写法 type Page struct { PageId string `bson:\u0026#34;pageId\u0026#34; json:\u0026#34;pageId\u0026#34;` Meta map[string]interface{} `bson:\u0026#34;meta\u0026#34; json:\u0026#34;pageId\u0026#34;` } 很多 Tag Items []Item `gorm:\u0026#34;column:items,type:varchar(255);comment:\u0026#39;sample column\u0026#39;\u0026#34; json:\u0026#34;items\u0026#34;` 参考链接 StackOverflow - How to define multiple name tags in a struct ","permalink":"https://aimerneige.com/zh/post/go/how-to-add-multiple-tags-to-go-struct/","summary":" 本来很简单的东西，但是老忘，干脆写个博客吧\n错误写法 type Page struct { PageId string `bson:\u0026#34;pageId\u0026#34;,json:\u0026#34;pageId\u0026#34;` Meta map[string]interface{} `bson:\u0026#34;meta\u0026#34;,json:\u0026#34;pageId\u0026#34;` } 正确写法 type Page struct { PageId string `bson:\u0026#34;pageId\u0026#34; json:\u0026#34;pageId\u0026#34;` Meta map[string]interface{} `bson:\u0026#34;meta\u0026#34; json:\u0026#34;pageId\u0026#34;` } 很多 Tag Items []Item `gorm:\u0026#34;column:items,type:varchar(255);comment:\u0026#39;sample column\u0026#39;\u0026#34; json:\u0026#34;items\u0026#34;` 参考链接 StackOverflow - How to define multiple name tags in a struct ","title":"如何给 Go 的结构体添加多个 tag"},{"content":"前言 有时我们要通过第三方服务获取数据，它可以是外部提供的 API，也可以是微服务的接口等等，总之，它们有相同的问题：“获取数据可能需要大量时间”。如果在代码中同步地获取这些数据，程序就会花时间等待这些服务响应，而这些等待会严重影响程序的运行效率，而且一旦这些服务崩溃，我们的程序就会陷入无休止的等待中，那么如何解决这个问题呢？可以使用 Go 的 context 包。\n问题 我们用这个函数来替代那些第三方服务。我们直接使用 time.Sleep() 函数来模拟一个耗时过程，在现实场景中，它可能是在执行一个非常复杂的 SQL 查询，也可以是调用一个人工智能服务接口。当然，这个耗时是不确定的，甚至有可能是无穷大（卡死）。\nfunc fetchThirdPartyStuffWhichCanBeSlow() (int, error) { time.Sleep(time.Millisecond * 500) return 64, nil } 如果我们不做任何处理，直接调用这个函数，就像这样：\nfunc foo() { // some code here ... val, err := fetchThirdPartyStuffWhichCanBeSlow() if err != nil { log.Fatal(err) } // some code here ... } 上面的代码如果用在一些只执行一次的脚本、工具中，并不会带来严重后果，无非多等一下就好了，即使有问题也可以关掉程序检查一下第三方服务。但是如果上面的代码用在一个承载大流量的 web 服务中，程序在执行完耗时代码后还要继续执行一些重要的业务功能，那么这样直接调用而不加考虑的代码很可能是致命的。一旦第三方服务出现问题，程序没有任何机制检查和处理，而是直接陷入无休止的等待。这显然是不合理的。\n解决方案 要解决上述的问题，比较常见的思路是引入一个主动停止耗时服务的功能，这样如果耗时函数花了太多时间执行，程序就可以感知到，并主动干预。\n在后文中，我们假设我们要使用用户的 ID 访问用户的数据，且调用三方服务的代码被单独封装为 fetchUserData()。\n使用 Channel 如果不使用本文要介绍的 Context，传统的思路是使用 Channel + Select 来处理：\ntype Response struct { value int err error } func fetchUserData(userID int) (int, error) { stop := make(chan bool) respch := make(chan Response) go func() { val, err := fetchThirdPartyStuffWhichCanBeSlow() respch \u0026lt;- Response{ value: val, err: err, } }() go func() { time.Sleep(time.Millisecond * 200) stop \u0026lt;- true }() for { select { case \u0026lt;-stop: return 0, fmt.Errorf(\u0026#34;fetching data from third party took to long\u0026#34;) case resp := \u0026lt;-respch: return resp.value, resp.err } } } 这里我们使用 stop 这个 Channel 来发送停止信号，在程序执行超过指定时间时关掉终止等待并报错，而 respch 用来接受返回值。在程序的最后，使用 select 来接受 Channel 的信号，当检测到超时或执行完成时返回结果。\n使用 Context Context 的基础用法其实就是对上述代码的优化：\nfunc foo() { // some code here ... ctx := context.Background() val, err := fetchUserData(ctx, userID) // some code here ... } type Response struct { value int err error } func fetchUserData(ctx context.Context, userID int) (int, error) { ctx, cancel := context.WithTimeout(ctx, time.Millisecond*200) defer cancel() respch := make(chan Response) go func() { val, err := fetchThirdPartyStuffWhichCanBeSlow() respch \u0026lt;- Response{ value: val, err: err, } }() for { select { case \u0026lt;-ctx.Done(): return 0, fmt.Errorf(\u0026#34;fetching data from third party took to long\u0026#34;) case resp := \u0026lt;-respch: return resp.value, resp.err } } } 这里，我们新建了一个 context：ctx, cancel := context.WithTimeout(ctx, time.Millisecond*200)\n这个 context 带超时检测，超时后它会自动发出 ctx.Done() 这个信号，我们只需要在最后监测它即可。\n传递数据 除了直接使用超时机制外，我们也可以通过 Context 传递数据：\nfunc foo() { // some code here ... ctx := context.WithValue(context.Background(), \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;) val, err := fetchUserData(ctx, userID) // some code here ... } func fetchUserData(ctx context.Context, userID int) (int, error) { value := ctx.Value(\u0026#34;foo\u0026#34;) fmt.Println(value) // some code here ... } 优势在哪儿 使用 Context 可以减少 Channel 的使用，尤其是调用层级非常深时，使用 Channel 来传递关闭信号非常复杂，而 Context 可以轻松地传递关闭信号。\n参考链接 YouTube - How To Use The Context Package In Golang? YouTube - [Go 語言] 用 10 分鐘了解 context 使用場景及介紹 ","permalink":"https://aimerneige.com/zh/post/go/go-context/","summary":"前言 有时我们要通过第三方服务获取数据，它可以是外部提供的 API，也可以是微服务的接口等等，总之，它们有相同的问题：“获取数据可能需要大量时间”。如果在代码中同步地获取这些数据，程序就会花时间等待这些服务响应，而这些等待会严重影响程序的运行效率，而且一旦这些服务崩溃，我们的程序就会陷入无休止的等待中，那么如何解决这个问题呢？可以使用 Go 的 context 包。\n问题 我们用这个函数来替代那些第三方服务。我们直接使用 time.Sleep() 函数来模拟一个耗时过程，在现实场景中，它可能是在执行一个非常复杂的 SQL 查询，也可以是调用一个人工智能服务接口。当然，这个耗时是不确定的，甚至有可能是无穷大（卡死）。\nfunc fetchThirdPartyStuffWhichCanBeSlow() (int, error) { time.Sleep(time.Millisecond * 500) return 64, nil } 如果我们不做任何处理，直接调用这个函数，就像这样：\nfunc foo() { // some code here ... val, err := fetchThirdPartyStuffWhichCanBeSlow() if err != nil { log.Fatal(err) } // some code here ... } 上面的代码如果用在一些只执行一次的脚本、工具中，并不会带来严重后果，无非多等一下就好了，即使有问题也可以关掉程序检查一下第三方服务。但是如果上面的代码用在一个承载大流量的 web 服务中，程序在执行完耗时代码后还要继续执行一些重要的业务功能，那么这样直接调用而不加考虑的代码很可能是致命的。一旦第三方服务出现问题，程序没有任何机制检查和处理，而是直接陷入无休止的等待。这显然是不合理的。\n解决方案 要解决上述的问题，比较常见的思路是引入一个主动停止耗时服务的功能，这样如果耗时函数花了太多时间执行，程序就可以感知到，并主动干预。\n在后文中，我们假设我们要使用用户的 ID 访问用户的数据，且调用三方服务的代码被单独封装为 fetchUserData()。\n使用 Channel 如果不使用本文要介绍的 Context，传统的思路是使用 Channel + Select 来处理：\ntype Response struct { value int err error } func fetchUserData(userID int) (int, error) { stop := make(chan bool) respch := make(chan Response) go func() { val, err := fetchThirdPartyStuffWhichCanBeSlow() respch \u0026lt;- Response{ value: val, err: err, } }() go func() { time.","title":"Golang Context"},{"content":"使用 PaperMC 安装 PaperMC 下载 PaperMC 提供的 jar 包，存储在恰当位置即可。\n启动 PaperMC java -Xms2G -Xmx2G -jar paper.jar --nogui 下面是官方提供的优化后的启动脚本：\njava -Xms10G -Xmx10G -XX:+UseG1GC -XX:+ParallelRefProcEnabled -XX:MaxGCPauseMillis=200 -XX:+UnlockExperimentalVMOptions -XX:+DisableExplicitGC -XX:+AlwaysPreTouch -XX:G1NewSizePercent=30 -XX:G1MaxNewSizePercent=40 -XX:G1HeapRegionSize=8M -XX:G1ReservePercent=20 -XX:G1HeapWastePercent=5 -XX:G1MixedGCCountTarget=4 -XX:InitiatingHeapOccupancyPercent=15 -XX:G1MixedGCLiveThresholdPercent=90 -XX:G1RSetUpdatingPauseTimePercent=5 -XX:SurvivorRatio=32 -XX:+PerfDisableSharedMem -XX:MaxTenuringThreshold=1 -Dusing.aikars.flags=https://mcflags.emc.gs -Daikars.new.flags=true -jar paper.jar --nogui 安装 datapack 关掉已启动的服务器，将 datapack 存储在 papermc/world/datapacks 文件夹下，重启服务器即可。（如果不存在就新建一个）\n安装插件 关掉已启动的服务器，将下载好的插件存储在 papermc/plugins 文件夹下，重启服务器即可。（如果不存在就新建一个）\n配置服务器 PaperMC 提供了非常多的服务器修改配置，具体请查阅 官方文档。\n对于 mod 的说明 PaperMC 并不兼容 Fabric 的 mod。如果需要使用 Fabric 的 mod，请参考下面的内容使用 Fabric 服务器。\n使用 Fabric 安装 Fabric # 安装依赖 sudo apt install openjdk-17-jre-headless curl # 创建存储数据的文件夹 mkdir fabric cd fabric # 下载安装器 # 在 https://fabricmc.net/use/installer/ 获取下载链接 curl -o installer.jar \u0026lt;installer jar url\u0026gt; # 运行安装器 java -jar installer.jar server -mcversion 1.19.3 -downloadMinecraft # 安装完成厚可以删除安装器 rm installer.jar # 重命名 jar 文件 mv server.jar vanilla.jar mv fabric-server-launch.jar server.jar echo \u0026#34;serverJar=vanilla.jar\u0026#34; \u0026gt; fabric-server-launcher.properties # 启动服务器 java -jar server.jar 安装 mod 关掉已启动的服务器，将 mod 存储在 fabric/mods 文件夹下，重启服务器即可。（如果不存在就新建一个）\n安装 datapack 关掉已启动的服务器，将 datapack 存储在 fabric/world/datapacks 文件夹下，重启服务器即可。（如果不存在就新建一个）\nWarning\n如果你的 datapack 用于生成地形，请先删除已经创建好的地图文件，即删除整个 world 文件夹，否则 datapack 和已有存档会发生冲突。\n参考链接 PaperMC PaperMC - Download PaperMC - Configuration Fabric Fabric - Installing a Fabric Server without a GUI ","permalink":"https://aimerneige.com/zh/post/minecraft/how-to-build-a-minecraft-mod-server/","summary":"使用 PaperMC 安装 PaperMC 下载 PaperMC 提供的 jar 包，存储在恰当位置即可。\n启动 PaperMC java -Xms2G -Xmx2G -jar paper.jar --nogui 下面是官方提供的优化后的启动脚本：\njava -Xms10G -Xmx10G -XX:+UseG1GC -XX:+ParallelRefProcEnabled -XX:MaxGCPauseMillis=200 -XX:+UnlockExperimentalVMOptions -XX:+DisableExplicitGC -XX:+AlwaysPreTouch -XX:G1NewSizePercent=30 -XX:G1MaxNewSizePercent=40 -XX:G1HeapRegionSize=8M -XX:G1ReservePercent=20 -XX:G1HeapWastePercent=5 -XX:G1MixedGCCountTarget=4 -XX:InitiatingHeapOccupancyPercent=15 -XX:G1MixedGCLiveThresholdPercent=90 -XX:G1RSetUpdatingPauseTimePercent=5 -XX:SurvivorRatio=32 -XX:+PerfDisableSharedMem -XX:MaxTenuringThreshold=1 -Dusing.aikars.flags=https://mcflags.emc.gs -Daikars.new.flags=true -jar paper.jar --nogui 安装 datapack 关掉已启动的服务器，将 datapack 存储在 papermc/world/datapacks 文件夹下，重启服务器即可。（如果不存在就新建一个）\n安装插件 关掉已启动的服务器，将下载好的插件存储在 papermc/plugins 文件夹下，重启服务器即可。（如果不存在就新建一个）\n配置服务器 PaperMC 提供了非常多的服务器修改配置，具体请查阅 官方文档。\n对于 mod 的说明 PaperMC 并不兼容 Fabric 的 mod。如果需要使用 Fabric 的 mod，请参考下面的内容使用 Fabric 服务器。","title":"如何搭建 Minecraft Mod 服务器"},{"content":"前言 在 Linux 系统中，经常会遇到一些软件只提供了可执行文件，而并没有提供可以通过包管理安装的途径，常见于 AppImage 封装的软件，这时候每次需要运行软件都需要通过终端来执行，非常麻烦。不过这个问题可以通过手动编写 .desktop 文件来解决，这样这些可执行文件就可以和其他软件一样拥有桌面图标。\n用法 使用 vim 或其他文本编辑器直接编写 .desktop 文件后将其置于如下路径之一即可：\n/usr/share/applications/ /usr/local/share/applications/ ~/.local/share/applications/ 示例 来自 Arch Linux Wiki 的示例 [Desktop Entry] # The type as listed above Type=Application # The version of the desktop entry specification to which this file complies Version=1.0 # The name of the application Name=jMemorize # A comment which can/will be used as a tooltip Comment=Flash card based learning tool # The path to the folder in which the executable is run Path=/opt/jmemorise # The executable of the application, possibly with arguments. Exec=jmemorize # The name of the icon that will be used to display this entry Icon=jmemorize # Describes whether this application needs to be run in a terminal or not Terminal=false # Describes the categories in which this entry should be shown Categories=Education;Languages;Java; 其中，Type 和 Name 是必须的，其他都是可选项。\nFluent Reader Fluent Reader 是一款开源的 rss 阅读器，它有非常精美的界面，也支持包括 Linux 在内的全部桌面平台，但是它在 Linux 下只提供了 AppImage 格式的封包，虽然可以方便支持全部 Linux 平台但是如果不写 .desktop 文件每次启动都需要开终端很麻烦，这里以它为例来编写一个 .desktop 文件。\n下载 首先自然是下载软件，在 release 界面下载最新的 AppImage 文件即可。将其存储在适合的路径下即可，本文以 ~/Software/Fluent-Reader 为例。\n给予可执行权限 不要忘记使用 chmod 指令给刚下载的 AppImage 文件赋予可执行权限。\nchmod +x Fluent.Reader.1.1.3.AppImage 准备一个图标 一般地，在 GitHub 可以轻松找到软件的图标。\nwget https://raw.githubusercontent.com/yang991178/fluent-reader/master/build/icon.png 编写 .desktop 文件 vim ~/.local/share/applications/fluent-reader.desktop [Desktop Entry] Categories=Network;News; Exec=/home/aimer/Software/Fluent-Reader/Fluent.Reader.1.1.3.AppImage Icon=/home/aimer/Software/Fluent-Reader/icon.png Name=Fluent Reader Comment=A modern desktop RSS reader StartupNotify=true Terminal=false Type=Application HMCL HMCL 是一个 Minecraft 启动器，其提供的 Linux 客户端不是前文所述的 AppImage 文件，而是 Jar 文件。后文以此为例介绍如何编写 Jar 文件的 .desktop 文件。\n下载 在 HMCL 官网 或 GitHub release 下载即可。\n下载好后保存在适当的位置，本文以 /home/aimer/Software/hmcl/HMCL-3.5.3.228.jar 为例。\n准备 jdk 环境 新版的 Minecraft 需要 Java 17 的环境，可以通过包管理来安装 Java 17 的 JDK 环境：\nsudo pacman -S jdk17-openjdk 也可以解压在 OpenJDK 下载的压缩包并解压：\nOpenJDK JDK 17 Java SE 17 要保证 java 指令在环境变量中并可直接调用，如果不想将其添加到环境变量，在后文 Exec 中需要将 java 替换为完整路径。\n准备一个图标 在这里下载我使用的图标：\nhttps://www.deviantart.com/dharmainitiative2010/art/Minecraft-Icon-187010413\n当然你也可以使用其他图标文件。\n编写 .desktop 文件 vim ~/.local/share/applications/hmcl.desktop [Desktop Entry] Categories=Game;ActionGame;AdventureGame;RolePlaying; Exec=java -jar /home/aimer/Software/hmcl/HMCL-3.5.3.228.jar Icon=/home/aimer/Software/hmcl/icon.png Name=HMCL Comment=Hello Minecraft! Launcher Terminal=false Type=Application Categories Categories 的具体内容可以参考下面内容：\nhttps://specifications.freedesktop.org/menu-spec/latest/apa.html\nMain Category Description Notes AudioVideo Application for presenting, creating, or processing multimedia (audio/video) Audio An audio application Desktop entry must include AudioVideo as well Video A video application Desktop entry must include AudioVideo as well Development An application for development Education Educational software Game A game Graphics Application for viewing, creating, or processing graphics Network Network application such as a web browser Office An office type application Science Scientific software Settings Settings applications System System application, \u0026ldquo;System Tools\u0026rdquo; such as say a log viewer or network monitor Utility Small utility application, \u0026ldquo;Accessories\u0026rdquo; 参考链接 Arch Linux Wiki - Desktop entries Ask Ubuntu A. Registered Categories ","permalink":"https://aimerneige.com/zh/post/linux/how-to-write-a-desktop-file/","summary":"前言 在 Linux 系统中，经常会遇到一些软件只提供了可执行文件，而并没有提供可以通过包管理安装的途径，常见于 AppImage 封装的软件，这时候每次需要运行软件都需要通过终端来执行，非常麻烦。不过这个问题可以通过手动编写 .desktop 文件来解决，这样这些可执行文件就可以和其他软件一样拥有桌面图标。\n用法 使用 vim 或其他文本编辑器直接编写 .desktop 文件后将其置于如下路径之一即可：\n/usr/share/applications/ /usr/local/share/applications/ ~/.local/share/applications/ 示例 来自 Arch Linux Wiki 的示例 [Desktop Entry] # The type as listed above Type=Application # The version of the desktop entry specification to which this file complies Version=1.0 # The name of the application Name=jMemorize # A comment which can/will be used as a tooltip Comment=Flash card based learning tool # The path to the folder in which the executable is run Path=/opt/jmemorise # The executable of the application, possibly with arguments.","title":"如何编写 .desktop 文件"},{"content":"阅前须知 本文章面向具有一定运维经验的用户，不面向小白 本文章介绍的 Minecraft 是 Java 版本的 Minecraft 本文章只介绍纯净服的搭建，不会说明如何安装 mod 如非特殊说明，本文中出现的 “我的世界” 均指代 Minecraft 的中文翻译，而不是由网易代理的 “我的世界” 准备 可供外部连接的服务器 基础 Linux 知识 安装 首先要确定你的服务器是否可以被外部连接 有公网 IP 如果你有公网 IP，可以直接使用你的主机作为服务器，相当于你有一台私有的云服务器。\n没有公网 IP 如果你没有公网 IP，你需要购买一台云服务器，这样，你就拥有了一个可供外部连接的公网 IP。\n如果你对服务器配置要求较高，本地也有闲置主机可以用来跑 Minecraft 服务器，可以通过 frp 将本地的主机穿透出去，以供外部连接。这样云服务器的配置就可以很低，只负责转发网络数据。\n如果你对服务器的配置要求不高，也不想本地 24 小时开着一台机器，可以直接使用云服务器来跑 Minecraft 服务器。\n至于你需要多高的配置来运行 Minecraft 服务器，可以参考 Wiki 的内容：\n确保服务器可以被外部连接后，安装 Minecraft 下载服务器文件 在 官网 下载服务器运行所需的 jar 文件。\n官方只提供最新版的文件，如果你需要历史版本，使用官方启动器下载。\n运行服务器 直接使用官网的示例指令运行 jar 文件：\njava -Xmx1024M -Xms1024M -jar minecraft_server.1.19.3.jar nogui 如果你有更高的内存，可以修改 -Xmx1024M -Xms1024M 这一部分。\n第一次执行后，需要同意用户协议才可以继续执行，修改 eula.txt 这个文件，将 eula=false 改为 eula=true。\n同意用户协议之后，继续使用相同的指令运行 jar 文件，这时 jar 文件会释放很多配置文件，并自动启动服务器，这时可以尝试使用客户端连接。\n客户端连接成功后，证明服务器已成功运行，如需关闭服务器，使用 Ctrl-c 即可。\n配置 修改 server.properties 并重启即可。\n下面是一些常用设置：\n正版认证：\nonline-mode=false 关闭 online-mode=true 开启 种子设定\nlevel-seed=minecraft 地图存档设定\nlevel-name=world name 难度设定\ndifficulty=peaceful easy normal hard 启用白名单\nenforce-whitelist=true 人数上限\nmax-players=5 限制世界大小\nmax-world-size=10000 服务器名称\nmotd=MiraiChess Minecraft Server 限制挂机\nplayer-idle-timeout=30 禁止 pvp\npvp=false 关于 server.properties 的更多细节，请查阅 Wiki。\n自动备份 参考这篇文章：\nAnduin - Auto backup for Minecraft on Linux 升级 替换 server.jar 之后重启即可。\n","permalink":"https://aimerneige.com/zh/post/minecraft/how-to-build-your-minecraft-server/","summary":"阅前须知 本文章面向具有一定运维经验的用户，不面向小白 本文章介绍的 Minecraft 是 Java 版本的 Minecraft 本文章只介绍纯净服的搭建，不会说明如何安装 mod 如非特殊说明，本文中出现的 “我的世界” 均指代 Minecraft 的中文翻译，而不是由网易代理的 “我的世界” 准备 可供外部连接的服务器 基础 Linux 知识 安装 首先要确定你的服务器是否可以被外部连接 有公网 IP 如果你有公网 IP，可以直接使用你的主机作为服务器，相当于你有一台私有的云服务器。\n没有公网 IP 如果你没有公网 IP，你需要购买一台云服务器，这样，你就拥有了一个可供外部连接的公网 IP。\n如果你对服务器配置要求较高，本地也有闲置主机可以用来跑 Minecraft 服务器，可以通过 frp 将本地的主机穿透出去，以供外部连接。这样云服务器的配置就可以很低，只负责转发网络数据。\n如果你对服务器的配置要求不高，也不想本地 24 小时开着一台机器，可以直接使用云服务器来跑 Minecraft 服务器。\n至于你需要多高的配置来运行 Minecraft 服务器，可以参考 Wiki 的内容：\n确保服务器可以被外部连接后，安装 Minecraft 下载服务器文件 在 官网 下载服务器运行所需的 jar 文件。\n官方只提供最新版的文件，如果你需要历史版本，使用官方启动器下载。\n运行服务器 直接使用官网的示例指令运行 jar 文件：\njava -Xmx1024M -Xms1024M -jar minecraft_server.1.19.3.jar nogui 如果你有更高的内存，可以修改 -Xmx1024M -Xms1024M 这一部分。","title":"如何搭建你自己的 Minecraft 服务器"},{"content":"在 Ubuntu 服务器上安装 qBittorrent-nox 更新系统 sudo apt update \u0026amp;\u0026amp; sudo apt upgrade -y 导入 qBittorrent-nox 稳定版本的源 sudo add-apt-repository ppa:qbittorrent-team/qbittorrent-stable -y 导入 qBittorrent-nox 非稳定版本的源（每夜版） sudo add-apt-repository ppa:qbittorrent-team/qbittorrent-unstable -y 更新源 sudo apt update 安装 qBittorrent-nox sudo apt install qbittorrent-nox -y 创建用户和用户组 sudo adduser --system --group qbittorrent-nox # on fedora sudo groupadd qbittorrent-nox 将你添加到用户组中 sudo adduser your-username qbittorrent-nox # on fedora sudo usermod -aG qbittorrent-nox your-username 创建 service 文件 sudo vim /etc/systemd/system/qbittorrent-nox.service [Unit] Description=qBittorrent Command Line Client After=network.target [Service] Type=forking User=qbittorrent-nox Group=qbittorrent-nox UMask=022 ExecStart=/usr/bin/qbittorrent-nox -d --webui-port=8080 Restart=on-failure [Install] WantedBy=multi-user.target 重载 systemctl sudo systemctl daemon-reload 启动 qBittorrent-nox sudo systemctl start qbittorrent-nox 开启开机自启动 qBittorrent-nox sudo systemctl enable qbittorrent-nox 检查 qBittorrent-nox 是否启动 systemctl status qbittorrent-nox 登录到 qBittorrent-nox Item Value username admin password adminadmin 如何删除 qBittorrent-nox # Remove qBittorrent Stable sudo add-apt-repository --remove ppa:qbittorrent-team/qbittorrent-stable # Remove qBittorrent Unstable (Nightly) sudo add-apt-repository --remove ppa:qbittorrent-team/qbittorrent-unstable -y # Remove qBittorrent sudo apt autoremove qbittorrent-nox ","permalink":"https://aimerneige.com/zh/post/linux/install-qbittorrent-nox-on-ubuntu-server/","summary":"在 Ubuntu 服务器上安装 qBittorrent-nox 更新系统 sudo apt update \u0026amp;\u0026amp; sudo apt upgrade -y 导入 qBittorrent-nox 稳定版本的源 sudo add-apt-repository ppa:qbittorrent-team/qbittorrent-stable -y 导入 qBittorrent-nox 非稳定版本的源（每夜版） sudo add-apt-repository ppa:qbittorrent-team/qbittorrent-unstable -y 更新源 sudo apt update 安装 qBittorrent-nox sudo apt install qbittorrent-nox -y 创建用户和用户组 sudo adduser --system --group qbittorrent-nox # on fedora sudo groupadd qbittorrent-nox 将你添加到用户组中 sudo adduser your-username qbittorrent-nox # on fedora sudo usermod -aG qbittorrent-nox your-username 创建 service 文件 sudo vim /etc/systemd/system/qbittorrent-nox.service [Unit] Description=qBittorrent Command Line Client After=network.","title":"在 Ubuntu 服务器上安装 qBittorrent-nox"},{"content":"在 Fedora 系统上运行微信 安装 wine sudo dnf install wine 调整缩放比例 输入下面的指令打开 winecfg\nwinecfg 在 Graphics 一栏中调整合适的 dpi 以保证有舒适的使用体验。（4k 屏幕，192 dpi）\n下载并配置字体 依次执行如下指令即可\nsudo dnf install cabextract sudo dnf install winetricks winetricks corefonts gdiplus riched20 riched30 下载并安装微信 直接下载官方的 exe 安装包（在网页下载也是一样的）\nwget https://dldir1.qq.com/weixin/Windows/WeChatSetup.exe 使用 wine 启动微信\nwine ./WeChatSetup.exe 接下来按照 Windows 的安装逻辑点击下一步安装好微信\n安装结束后可以删除安装包\n修改语言设置 修改这个文件\nvim ~/.local/share/applications/wine/Programs/WeChat/WeChat.desktop 调整 Exec 这一部分，添加如下环境变量\nenv LC_ALL=\u0026#34;zh_CN.UTF8\u0026#34; 最终结果应该是这样（注意路径）\n[Desktop Entry] Name=WeChat Exec=env LC_ALL=\u0026#34;zh_CN.UTF8\u0026#34; env WINEPREFIX=\u0026#34;/home/aimer/.wine\u0026#34; wine C:\\\\\\\\ProgramData\\\\\\\\Microsoft\\\\\\\\Windows\\\\\\\\Start\\\\ Menu\\\\\\\\Programs\\\\\\\\WeChat\\\\\\\\WeChat.lnk Type=Application StartupNotify=true Path=/home/aimer/.wine/dosdevices/c:/Program Files (x86)/Tencent/WeChat Icon=E03C_WeChat.0 StartupWMClass=wechat.exe 启动微信 安装过程中会自动添加 desktop 文件，直接打开即可。\n已知问题 只能使用中文，使用英文时无法正常显示中文字符 表情包的名称显示不正常 通过微信调用的进程会携带中文的环境变量 程序窗口被覆盖后窗口阴影依然显示在最前 小程序有可能闪退 替代方案 nspawn 如果你不介意安装一个 systemd-nspawn 的容器的话，可以尝试这个项目：\nGitHub - loaden/nspawn-qq 社区包 请参考这篇博客文章：\nXUTHUS - fedora 安装微信和企业微信 参考链接 AnduinXue - Run WeChat in Ubuntu ","permalink":"https://aimerneige.com/zh/post/linux/install-wechat-on-fedora/","summary":"在 Fedora 系统上运行微信 安装 wine sudo dnf install wine 调整缩放比例 输入下面的指令打开 winecfg\nwinecfg 在 Graphics 一栏中调整合适的 dpi 以保证有舒适的使用体验。（4k 屏幕，192 dpi）\n下载并配置字体 依次执行如下指令即可\nsudo dnf install cabextract sudo dnf install winetricks winetricks corefonts gdiplus riched20 riched30 下载并安装微信 直接下载官方的 exe 安装包（在网页下载也是一样的）\nwget https://dldir1.qq.com/weixin/Windows/WeChatSetup.exe 使用 wine 启动微信\nwine ./WeChatSetup.exe 接下来按照 Windows 的安装逻辑点击下一步安装好微信\n安装结束后可以删除安装包\n修改语言设置 修改这个文件\nvim ~/.local/share/applications/wine/Programs/WeChat/WeChat.desktop 调整 Exec 这一部分，添加如下环境变量\nenv LC_ALL=\u0026#34;zh_CN.UTF8\u0026#34; 最终结果应该是这样（注意路径）\n[Desktop Entry] Name=WeChat Exec=env LC_ALL=\u0026#34;zh_CN.UTF8\u0026#34; env WINEPREFIX=\u0026#34;/home/aimer/.wine\u0026#34; wine C:\\\\\\\\ProgramData\\\\\\\\Microsoft\\\\\\\\Windows\\\\\\\\Start\\\\ Menu\\\\\\\\Programs\\\\\\\\WeChat\\\\\\\\WeChat.lnk Type=Application StartupNotify=true Path=/home/aimer/.","title":"在 Fedora 系统上安装微信"},{"content":"前言 在写项目的时候，有时候不可避免地要处理静态文件，如果将源码直接作为软件提供问题不大，使用相对路径读取这些静态文件就可以了。但是如果项目作为库向外公布显然不可行，使用相对路径是读取不到文件的，而使用绝对路径却会带来更大的问题：因为不同的人使用，路径绝对不可能完全一致的。如果要求用户在指定路径下放置这些依赖的静态文件，虽然可行但是会给用户带来很大的困扰，而且这样的实现方式显然不够优雅。这时候，将这些静态文件一起打包进可执行文件似乎是一个完美的解决方案，那么如何实现呢？最简单的方法是硬编码，将静态文件以文本或字节数组的形式直接编入源代码，go 也有一些库帮你自动生成代码，比如 go-bindata。很明显，这个库已经终止维护了，这是因为在 go 1.16 版本，官方发布了 embed 完美地解决了这个问题。本文简要介绍 embed 的一些基础用法。\nembed 假设我们有一个文件 hello.txt\nHello World! Hello go embed! 我们要写一个程序读取其中的内容并输出到终端：\n// file: main.go package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { s, err := os.ReadFile(\u0026#34;./hello.txt\u0026#34;) if err != nil { panic(err) } fmt.Println(string(s)) } 很简单，不是吗？\n➜ tree . . ├── go.mod ├── hello.txt └── main.go 0 directories, 3 files ➜ go build main.go ➜ ./main Hello World! Hello go embed! 但是如果 hello.txt 这个文件不存在的话，我们再次运行程序：\n➜ rm hello.txt ➜ tree . . ├── go.mod ├── main └── main.go 0 directories, 3 files ➜ ./main panic: open ./hello.txt: no such file or directory goroutine 1 [running]: main.main() /home/aimerneige/Code/go/go-embed-tutorial/main.go:11 +0x96 exit status 2 显然，因为读取不到文件，程序在第 11 行 panic 了。那么如何将 hello.txt 也一并打包入可执行文件呢？\n我们先不使用 embed，而是直接将文件内容硬编码，我们就会得到这样的代码：\n// file: main.go package main import ( \u0026#34;fmt\u0026#34; ) var f string = `Hello World! Hello go embed!` func main() { fmt.Println(f) } 显然我们可以得到相同的结果：\n➜ go build main.go ➜ tree . . ├── go.mod ├── main └── main.go 0 directories, 3 files ➜ ./main Hello World! Hello go embed! 这里，我们使用了一个字符串 f 来存储文件中的内容。但是直接将文本内容放入源代码十分不优雅，尤其是当文本文件内容较多的时候，源代码就会太混乱，改动也比较麻烦。\n接下来，我们恢复文件 hello.txt 后使用 embed 来优化它：\n// file: main.go package main import ( _ \u0026#34;embed\u0026#34; \u0026#34;fmt\u0026#34; ) //go:embed hello.txt var f string func main() { fmt.Println(f) } 首先，我们下划线引入了一个包 _　\u0026quot;embed\u0026quot;，这样做是为了引入 embed 包来执行它的 init 函数而不使用它。有了这个包以后，我们就可以以注释的方式来将一个文件的内容绑定到一个变量上：\n//go:embed hello.txt var f string 这个变量就会以字符串的形式存储文件 hello.txt 中的数据。\n这时候，我们在 hello.txt 文件存在的情况下编译程序：\n➜ go build main.go ➜ ./main Hello World! Hello go embed! 简单执行文件我们当然可以得到相同的输出，但是如果这个时候我们删除 hello.txt 会发生什么呢？\n➜ rm hello.txt ➜ tree . . ├── go.mod ├── main └── main.go 0 directories, 3 files ➜ ./main Hello World! Hello go embed! 正如预期的那样，我们依然得到了相同的输出，这是因为 hello.txt 中的内容已经编码到了可执行文件中了。\n类似地，我们还可以将图片编码为字节数组：\n// file: main.go package main import ( \u0026#34;bytes\u0026#34; _ \u0026#34;embed\u0026#34; \u0026#34;image/jpeg\u0026#34; \u0026#34;image/png\u0026#34; \u0026#34;os\u0026#34; ) //go:embed avatar.jpg var imgData []byte func main() { img, err := jpeg.Decode(bytes.NewReader(imgData)) if err != nil { panic(err) } f, err := os.Create(\u0026#34;./avatar.png\u0026#34;) if err != nil { panic(err) } defer f.Close() png.Encode(f, img) } ➜ tree . . ├── avatar.jpg ├── go.mod └── main.go 0 directories, 3 files 此时，我们编译 main.go，得到的可执行文件可以在任意目录下执行，并且都会在同级目录下输出一个 avatar.png。\n➜ go build main.go ➜ rm avatar.jpg ➜ ./main ➜ tree . . ├── avatar.png ├── go.mod ├── main └── main.go 0 directories, 4 files 注意 embed 的路径是相对于源代码文件而言的。如下例：\n➜ tree . . ├── go.mod ├── hello.txt ├── internal │ ├── asserts │ │ └── example.png │ ├── internal.go │ └── internal.txt └── main.go 2 directories, 6 files // file: internal/internal.go package internal import ( _ \u0026#34;embed\u0026#34; ) //go:embed internal.txt var txt string //go:embed asserts/example.png var png []byte 在 internal 包中，我们引用的俩个文件 internal/internal.txt 和 internal/asserts/example.png 的路径不是项目的相对路径，而是源文件 internal/internal.go 的相对路径。\n上面的写法已经能够覆盖大部分的场景了，但是，如果我们的文件很多要怎么办呢？这时就需要使用 embed.FS。embed.FS 可以将文件或文件夹打包入可执行文件，并抽象为 FS 以供调用：\n// file: main.go package main import ( \u0026#34;bytes\u0026#34; \u0026#34;embed\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;image/png\u0026#34; \u0026#34;io/fs\u0026#34; ) //go:embed resources/images var images embed.FS //go:embed resources/text var texts embed.FS //go:embed resources var resources embed.FS func main() { // read images for i := 1; i \u0026lt;= 5; i++ { filePath := fmt.Sprintf(\u0026#34;resources/images/Screenshot-%d.png\u0026#34;, i) imgFile, err := fs.ReadFile(images, filePath) if err != nil { panic(err) } image, err := png.Decode(bytes.NewReader(imgFile)) if err != nil { panic(err) } fmt.Printf(\u0026#34;size of %s: %dx%d\\n\u0026#34;, filePath, image.Bounds().Dx(), image.Bounds().Dy()) } // read text for i := 1; i \u0026lt;= 2; i++ { filePath := fmt.Sprintf(\u0026#34;resources/text/example%d.txt\u0026#34;, i) example, err := texts.ReadFile(filePath) if err != nil { panic(err) } fmt.Printf(\u0026#34;text of %s: %s\\n\u0026#34;, filePath, string(example)) } // read sub dir file license, err := resources.ReadFile(\u0026#34;resources/license/LICENSE\u0026#34;) if err != nil { panic(err) } fmt.Println(string(license)) } ➜ tree . . ├── go.mod ├── main.go └── resources ├── images │ ├── Screenshot-1.png │ ├── Screenshot-2.png │ ├── Screenshot-3.png │ ├── Screenshot-4.png │ └── Screenshot-5.png ├── license │ └── LICENSE └── text ├── example1.txt └── example2.txt 4 directories, 10 files ➜ cat resources/license/LICENSE EXAMPLE LICENSE FILE ➜ cat resources/text/example1.txt example 1 ➜ cat resources/text/example2.txt example 2 ➜ go build main.go ➜ ./main size of resources/images/Screenshot-1.png: 1920x1080 size of resources/images/Screenshot-2.png: 1920x1080 size of resources/images/Screenshot-3.png: 1920x1080 size of resources/images/Screenshot-4.png: 1920x1080 size of resources/images/Screenshot-5.png: 1920x1080 text of resources/text/example1.txt: example 1 text of resources/text/example2.txt: example 2 EXAMPLE LICENSE FILE ➜ rm resources -rf ➜ tree . . ├── go.mod ├── main └── main.go 0 directories, 3 files ➜ ./main size of resources/images/Screenshot-1.png: 1920x1080 size of resources/images/Screenshot-2.png: 1920x1080 size of resources/images/Screenshot-3.png: 1920x1080 size of resources/images/Screenshot-4.png: 1920x1080 size of resources/images/Screenshot-5.png: 1920x1080 text of resources/text/example1.txt: example 1 text of resources/text/example2.txt: example 2 EXAMPLE LICENSE FILE 要注意的是，我们读取文件时提供的路径一定是完整的相对路径。\nembed.FS 在 http 静态服务中非常有用：\nmain.go\n// file: main.go package main import ( \u0026#34;embed\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io/fs\u0026#34; \u0026#34;net/http\u0026#34; ) //go:embed public var public embed.FS func main() { mux := http.NewServeMux() mux.Handle(\u0026#34;/\u0026#34;, handler()) http.ListenAndServe(\u0026#34;:8080\u0026#34;, mux) } func handler() http.Handler { f := fs.FS(public) html, err := fs.Sub(f, \u0026#34;public\u0026#34;) if err != nil { panic(err) } fmt.Println(\u0026#34;Server start at http://127.0.0.1:8080/\u0026#34;) return http.FileServer(http.FS(html)) } index.html\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Hello World\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Hello World\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;This is a simple example index.html\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Click About bellow to see about page.\u0026lt;/p\u0026gt; \u0026lt;a href=\u0026#34;./about.html\u0026#34;\u0026gt;About\u0026lt;/a\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; about.html\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;About\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;About\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;This is a simple about.html page.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Click bellow Index to back to index page.\u0026lt;/p\u0026gt; \u0026lt;a href=\u0026#34;./index.html\u0026#34;\u0026gt;Index\u0026lt;/a\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ➜ tree . . ├── go.mod ├── main.go └── public ├── about.html └── index.html 1 directory, 4 files 当然还有很多其他神奇玩法，这里只介绍最基本的用法，其他大家发挥想象力。\n参考链接 embed ","permalink":"https://aimerneige.com/zh/post/go/go-embed/","summary":"前言 在写项目的时候，有时候不可避免地要处理静态文件，如果将源码直接作为软件提供问题不大，使用相对路径读取这些静态文件就可以了。但是如果项目作为库向外公布显然不可行，使用相对路径是读取不到文件的，而使用绝对路径却会带来更大的问题：因为不同的人使用，路径绝对不可能完全一致的。如果要求用户在指定路径下放置这些依赖的静态文件，虽然可行但是会给用户带来很大的困扰，而且这样的实现方式显然不够优雅。这时候，将这些静态文件一起打包进可执行文件似乎是一个完美的解决方案，那么如何实现呢？最简单的方法是硬编码，将静态文件以文本或字节数组的形式直接编入源代码，go 也有一些库帮你自动生成代码，比如 go-bindata。很明显，这个库已经终止维护了，这是因为在 go 1.16 版本，官方发布了 embed 完美地解决了这个问题。本文简要介绍 embed 的一些基础用法。\nembed 假设我们有一个文件 hello.txt\nHello World! Hello go embed! 我们要写一个程序读取其中的内容并输出到终端：\n// file: main.go package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { s, err := os.ReadFile(\u0026#34;./hello.txt\u0026#34;) if err != nil { panic(err) } fmt.Println(string(s)) } 很简单，不是吗？\n➜ tree . . ├── go.mod ├── hello.txt └── main.go 0 directories, 3 files ➜ go build main.go ➜ ./main Hello World! Hello go embed!","title":"Golang embed"},{"content":"前言 Go 语言的官方包 image 和 image/color 定义了非常多的类型，涵盖了很多的图像处理基础内容，本文简单介绍这些库中的基本概念和使用方法。\n常见类型介绍 Colors Colors 是一个接口，它的代码如下：\ntype Color interface { // RGBA returns the alpha-premultiplied red, green, blue and alpha values // for the color. Each value ranges within [0, 0xffff], but is represented // by a uint32 so that multiplying by a blend factor up to 0xffff will not // overflow. // // An alpha-premultiplied color component c has been scaled by alpha (a), // so has valid values 0 \u0026lt;= c \u0026lt;= a. RGBA() (r, g, b, a uint32) } 简单来说，它定义了一个函数，它将任意类型的颜色转化为 rgba 值。这个转化过程可能是有损失的，比如转化 CMYK 或 YCbCr 颜色空间的颜色。\nColor 的 rgba 值都是经过了 alpha 预乘的。\nColor 定义的 rgba 值类型是 uint32，但是它存储的颜色是 16 位色深，也就是其最大值为 65535，这样做为了兼容一些算法，以防止在某些乘法运算中出现溢出1。\nRGBA image/color 包同样定义了很多实现了 Color 接口的颜色类型，例如 RGBA，它的代码如下：\ntype RGBA struct { R, G, B, A uint8 } 它简单地实现了经典的“8 bit 色深”颜色。\n请注意，RGBA 的 R 字段是 [0, 255] 范围内的 8 位 alpha 预乘颜色。 RGBA 通过将该值乘以 0x101 来满足 Color 接口，以生成 [0, 65535] 范围内的 16 位 alpha 预乘颜色。 类似地，NRGBA 结构类型表示 8 位非 alpha 预乘颜色，如 PNG 图像格式所使用的那样。 直接操作 NRGBA 的字段时，值是非 alpha 预乘的，但在调用 RGBA 方法时，返回值是 alpha 预乘的。\nModel Model 是一个可以将 Colors 转化为其他 Colors 的接口，这个转化可能是有损失的。例如，GrayModel 可以将任何颜色转换为去饱和的灰色 Gray。 Palette 可以将任意颜色转化为有限的调色板中的一种颜色。\ntype Model interface { Convert(c Color) Color } type Palette []Color Points 一个 Points 是一个整数网格上的 (x, y) 的坐标，轴向右和向下递增。它既不是像素也不是方格。它是一个没有宽度，高度和颜色的点。下图中为了可视化，使用了带有彩色的方块。\ntype Point struct { X, Y int } p := image.Point{2, 1} Rectangles 一个 Rectangle 是整数网格上的轴对称矩形，它由俩个点来定义：它左上角的点和右下角的点。与点类似，矩形也没有颜色，但是下面图片为了可视化而使用了带有颜色的细线勾画出矩形，同时标出了他们的最小和最大点。\ntype Rectangle struct { Min, Max Point } 为了方便，image.Rect(x0, y0, x1, y1) 等价于 image.Rectangle{image.Point{x0, y0}, image.Point{x1, y1}}，但是书写起来更加容易。\n左边和上边被包括在矩形内，而右边和下边不包括在矩形内。即对于一个点 p 和一个矩形 r,p 来说，In(p) 当且仅当 r.Min.X \u0026lt;= p.X \u0026amp;\u0026amp; p.X \u0026lt; r.Max.X 时成立，对 Y 同理。这非常类似于切片 s[i0:i1] 包括 i0 而不包括 i1 一样。（与数组和切片不同，矩形经常包含有非零的原点）\nr := image.Rect(2, 1, 5, 5) // Dx 和 Dy 返回一个矩形的宽和高 fmt.Println(r.Dx(), r.Dy(), image.Pt(0, 0).In(r)) // prints 3 4 false 将点加入矩形 Add() 会平移矩形。点和矩形并非局限于右下象限。\nr := image.Rect(2, 1, 5, 5).Add(image.Pt(-4, -2)) fmt.Println(r.Dx(), r.Dy(), image.Pt(0, 0).In(r)) // prints 3 4 true 俩个矩形相交 Intersect() 会生成另一个矩形，它可能是空的。\nr := image.Rect(0, 0, 4, 3).Intersect(image.Rect(2, 2, 5, 5)) // Size 返回一个矩形的宽和高，作为一个点 fmt.Printf(\u0026#34;%#v\\n\u0026#34;, r.Size()) // prints image.Point{X:2, Y:1} 点 Point 和矩形 Rectangles 以值传递的方式返回值。将一个 Rectangle 作为 argument 传入一个函数相当于传入俩个 Point 或四个 int。\nImages 一个 Image 将 Rectangle 中的每个正方形网格映射到某种 Model 的 Color。\u0026ldquo;The pixel at (x, y)\u0026rdquo; 是指由点 (x, y)，(x+1, y)，(x+1, y+1) 和 (x, y+1) 定义的正方形网格的颜色。\ntype Image interface { // ColorModel returns the Image\u0026#39;s color model. ColorModel() color.Model // Bounds returns the domain for which At can return non-zero color. // The bounds do not necessarily contain the point (0, 0). Bounds() Rectangle // At returns the color of the pixel at (x, y). // At(Bounds().Min.X, Bounds().Min.Y) returns the upper-left pixel of the grid. // At(Bounds().Max.X-1, Bounds().Max.Y-1) returns the lower-right one. At(x, y int) color.Color } 一个常见的错误是认为图像的 Bounds 开始于 (0, 0)。例如，一个 GIF 动画包含一系列图像，第一个图像之后的每个图像通常只保存更改区域的像素数据，并且该区域不一定从 (0, 0) 开始。正确地遍历一个 Image 的像素的方法如下：\nb := m.Bounds() for y := b.Min.Y; y \u0026lt; b.Max.Y; y++ { for x := b.Min.X; x \u0026lt; b.Max.X; x++ { doStuffWith(m.At(x, y)) } } Image 的实现并不一定基于内存切片中的像素数据。例如，Uniform 表示一个具有巨大边界和统一颜色的图像，其内存就表示该颜色。\ntype Uniform struct { C color.Color } 但是，通常地，程序需要一个基于切片的，存储着像是 RGBA 和 Gray（其包引用位 image.RGBA 和 image.Gray）这样的数据结构类型的像素数据，并且实现了 Image 接口的图像。\ntype RGBA struct { // Pix holds the image\u0026#39;s pixels, in R, G, B, A order. The pixel at // (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*4]. Pix []uint8 // Stride is the Pix stride (in bytes) between vertically adjacent pixels. Stride int // Rect is the image\u0026#39;s bounds. Rect Rectangle } 这些类型同样提供了一个 Set(x, y int, c color.Color) 方法来允许一次修改图片的一个像素。\nm := image.NewRGBA(image.Rect(0, 0, 640, 480)) m.Set(5, 5, color.RGBA{255, 0, 0, 255}) 如果你在读或写大量的像素数据，直接读写这些结构中的 Pix 字段会更有效，同时也更复杂。\n基于切片的 Image 实现还提供了 SubImage 方法。它可以返回同一组数组下的 Image。修改子图片的像素会影响原图的像素，类似修改子切片 s[i0:i1] 同样会影响原始切片 s 一样。\nm0 := image.NewRGBA(image.Rect(0, 0, 8, 5)) m1 := m0.SubImage(image.Rect(1, 2, 5, 5)).(*image.RGBA) fmt.Println(m0.Bounds().Dx(), m1.Bounds().Dx()) // prints 8, 4 fmt.Println(m0.Stride == m1.Stride) // prints true 对于一些处理图片的 Pix 的底层代码，应该小心对于 Pix 的访问越界会影响图片边界外的像素。在上面的示例代码中，m1.Pix 覆盖的像素用蓝色阴影进行标注。而一些顶层代码，例如 At 和 Set 方法，或是 image/draw 包将会限制它们的操作在图片的边界内。\nImage Formats Go 语言标准库支持多种常见的图像格式，例如 GIF、JPEG 和 PNG。如果你知道源图像的文件格式，可以直接使用 io.Reader 进行解码。\nimport ( \u0026#34;image/jpeg\u0026#34; \u0026#34;image/png\u0026#34; \u0026#34;io\u0026#34; ) // convertJPEGToPNG converts from JPEG to PNG. func convertJPEGToPNG(w io.Writer, r io.Reader) error { img, err := jpeg.Decode(r) if err != nil { return err } return png.Encode(w, img) } 如果你有一张未知格式的图片，image.Decode 函数可以自动检测格式。可识别的格式是在运行时构建的，不限于标准库中的格式。图像格式包通常在 init 函数中注册其格式，main 包将“下划线引入”这样的包，不适用而仅仅为了注册其格式。\nimport ( \u0026#34;image\u0026#34; \u0026#34;image/png\u0026#34; \u0026#34;io\u0026#34; _ \u0026#34;code.google.com/p/vp8-go/webp\u0026#34; _ \u0026#34;image/jpeg\u0026#34; ) // convertToPNG converts from any recognized format to PNG. func convertToPNG(w io.Writer, r io.Reader) error { img, _, err := image.Decode(r) if err != nil { return err } return png.Encode(w, img) } 参考链接 https://go.dev/blog/image\nhttps://en.wikipedia.org/wiki/Alpha_compositing\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://aimerneige.com/zh/post/go/go-image-processing-basic/","summary":"前言 Go 语言的官方包 image 和 image/color 定义了非常多的类型，涵盖了很多的图像处理基础内容，本文简单介绍这些库中的基本概念和使用方法。\n常见类型介绍 Colors Colors 是一个接口，它的代码如下：\ntype Color interface { // RGBA returns the alpha-premultiplied red, green, blue and alpha values // for the color. Each value ranges within [0, 0xffff], but is represented // by a uint32 so that multiplying by a blend factor up to 0xffff will not // overflow. // // An alpha-premultiplied color component c has been scaled by alpha (a), // so has valid values 0 \u0026lt;= c \u0026lt;= a.","title":"Go 图像处理基础"},{"content":" 本文章转载自 Rustt\n简介 当我开始学习 Rust 的时候，我犯了一个错误，那就是先读《The Rust Programming Language》。虽然这是一本非常好的资料，但让新手一开始就阅读这本 20 个章节的书籍，简直令人望而生畏，大多数人还没开始就放弃了。没有人会让一个刚开始学习 JavaScript 或者 Python 的人去阅读一本 20 个章节的书籍。Rust 学习曲线非常陡峭的，但只要循序渐进的学习一定也能学有所成。\n摘要 如果你是一个完完全全的 Rust 小白，想要在一天中尽可能多的学习 Rust，那我推荐你去阅读 fasterthanlime 的《半小时快速了解 Rust》，然后完成 Rustlings 项目中的练习。\n如果你已经学过 Rust 的基本语法，你可以试着做一下 Exercism.io 网站上的 Rust 部分。如果你遇到了问题，你可以在 Google 或者 StackOverflow 上寻求帮助。我推荐你花点时间来简单的阅读和浏览一下《Rust Standard Library Docs》，它是一个很棒的学习资料，里面有一些简单且实用例子去帮助你更好的使用 Rust 的标准库。《Rust by Example》也是一本高质量的参考资料，你可以通过他快速的学习 Rust 的语法和特性。如果你想要更深入的理解 Rust 的某一个概念，那么我推荐你在《The Rust Programming Language》这本书中寻找相关的章节去阅读。尤其推荐在 Exercism.io 上进行练习。在完成每个题目之后，你可以查看其他所有人的题解，可以按点赞数排序来找到通俗易懂并且巧妙的题解。这是一种很棒的学习方式。\n此时，你可能已经是一个高级的初学者，能够找到属于自己的学习路线。但，如果你还需要更多的指导并想要尝试用 Rust 来写一些简单的程序，我推荐你试一着做一下 Advent of Code 2018 Calendar 上的练习。为什么推荐你做 2018 年的题目呢？因为当你做完了这个练习，你可以和 BurntSushi 提供的答案（ BurntSushi\u0026rsquo;s Advent of Code 2018 Rust solutions）进行对比。BurntSushi 写的 Rust 代码整洁、可读性强、通俗易懂。阅读一个有经验的 Rustacean 的代码将会使你受益无穷。\n现在可以退出了，文章最精彩的部分已经结束了。\nRust 练习场评测 别名：适合 Rust 新人的免费练习场评测\n大多数的练习场都不是专门用于练习 Rust 的，但都可以用于学习和练习 Rust。某些练习场还明确的表示可以提交 Rust 代码，并支持指定 Rust 版本。\n下面的练习场是按照从最坏到最好进行排序的。\nHackerRank 虽然 HackerRank 支持 Rust 语言，但大多数题目并不能提交题解。当我上传题解的时候被直接拒绝了。\n迷惑。我能浏览其他用户上传的 Rust 题解，按道理说，我也可以上传 Rust 题解。我尝试在 Google 上搜索这个问题，并没有找到有用的信息。我没办法将 HackerRank 和其他网站对比，因此我只想告诉你，别像我这样浪费时间，试试其他网站吧。\n欧拉计划（Project Euler） 我是从 2012 年开始学习编程的，当时我常常听到“如果你想要快速学习一门编程语言，来做几个 Project Euler 的题目吧！”，这在当时是个不错的建议，因为当时没有其他更好的选择。但在我看来，Project Euler 和编程关系不大。Project Euler 的题目大多是数学问题，而不是编程问题。这些题目需要大量的数学推导才能做出来，相比之下，所需要的编程能力是微不足道的。我不推荐你在 Project Euler 上学习 Rust，除非你数学很强或对这个网站有一些情结。\n力扣（LeetCode） 力扣上支持使用 Rust 来编写题解。力扣上的每个题目，你都会得到一个模板，模板通常包含一个没有被实现函数，你需要实现它并使其完成题目要求的功能。对于某个比较复杂的问题，模板可能会包含一些 struct 结构体和 impl 代码块、几个未被实现的方法。不幸的是，这些模板不是由人工撰写的，而是由机器自动生成的，这会导致你写出许多不规范 Rust 代码。让我们来对比一下力扣生成的 Rust 代码和优雅的 Rust 代码\n力扣生成的 Rust 代码 优雅的 Rust 代码 使用 Option\u0026lt;Rc\u0026lt;RefCell\u0026lt;Node\u0026gt;\u0026gt;\u0026gt; 来表示链表 使用 Option\u0026lt;Rc\u0026lt;RefCell\u0026lt;Node\u0026gt;\u0026gt;\u0026gt; 来表示链表太复杂。Option\u0026lt;Box\u0026lt;Node\u0026gt;\u0026gt; 同样能表示链表，并且使用起来更简单。 insert 方法需要改变 self，但生成的代码依然使用不可改变的借用。例如：fn insert(\u0026amp;self, val: i32) 将 self 需要改成可变借用。例如：fn insert(\u0026amp;mut self, val: i32) 即使程序不会使用负数，依然将所有的数字都声明为 32 位的整型。例如：fn nth_fib(n: i32) -\u0026gt; i32 如果程序不使用负数，我们应该使用无符号整数。例如：fn nth_fib(n: u32) -\u0026gt; u32 即使不需要获得参数的所有权，依然，。例如：fn sum(nums: Vec\u0026lt;i32\u0026gt;) -\u0026gt; i32 如果不需要参数的所有权，那么应该使用借用。例如：fn sum(nums: \u0026amp;[i32]) -\u0026gt; i32 在力扣上练习 Rust 的问题：\n力扣不允许你在做题时引入第三方的依赖。对于大多数语言来说，我认为这是合理的，但 Rust 的标准库非常小，甚至不支持正则表达式，使用 Rust 来做复杂字符串解析意义不大。由于其他语言的标准库自带正则表达式，所以做起来很简单。 所有的并发类问题，都不能提交题解。无法理解！安全且高效的并发是 Rust 的一大亮点。 在做完题目后，你能在问题的评论区查看其他用户的题解（许多用户喜欢讲题解发布在评论区），但由于 Rust 太小众，有时你会找不到 Rust 的题解。 力扣的常见问题：\n力扣上有大量低质量的题目。虽然用户可以选择喜欢或是不喜欢，但题目不会被删除，即使这个题目被绝大多数讨厌。我看过许多 100+ 投票的问题，其中 80% 都是不喜欢，我不理解为什么还要保留这些题目。 题目的难度等级不准确。力扣上的题目共有三个难度等级，分别是简单、中等、困难，但有很多简单题的解题率比难题更低。 不是所有的题目都能用任意语言提交。你没办法直观的判断题目支持哪些语言。例如，所有关于图的题目都不支持使用 Rust 提交。 力扣的优点：\n提交的题解会使用一组未知的数据来进行测试，如果程序在某个特殊数据出错了，它会把这个特殊数据显示给你，帮助你完善题解。 生成的所有 Rust 代码都符合 rustfmt 格式规范。 CodeWars Codewars 这个名字经常被误解，这里并没有竞赛。Codewar 的题目没有时间限制，也不会用你的执行速度和内存使用情况来评价你的题解。值得注意的是，没有任何人和你一决高下并不是什么坏事。\nCodewars 支持使用 Rust 来编写题解。类似力扣，Codewars 上的每个题目，你都会得到一个模板，模板通常会包含一个没有被实现函数，你需要实现它并使其完成题目要求的功能。这些模板是由人工撰写的，不是所有撰写模板的人都擅长 Rust，所以你可能偶然会碰到糟糕的 Rust 题目。例如：\nCodewars 的模板 优雅的 Rust 代码 有时不遵循 rustfmt 格式规范，例如：fn makeUppercase(s:\u0026amp;str)-\u0026gt;String 应该尽量遵循 rustfmt 格式规范的写法，例如：fn make_uppercase(s:\u0026amp;str)-\u0026gt;String 即使程序不会使用负数，依然将所有的数字都声明为 32 位的整型。例如：fn nth_fib(n: i32) -\u0026gt; i32 如果程序没有负数，我们应该使用无符号整数。例如：fn nth_fib(n: u32) -\u0026gt; u32 当程序需要将 -1 作为返回结果时，例如：fn get_index(needle:i32, haystack: \u0026amp;[i32])-\u0026gt;i32 应该将返回类型包装成 Option 类型。 例如：fn get_index(needle:i32, haystack: \u0026amp;[i32]) -\u0026gt; Option\u0026lt;usize\u0026gt; 有时不充分利用解引用强制转换。例如：fn do_stuff(s: \u0026amp;String, list: \u0026amp;Vec\u0026lt;i32\u0026gt;) 充分利用解引用强制转换。例如：fn do_stuff(s: \u0026amp;str, list: \u0026amp;[i32]) 上面的问题只是偶然会碰到，因为撰写模板的人的技能水品不同。相比于力扣，这是一个很大的进步，力扣上的 Rust 题目普遍都比较糟糕。在 Codewars 上的 Rust 学习者整体趋向于经验不足，因为我经常在高赞题解中看见非常普通的代码。例如：\nCodewars 的高赞题解 优雅的 Rust 写法 有时在函数末尾使用 return。例如：return result; 代码块可以被作为表达式，函数末尾的 return 通常省略不写。例如：result 总是使用紧凑的格式来让题解显得更简洁。 应该遵循 rustfmt 格式规范 有时调用不必要的函数。例如：str_slice.to_string().chars() 如果不需要，就不调用。例如：str_slice.chars() 总是使用迭代器来编写题解，忽视了其他方面的问题。 迭代器很好用，也很常用。但如果你把 15 个迭代器写在一行，或是将迭代器多层嵌套在一起，你应该考虑重构一些函数。 上面的问题也只是偶然会碰到。有经验的 Rust 开发者能很轻松的发现这些问题，但大部分的 Rust 初学者并不清楚它们正在学习不规范的代码。\nCodewars 在 Rust 方面的其他问题：\nRust 的题目非常少。这个网站一共 9000 多个题目，但只有 300 个支持使用 Rust 提交题解。 Codewars 的常见问题：\n当题目提交后，系统会使用一组未知的数据来测试你的题解。如果测试没有全部通过，系统并不会告诉你哪个数据出现问题。如果边界值没有在题目描述中清楚的交代，这会让人非常恼火。 Codewars 的优点：\nCodewars 有一个很小的 Rust 第三方依赖库列表，你可以用这些依赖库来解决问题。支持的第三方依赖库有：rand、chrono、regex、serde、itertools、lazy_static，它们能让 Rust 更接近其他语言。 你可以直接筛选出支持 Rust 的语言。 题解被提交后，会被自动发布到答案区。你也可以查看其他人的题解，并对其进行投票。你可以按点赞数对题解进行排序，前面的题解通常都是简单而高效的，但有时也会不符合规范。 题目的难度等级非常准确。Codewars 并不是像力扣一样将问题从易到难分为三个阶段（简单、中等、困难），而是将难度分为八个等级，它们由易到难分别是：8kyu、7kyu、6kyu、5kyu、4kyu、3kyu、2kyu、1kyu。在 8kyu 到 4 kyu 之间，我共计完成了 60 个题目，每一层难度都比只上一层难一点，非常适合训练。 Advent of Code Advent of Code（简称 AoC） 和编程语言完全没有关系。HackerRank、LeetCode、CodeWars 对 Rust 的支持并不好，相比之下，使用 AoC 可能效果更好。 在我在看，AoC 的题目是有趣的、多样化的、高质量的。\nAoC 的常见问题：\n当你完成练习后，没办法看到其他人的题解，并且无法判断在 Google 上搜索的题解质量。 为了解决上面的问题，我推荐去做 2018 年的题目，然后将你的题解和 BurntSushi 提供的答案（ BurntSushi\u0026rsquo;s Advent of Code 2018 Rust solutions）进行对比。BurntSushi 写的 Rust 代码整洁、可读性强、通俗易懂。如果你想要完成 2019 年的题目，我推荐参考 bcmyers 的题解（bcmyers\u0026rsquo; AoC 2019 Rust solutions），bcmyers 还在 Youtube 上制作了一个 Youtube 播放列表来讲解这些题目，他很好的解释了他的思考过程以及他为什么的代码要做这些事情。\nRustlings 极力推荐 Rustlings，因为它太棒了。这是一套能教会你 Rust 常规用法的练习。\n如果你是一个完完全全的 Rust 小白，你必须试试 Rustlings。不过，我极力推荐你先阅读 fasterthanlime 的《半小时快速了解 Rust》，它会帮助你迅速了解很多的 Rust 语法和概念。\nRustlings 的一点小缺陷：在“错误处理”（Error handling）和“类型转换”（Type conversions）部分突然难度飙升，很多人在这不知所措。\nRustlings 太短了，这并不是在批评它，Rustlings 设计的目的就是简单快速的介绍 Rust。但它写得太好了，我希望这样的内容能再多一点。\nExercism Exercism 有一套 Rust 的练习集，大致按主题和难度系数进行排序。虽然这套 Rust 的练习集类似于其他练习集，但所有的练习题都是由经验丰富的 Rustacean 来改写的，不会遇到在 LeetCode 或 Codewars 上的问题。上面由很多 Rust 的经典问题，实现一个标准库中的 Trait，或是写一个 Macro，或是使用多线程写一个并发问题，或是使用 unsafe 编写 Rust 代码。Exercism 是仅次于 Rustlings 的 Rust 学习资料。Rustlings 被放在 Exercism 之上，仅仅是因为 Rustlings 可以在一个晚上完成，而Exercism 的 Rust 练习集需要花费至少一个月。\n在 Exercism 上练习 Rust 的问题：\n不能使用“指导模式”（Mentored mode）。因为网站上大部分的 Rust 导师都并不活跃，所以最好使用“练习模式”（Practice mode） 一共有 92 个练习题，但其中很大一部分不会教你任何新知识，从中砍掉 20 个左右的练习题，可以让内容更紧凑一点。 Exercism 的优点：\n所有的练习题都是由经验丰富的 Rustacean 来改写的。 内容包括 Rust 的习惯用法、设计模式、语言特性。 由易到难，难度等级准确。 你可以在题解中引用任何第三方依赖库。 所有的测试案例都是公开的，如果测试样例不通过，你可以知道为什么没有通过。 提交题解之后，你可以查看别人的题解，并且题解可以按质量来排序。 结论 同摘要部分。\n讨论 可以在下面这些地方讨论本文：\nlearnrust subreddit official Rust users forum Twitter rust subreddit Hackernews Github 通知 通过这些渠道获取最新消息\nFollowing pretzelhammer on Twitter or Subscribing to this repo\u0026rsquo;s release RSS feed or Watching this repo\u0026rsquo;s releases (click Watch -\u0026gt; click Custom -\u0026gt; select Releases -\u0026gt; click Apply) 延申阅读 Common Rust Lifetime Misconceptions Sizedness in Rust Tour of Rust\u0026rsquo;s Standard Library Traits RESTful API in Sync \u0026amp; Async Rust Learn Assembly with Entirely Too Many Brainfuck Compilers ","permalink":"https://aimerneige.com/zh/post/rust/re-learning-rust-in-2022/","summary":"本文章转载自 Rustt\n简介 当我开始学习 Rust 的时候，我犯了一个错误，那就是先读《The Rust Programming Language》。虽然这是一本非常好的资料，但让新手一开始就阅读这本 20 个章节的书籍，简直令人望而生畏，大多数人还没开始就放弃了。没有人会让一个刚开始学习 JavaScript 或者 Python 的人去阅读一本 20 个章节的书籍。Rust 学习曲线非常陡峭的，但只要循序渐进的学习一定也能学有所成。\n摘要 如果你是一个完完全全的 Rust 小白，想要在一天中尽可能多的学习 Rust，那我推荐你去阅读 fasterthanlime 的《半小时快速了解 Rust》，然后完成 Rustlings 项目中的练习。\n如果你已经学过 Rust 的基本语法，你可以试着做一下 Exercism.io 网站上的 Rust 部分。如果你遇到了问题，你可以在 Google 或者 StackOverflow 上寻求帮助。我推荐你花点时间来简单的阅读和浏览一下《Rust Standard Library Docs》，它是一个很棒的学习资料，里面有一些简单且实用例子去帮助你更好的使用 Rust 的标准库。《Rust by Example》也是一本高质量的参考资料，你可以通过他快速的学习 Rust 的语法和特性。如果你想要更深入的理解 Rust 的某一个概念，那么我推荐你在《The Rust Programming Language》这本书中寻找相关的章节去阅读。尤其推荐在 Exercism.io 上进行练习。在完成每个题目之后，你可以查看其他所有人的题解，可以按点赞数排序来找到通俗易懂并且巧妙的题解。这是一种很棒的学习方式。\n此时，你可能已经是一个高级的初学者，能够找到属于自己的学习路线。但，如果你还需要更多的指导并想要尝试用 Rust 来写一些简单的程序，我推荐你试一着做一下 Advent of Code 2018 Calendar 上的练习。为什么推荐你做 2018 年的题目呢？因为当你做完了这个练习，你可以和 BurntSushi 提供的答案（ BurntSushi\u0026rsquo;s Advent of Code 2018 Rust solutions）进行对比。BurntSushi 写的 Rust 代码整洁、可读性强、通俗易懂。阅读一个有经验的 Rustacean 的代码将会使你受益无穷。","title":"[转载] Rust 大佬给初学者的学习建议"},{"content":"更新系统 # Debian apt update # Fedora dnf update 安装常用工具 # Debain apt install -y neofetch htop tree ncdu ranger zsh vim neovim git curl wget net-tools # Fedora dnf install -y neofetch htop tree ncdu ranger zsh vim neovim git curl wget util-linux-user 创建 sudo 用户 # Debian adduser aimer usermod -aG sudo aimer # Fedora useradd -G wheel aimer passwd aimer 测试 root 权限 su - aimer sudo cat /etc/shadow 配置 SSH 连接密钥 快速上传本地密钥 # 在你的本地环境执行这条指令 ssh-copy-id aimer@server 导入托管的密钥 # 导入你自己的密钥！ wget https://aimerneige.com/authorized_keys -O ~/.ssh/authorized_keys chmod 600 ~/.ssh/authorized_keys 测试连通性 ssh aimer@server 禁用 root 和密码登录 sudo vim /etc/ssh/sshd_config 将 PermitRootLogin 修改为 no 可以禁用 root 用户登录 将 PasswordAuthentication 修改为 no 可以禁用密码登录 设置 sudo 免密码 sudo visudo 在末尾添加如下内容\naimer ALL=(ALL) NOPASSWD:ALL 删除云服务商提供的其他用户 sudo deluser default Warning\n不要删除 root 用户。\n重启服务器 sudo reboot 其他配置 配置 zsh 环境 oh-my-zsh # 安装 oh-my-zsh sh -c \u0026#34;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\u0026#34; # 从 github 更新配置 （使用你自己的配置文件！！！！！） sh -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/aimerneige/zsh/master/install.sh)\u0026#34; # 安装 zsh-autosuggestions git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions # 安装 zsh-syntax-highlighting git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting # 安装 k git clone https://github.com/supercrabtree/k $ZSH_CUSTOM/plugins/k # 安装 starship curl -sS https://starship.rs/install.sh | sh lsd 安装 lsd\n# ubuntu # https://github.com/Peltoche/lsd/releases sudo dpkg -i lsd_0.23.1_amd64.deb # fedora sudo dnf install lsd -y 修改 .zshrc 文件，添加 alias\nalias ls=lsd bat 安装 bat\n# ubuntu sudo apt install bat -y # fedora sudo dnf install bat -y 修改 .zshrc 文件，添加 alias\n# add bellow line on ubuntu # alias bat=batcat alias cat=bat 安装 node 环境 安装 nvm\n# 使用 curl curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.2/install.sh | bash # 使用 wget wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.2/install.sh | bash 重新加载你的 shell\n使用 nvm 安装 lts 版本的 nodejs\nnvm install --lts 测试是否生效\nnode --version npm --version 安装 python 环境 # ubuntu sudo apt install -y python-is-python3 python2 python3-pip # fedora sudo dnf install -y python-is-python3 python2 python3-pip 配置 neovim 安装依赖 pip install neovim npm install --location=global neovim 下载配置 rm -rf ~/.config/nvim # 使用你自己的配置文件！！！！！ git clone https://github.com/aimerneige/nvim.git ~/.config/nvim 安装插件 # 启动 neovim 后自动下载 nvim 移除 snap 查看已安装的 snap 包\nsnap list 依次移除全部的 snap 包\nsudo snap remove --purge lxd sudo snap remove --purge core20 sudo snap remove --purge snapd 移除 snapd\nsudo apt remove --autoremove snapd 修改如下文件来防止自动更新下载 snap 的包\nsudo vim /etc/apt/preferences.d/nosnap.pref 写入如下内容：\nPackage: snapd Pin: release a=* Pin-Priority: -10 更新系统\nsudo apt update 命令手册工具 tldr # Debain sudo apt install tldr # Fedora sudo dnf install tldr cheat.sh curl -s https://cht.sh/:cht.sh | sudo tee /usr/local/bin/cht.sh \u0026amp;\u0026amp; sudo chmod +x /usr/local/bin/cht.sh 参考链接 Best-practice for authentication after creating a new Linux server ","permalink":"https://aimerneige.com/zh/post/devops/how-to-setup-your-new-linux-server/","summary":"更新系统 # Debian apt update # Fedora dnf update 安装常用工具 # Debain apt install -y neofetch htop tree ncdu ranger zsh vim neovim git curl wget net-tools # Fedora dnf install -y neofetch htop tree ncdu ranger zsh vim neovim git curl wget util-linux-user 创建 sudo 用户 # Debian adduser aimer usermod -aG sudo aimer # Fedora useradd -G wheel aimer passwd aimer 测试 root 权限 su - aimer sudo cat /etc/shadow 配置 SSH 连接密钥 快速上传本地密钥 # 在你的本地环境执行这条指令 ssh-copy-id aimer@server 导入托管的密钥 # 导入你自己的密钥！ wget https://aimerneige.","title":"如何配置新购置的 Linux 服务器"},{"content":"安装 wsl2 使用管理员身份开启 windows terminal.\n执行如下指令：\nwsl.exe --install 等待安装完成后在开始菜单执行重启(Restart)\nWarning\n注意是在开始菜单选择 Restart 而不能是选择 Shut Down 关机之后手动开机。\n安装过程中系统会自动下载 Ubuntu 的子系统，重启后会弹出 ubuntu 的命令行初始界面，输入用户名和密码即可开始使用 ubuntu 子系统。\n执行下面的指令设置 wsl 默认版本为 wsl2：\nwsl --set-default-version 2 安装其他版本的子系统 如果你想要其他版本的子系统，可以执行如下指令获取可通过 wsl 指令直接安装的发行版列表：\nwsl --list --online 返回数据类似下面这样：\nThe following is a list of valid distributions that can be installed. Install using \u0026#39;wsl --install -d \u0026lt;Distro\u0026gt;\u0026#39;. NAME FRIENDLY NAME Ubuntu Ubuntu Debian Debian GNU/Linux kali-linux Kali Linux Rolling openSUSE-42 openSUSE Leap 42 SLES-12 SUSE Linux Enterprise Server v12 Ubuntu-16.04 Ubuntu 16.04 LTS Ubuntu-18.04 Ubuntu 18.04 LTS Ubuntu-20.04 Ubuntu 20.04 LTS 如果想要安装某发行版，直接执行相应指令即可。例如可以通过下面的指令安装 debian 子系统：\nwsl --install -d Debian 当你安装了多个发行版，可以通过下面的指令指定默认发行版：\nwsl --setdefault \u0026lt;Distro\u0026gt; 例如，设置 Kali-linux 为默认发行版：\nwsl --setdefault Kali-linux 安装 fedora 35 wsl 提供的发行版中，并不包含 fedora 系统，所以只能手动安装。\n下载 fedora 镜像文件(rootfs image) 在 Fedora-Container-Base 选择需要的 fedora 版本下载。\n在保证 State 一栏为 complete 的前提下找到需要的版本。\nFedora 35 build\n我们要下载的文件是 xz 格式，同时选择正确的架构，如 x86_64。\n(点击下面的链接直接下载)\nFedora-Container-Base-35-20220221.0.x86_64.tar.xz\n下载好之后解压这个压缩文件，如果你不知道用什么软件，下载使用 7-Zip。\nWarning\n注意，解压为 tar 文件即可，不要继续解压 tar 文件。\n此时，查看你刚刚得到的 tar 文件，在里面找到一个名为 layer.tar 的文件，单独解压它，他就是我们需要的 rootfs image。把它解压到一个容易找到的位置，比如 Downloads 目录。为了便于使用，你可以将它重命名为 fedora-35-rootfs.tar。\n如果你想要一些更加官方的系统镜像，可以在 docker-brew-fedora 项目中找到你想要的文件。\n直接在 仓库 中找到对应的版本和架构后下载对应的文件即可。比如，你可能下载了 fedora-35-x86_64.tar.xz，下载完成后，解压这个文件，得到 tar 文件，这个 tar 文件就是 rootfs image。如果愿意，你也可以将它重命名为 fedora-35-rootfs.tar。\n创建你的 wsl 存储目录 创建一个文件夹来保存你的 wsl 文件。\nmkdir $HOME\\wsl\\fedora 释放镜像文件 假设你想要将子系统命名为 fedora，想要把它保存在 $HOME\\wsl\\fedora 目录下，同时 rootfs 文件存储在 $HOME\\Downloads\\fedora-35-rootfs.tar，执行下面的指令：\nwsl --import fedora $HOME\\wsl\\fedora $HOME\\Downloads\\fedora-35-rootfs.tar 检查安装情况 wsl -l 使用 root 启动 fedora 子系统： wsl -d fedora 设置 fedora 为默认发行版 wsl -s fedora 修复问题 Info\n注：以下问题是否存在取决于你下载的 fedora 版本，如果你没有对应错误直接跳过即可。\n挂载错误 如果你在第一次启动 fedora 时得到了以下错误：\nAn error occurred mounting one of your file systems. Please run \u0026#39;dmesg\u0026#39; for more details. 这是由于系统缺少 mount 指令造成的，如果你不需要 mount 指令也不在意错误，完全可以忽略这个错误（虽然还是建议修一下）。\n安装 util-linux 这个包即可。（如果你是一个极简主义者，安装 util-linux-core 这个包）\ndnf install -y util-linux 安装完成后关闭 fedora 重启即可。\nwsl -t fedora 配置你的 fedora 升级系统 dnf update 创建用户 继续之前，先安装下面的包：\ndnf install -y passwd cracklib-dicts 在 wheel 用户组下创建名为 myusername 的用户\nuseradd -G wheel myusername 为用户 myusername 设置密码\npasswd myusername 使用指定用户登录 wsl\nwsl -d fedora -u myusername 查看是否成功\nwhoami 检查是否具有 sudo 权限\nsudo cat /etc/shadow 设置默认用户 首先你的系统必须是 Windows build 18980 之后的版本，只需要 修改 wsl 配置文件 即可。\n如果你没有创建过 /etc/wsl.conf 文件，直接执行如下指令：\nprintf \u0026#34;\\n[user]\\ndefault = myusername\\n\u0026#34; | sudo tee -a /etc/wsl.conf 或者手动添加下面内容到 /etc/wsl.conf：\n[user] default = myusername 关闭 fedora 子系统。\nwsl -t fedora 在不指定用户的情况下启动 fedora 子系统，检查用户是否正确。\n容器 如果你需要运行容器，重新安装 shadow-utils 确保修复一些 rootfs 带来的错误：\nsudo dnf reinstall -y shadow-utils ping 如果你想要执行 ping 指令，执行下面的操作：\nsudo dnf install -y procps-ng iputils sudo sysctl -w net.ipv4.ping_group_range=\u0026#34;0 2000\u0026#34; 常用指令 安装下面的包来启用 Linux 下常用指令：\nsudo dnf -y install iproute findutils ncurses initscripts 编辑器 安装必要的编辑器，你可以按照喜好选择 vim nano 或 micro。\nsudo dnf install -y vim man 继续之前首先要确保 nodocs 选项没有被开启，你可以手动编辑 tsflags=nodocs 这一行，也可以直接执行下面的指令：\ngrep -v nodocs /etc/dnf/dnf.conf | sudo tee /etc/dnf/dnf.conf 接下来安装 man\nsudo dnf install -y man man-pages 安装完成之后，在这之后安装的软件就可以使用 man 指令查看文档了，但是之前已经安装好的软件，并不能查看文档，比如现在执行 man dnf 就不会得到任何结果。需要执行 sudo dnf reinstall -y dnf 重新安装 dnf 之后，才可以正确查看相关文档。\n执行下面的指令重新安装全部的包：\nWarning\n这一步非常费时，如果你不常用 man 可以选择跳过。\nfor pkg in $(dnf repoquery --installed --qf \u0026#34;%{name}\u0026#34;); do sudo dnf reinstall -qy $pkg; done 允许调用 Windows 的浏览器 首先安装 wslu\nsudo dnf copr enable wslutilities/wslu sudo dnf install wslu 添加如下配置\nexport BROWSER=wslview 导出系统 为了方便之后安装，可以将系统导出。\n首先清理掉缓存文件：\nsudo dnf clean all 使用下面的指令导出 fedora 子系统到 $HOME\\Downloads\\fedora-wsl.tar 目录下。\nwsl --export fedora $HOME\\Downloads\\fedora-wsl.tar 之后要使用的时候，可以使用下面的指令导入：\nmkdir $HOME\\wsl\\freshfedora wsl --import freshfedora $HOME\\wsl\\freshfedora $HOME\\Downloads\\fedora-wsl.tar wsl 常用指令 查看当前正在运行的子系统 wsl --list --running 关闭指定子系统 wsl --terminate \u0026lt;Distro\u0026gt; 例如关闭正在运行的 Ubuntu 子系统：\nwsl --terminate Ubuntu 关闭全部子系统 wsl --shutdown 升级 wsl wsl --update 版本回滚 wsl --update --rollback 删除子系统 wsl --unregister \u0026lt;Distro\u0026gt; wsl 使用技巧 在文件资源管理器中输入 \\\\wsl$ 即可进入 wsl 的目录。可以将它添加到文件资源管理器的网络路径里便于访问。\n参考 Install Fedora 36 or earlier on Windows Subsystem for Linux (WSL)\n","permalink":"https://aimerneige.com/zh/post/others/install-fedora35-on-wsl/","summary":"安装 wsl2 使用管理员身份开启 windows terminal.\n执行如下指令：\nwsl.exe --install 等待安装完成后在开始菜单执行重启(Restart)\nWarning\n注意是在开始菜单选择 Restart 而不能是选择 Shut Down 关机之后手动开机。\n安装过程中系统会自动下载 Ubuntu 的子系统，重启后会弹出 ubuntu 的命令行初始界面，输入用户名和密码即可开始使用 ubuntu 子系统。\n执行下面的指令设置 wsl 默认版本为 wsl2：\nwsl --set-default-version 2 安装其他版本的子系统 如果你想要其他版本的子系统，可以执行如下指令获取可通过 wsl 指令直接安装的发行版列表：\nwsl --list --online 返回数据类似下面这样：\nThe following is a list of valid distributions that can be installed. Install using \u0026#39;wsl --install -d \u0026lt;Distro\u0026gt;\u0026#39;. NAME FRIENDLY NAME Ubuntu Ubuntu Debian Debian GNU/Linux kali-linux Kali Linux Rolling openSUSE-42 openSUSE Leap 42 SLES-12 SUSE Linux Enterprise Server v12 Ubuntu-16.","title":"在 wsl 下安装 fedora 35"},{"content":"什么是 find 正如它的名字一样，find 指令用于查找文件。\nLinux find 命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则 find 命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。\n来源: 菜鸟教程\nThe find command in UNIX is a command line utility for walking a file hierarchy. It can be used to find files and directories and perform subsequent operations on them. It supports searching by file, folder, name, creation date, modification date, owner and permissions. By using the ‘-exec’ other UNIX commands can be executed on files or folders found.\nFrom: Geeks for Geeks\n基础语法 find [options] [path...] [expression] The options attribute controls the treatment of the symbolic links, debugging options, and optimization method. The path... attribute defines the starting directory or directories where find will search the files. The expression attribute is made up of options, search patterns, and actions separated by operators. From: Linuxize\n[options] options 属性用于控制一些额外选项。\nNote\n如果查询 man find，会得到这样一份语法说明:\nfind [-H] [-L] [-P] [-D debugopts] [-Olevel] [starting-point...] [expression] 本文将 [-H] [-L] [-P] [-D debugopts] [-Olevel] 这一部分抽象成了 options\n-H, -L and -P 用于控制对 symbolic link 的处理方法。\n[-D debugopts] 用于控制调试功能。\n[-Olevel] 用于控制优化方法。\n具体细节查 man 吧，这块也不常用，有空补。 [path\u0026hellip;] path 即开始查找的根目录。\n使用 find 时，这里可以是一个目录，也可以是多个目录。\nWarning\n用户必须有对应目录的读权限才可以正常执行，否则会返回错误信息。\n[expression] 包含各种选项，搜索模式和操作。比如可以指定文件名，文件大小，修改日期等选项来过滤查找内容。\n使用样例 搜索当前目录下全部名称为 avatar 的文件或文件夹 find . -name \u0026#34;avatar\u0026#34; 搜索当前目录下所有 go 源代码文件 find . -name \u0026#34;*.go\u0026#34; -type f Note\n如果没有 -type f，输出结果可能包含有以 *.go 结尾的文件夹。\n查找最近 20 天内更新过的文件 find . -ctime -20 只搜索当前目录下的文件和文件夹而不递归搜索 find . -maxdepth 1 Warning\n-maxdepth 作为全局选项应该位于其他选项的前面。\n# 正确的做法 find . -maxdepth 1 -name \u0026#34;*avatar*\u0026#34; # 不当的做法（会有警告） find . -name \u0026#34;*avatar*\u0026#34; -maxdepth 1 删除当前目录下名为 temp 的文件 # 直接删 find . -type f -name \u0026#34;temp\u0026#34; -delete # 打印一下删了哪些文件 find . -type f -name \u0026#34;temp\u0026#34; -delete -print # 为了防止删错，还是确认一下吧 find . -type f -name \u0026#34;temp\u0026#34; -ok rm {} \\; 查找一下七天前的旧日志，并在删除之前询问它们 find ./log -type f -mtime +7 -ok rm {} \\; 查找指定目录下有哪些空文件 # 打印文件名 find /home/aimerneige /root -type f -size 0 # 调用 ls 看一下文件属性吧 find /home/aimerneige /root -type f -size 0 -exec ls -l {} \\; 查找当前目录下指定大小范围内的文件 # 大于 200k find . -type f -size +200k # 小于200k find . -type f -size -200k # 在 50k 与 200k 之间 find . -type f -size +50k -200k 查找全部 ntfs 硬盘中拷贝出的文件 # 查找权限为 777 的文件，并打印详细信息 find . -type f -perm 777 -exec ls -l {} \\; # 777 太讨厌了，权限改为默认的 664 find . -type f -perm 777 -exec chmod 664 {} \\; 看一下当前目录下文件占用情况 find . -type d -exec du -sh {} \\; 批量添加文件后缀 find . -type f -name \u0026#34;*.JPG\u0026#34; -exec mv {} {}.jpg \\; 使用 bat 查看当前目录下全部 go 源代码 find . -type f -name \u0026#34;*.go\u0026#34; -exec bat {} \\; 使用技巧 当搜索目标路径为当前目录.时，可以省略不写 find -type f -name \u0026#34;*.go\u0026#34; # 上面的指令和下面的等价 find . -type f -name \u0026#34;*.go\u0026#34; 当结果过多时，使用 xargs 代替 -exec find ~ -type f -name \u0026#34;*.cpp\u0026#34; -exec ls -l {} \\; exec 的原理是将查找结果一次性发送到后面的命令当中，如果结果过多会导致数据溢出而报错。\n使用管道以及 xargs 来避免这个问题：\nfind ~ -type f -name \u0026#34;*.cpp\u0026#34; | xargs ls -l 结果太多了不好看，我们把结果输出到一个文件里面。\nfind ~ -type f -name \u0026#34;*.cpp\u0026#34; | xargs ls -l \u0026gt; ./result.txt ","permalink":"https://aimerneige.com/zh/post/linux/basic-usage-of-find/","summary":"什么是 find 正如它的名字一样，find 指令用于查找文件。\nLinux find 命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则 find 命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。\n来源: 菜鸟教程\nThe find command in UNIX is a command line utility for walking a file hierarchy. It can be used to find files and directories and perform subsequent operations on them. It supports searching by file, folder, name, creation date, modification date, owner and permissions. By using the ‘-exec’ other UNIX commands can be executed on files or folders found.","title":"find 指令的基本用法"},{"content":"前言 毫无疑问，idea 是最好的 Java IDE 之一，它对 Spring 也有很好的支持，但是由于某高校的 JetBrains 授权被拉入黑名单，导致我无法继续使用正版授权，虽然可以通过给 JetBrains 写邮件，证明自己高校学生的身份后继续获取授权，但是实在是懒，而且我也不是很喜欢使用 IDE，于是就就打算使用 vscode 进行开发。\nVisual Studio Code 作为一款优秀的代码编辑器，有非常多的插件，经过配置后完全可以胜任大部分 IDE 的功能，本文章简要介绍如何构建 spring 的开发环境。\n配置 安装配置 Java 和 Maven Tip\n正常流程配置 Java 和 Maven，如果你已经配置过可以直接跳过\n下载所需的 JDK 并解压。 在环境变量中配置 JAVA_HOME 在系统环境变量 PATH 中添加 JAVA_HOME/bin 下载 Maven 并解压 在环境变量中配置 MAVEN_HOME 在系统环境变量 PATH 中添加 MAVEN_HOME/bin 安装必要插件 Extension Pack For Java Gradle Extension Pack Spring Boot Extension Pack SonarLint Java Code Generators XML Dependency Analytics 在 settings.json 中简单配置 { \u0026#34;sonarlint.ls.javaHome\u0026#34;: \u0026#34;/home/aimerneige/.jdks/openjdk-17.0.1\u0026#34;, \u0026#34;java.configuration.runtimes\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;JavaSE-17\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;/home/aimerneige/.jdks/openjdk-17.0.1\u0026#34;, \u0026#34;default\u0026#34;: true }, { \u0026#34;name\u0026#34;: \u0026#34;JavaSE-11\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;/home/aimerneige/.jdks/corretto-11.0.13\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;JavaSE-1.8\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;/home/aimerneige/.jdks/corretto-1.8.0_312\u0026#34; } ], \u0026#34;spring.initializr.defaultLanguage\u0026#34;: \u0026#34;Java\u0026#34;, \u0026#34;spring.initializr.defaultJavaVersion\u0026#34;: \u0026#34;8\u0026#34;, \u0026#34;spring.initializr.defaultArtifactId\u0026#34;: \u0026#34;demo\u0026#34;, \u0026#34;spring.initializr.defaultGroupId\u0026#34;: \u0026#34;com.aimerneige\u0026#34;, \u0026#34;spring.initializr.serviceUrl\u0026#34;: [ \u0026#34;https://start.spring.io\u0026#34; ], \u0026#34;spring.initializr.defaultPackaging\u0026#34;: \u0026#34;JAR\u0026#34;, \u0026#34;spring.initializr.defaultOpenProjectMethod\u0026#34;: \u0026#34;Open\u0026#34; } 以上配置的具体功能可以自行查看插件的官方文档\n创建新项目 通过 Ctrl + Shift + P 快捷键，输入指令 Spring Initializr 后选择创建 Gradle 或 Maven 项目，按照指引完成新项目的创建。\n","permalink":"https://aimerneige.com/zh/post/java/start-develop-spring-project-on-vscode/","summary":"前言 毫无疑问，idea 是最好的 Java IDE 之一，它对 Spring 也有很好的支持，但是由于某高校的 JetBrains 授权被拉入黑名单，导致我无法继续使用正版授权，虽然可以通过给 JetBrains 写邮件，证明自己高校学生的身份后继续获取授权，但是实在是懒，而且我也不是很喜欢使用 IDE，于是就就打算使用 vscode 进行开发。\nVisual Studio Code 作为一款优秀的代码编辑器，有非常多的插件，经过配置后完全可以胜任大部分 IDE 的功能，本文章简要介绍如何构建 spring 的开发环境。\n配置 安装配置 Java 和 Maven Tip\n正常流程配置 Java 和 Maven，如果你已经配置过可以直接跳过\n下载所需的 JDK 并解压。 在环境变量中配置 JAVA_HOME 在系统环境变量 PATH 中添加 JAVA_HOME/bin 下载 Maven 并解压 在环境变量中配置 MAVEN_HOME 在系统环境变量 PATH 中添加 MAVEN_HOME/bin 安装必要插件 Extension Pack For Java Gradle Extension Pack Spring Boot Extension Pack SonarLint Java Code Generators XML Dependency Analytics 在 settings.","title":"使用 vscode 开发 Spring 项目"},{"content":" 由于某些网络原因1，本文所提到的部分网站、下载链接可能在中国大陆地区无法访问，请自行查找解决方案，本文不再赘述。\n如果你在阅读本文时遇到了任何问题，请查阅 go 语言官方网站。\n下载预编译文件 在 Download Go 选择适合你平台的最新版本文件下载。\n本文不推荐使用一键安装包的方式安装 go 语言，即请不要直接下载下图所示的文件:\n我们在下面的 Stable versions 后找到最新版本的 go，选择适合自己电脑系统与架构的压缩包。要选择 Archive　而不要选择 Installer。\nTip\n当然使用 msi 等一键安装包安装也是完全可以的，如果你想要使用一键安装包的方式安装 go，请查阅其他资料。\n如果你想要通过源码安装，请自行查阅 通过源码构建。\n安装 \u0026amp; 配置 下面分别具体说明不同平台下安装和配置的方法。\nLinux 解压压缩文件 这里我们可以直接使用 官方安装指南 提供的指令来解压。\nrm -rf /usr/local/go \u0026amp;\u0026amp; tar -C /usr/local -xzf go1.17.linux-amd64.tar.gz 本指令会将 go 安装在 /usr/local/go 路径下，因此执行命令需要 root 权限。当然，如果想要将 go 安装在其他路径也是可以的，但是还是推荐安装在官方推荐的路径下。\nInfo\n如果你使用了其他的路径来安装 go，在之后的配置过程中记得要修改 GOROOT 变量修改为你所安装的路径。\n执行命令前请先切换工作目录，确保当前路径下有刚刚下载好的压缩包。\nWarning\n压缩包名 go1.17.linux-amd64.tar.gz 可能有所不同，这取决于你安装的 go 版本和操作系统及处理器架构。\n配置环境变量 成功解压后，如果你尝试直接在终端执行 go 指令，你会发现系统并没有识别到你刚安装的 go 二进制文件，这是因为我们还没有对 go 的环境变量进行配置。\n根据你所使用的不同的 shell，直接修改对应的配置文件，写入如下内容即可。\n例如在 bash 下要修改 ~/.bashrc，而在 zsh 下则需要修改 ~/.zshrc。\nexport GOROOT=/usr/local/go export GOPATH=$HOME/golang export PATH=$GOROOT/bin:$PATH export PATH=$GOPATH/bin:$PATH export GO111MODULE=on # export GOPROXY=https://goproxy.cn export GOROOT=/usr/local/go 为 go 的安装目录，即之前的解压路径。 export GOPATH=$HOME/golang 为 go 的工作区目录，所有的源代码、代码包等会存放在这里，可以自己定义。 export PATH=$GOROOT/bin:$PATH 与 export PATH=$GOPATH/bin:$PATH 将可执行文件目录添加到环境变量。不需要修改。 export GO111MODULE=on 启用 GO111MODULE。建议启用。 export GOPROXY=https://goproxy.cn 使用 goproxy.cn 提供的代理服务，如果你有其他的代理服务可以注释掉它。 Tip\n上面的安装方式只有家目录对应的用户可以使用 go 指令，如果你想要全局注册，修改 /etc/profile 文件。\n完成修改后，使用 source 指令应用更改，之后 go 就配置好了。\nWarning\n使用 source 指令时还要指定文件，如果你在使用 bash，修改了 ~/.bashrc，那么要执行 source ~/.bashrc，同理，可得使用 zsh，修改了 ~/.zshrc 需要执行 source ~/.zshrc。\n不会真的有 Linux 小白只执行 source 吧，不会吧，不会吧。\n可以在终端下查看 go env 指令是否有输出检查 go 是否可用。\nmac OS 与 Linux 类似，下载好压缩文件后将其解压，修改配置即可。\nNote\n在 macOS 下默认安装了 zsh，你可以直接修改 ~/.zshrc，如果你想要全局配置，修改 /etc/profile。\nWindows 首先解压下载好的压缩文件，记住自己解压的位置。一般地，我会将 go 安装在 C:\\sdk\\go 下。\n配置环境变量\nWarning\n下文中提到的 GOROOT GOPATH 等要按照自己的需求更改，不可直接复制。\n打开“开始”并搜索“env” 选择“编辑系统环境变量” 点击“环境变量…”按钮 在“\u0026lt;你的用户名\u0026gt; 的用户变量”章节下（上半部分） 配置 GOROOT 点击“新建…”按钮 选择“变量名”输入框并输入“GOROOT” 选择“变量值”输入框并输入“C:\\sdk\\go” 点击“确定”按钮 配置 GOPATH 点击“新建…”按钮 选择“变量名”输入框并输入“GOPATH” 选择“变量值”输入框并输入“D:\\Code\\golang” 点击“确定”按钮 启用 GO111MODULE 点击“新建…”按钮 选择“变量名”输入框并输入“GO111MODULE” 选择“变量值”输入框并输入“on” 点击“确定”按钮 启用代理服务 点击“新建…”按钮 选择“变量名”输入框并输入“GOPROXY” 选择“变量值”输入框并输入“https://goproxy.cn” 点击“确定”按钮 最后记得把 %GOROOT%\\bin 和 %GOPATH%\\bin 添加进环境变量。\n检查 go env 的输出，验证安装是否成功。\n如何更新 go 重新执行之前的解压指令即可。即先删除 GOROOT 路径下所有文件，然后重新解压新版的 go 压缩文件。\n如果你在使用 Windows，删除后手动解压。\nhttps://en.wikipedia.org/wiki/Great_Firewall\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://aimerneige.com/zh/post/go/go-env-setup-for-beginner/","summary":"由于某些网络原因1，本文所提到的部分网站、下载链接可能在中国大陆地区无法访问，请自行查找解决方案，本文不再赘述。\n如果你在阅读本文时遇到了任何问题，请查阅 go 语言官方网站。\n下载预编译文件 在 Download Go 选择适合你平台的最新版本文件下载。\n本文不推荐使用一键安装包的方式安装 go 语言，即请不要直接下载下图所示的文件:\n我们在下面的 Stable versions 后找到最新版本的 go，选择适合自己电脑系统与架构的压缩包。要选择 Archive　而不要选择 Installer。\nTip\n当然使用 msi 等一键安装包安装也是完全可以的，如果你想要使用一键安装包的方式安装 go，请查阅其他资料。\n如果你想要通过源码安装，请自行查阅 通过源码构建。\n安装 \u0026amp; 配置 下面分别具体说明不同平台下安装和配置的方法。\nLinux 解压压缩文件 这里我们可以直接使用 官方安装指南 提供的指令来解压。\nrm -rf /usr/local/go \u0026amp;\u0026amp; tar -C /usr/local -xzf go1.17.linux-amd64.tar.gz 本指令会将 go 安装在 /usr/local/go 路径下，因此执行命令需要 root 权限。当然，如果想要将 go 安装在其他路径也是可以的，但是还是推荐安装在官方推荐的路径下。\nInfo\n如果你使用了其他的路径来安装 go，在之后的配置过程中记得要修改 GOROOT 变量修改为你所安装的路径。\n执行命令前请先切换工作目录，确保当前路径下有刚刚下载好的压缩包。\nWarning\n压缩包名 go1.17.linux-amd64.tar.gz 可能有所不同，这取决于你安装的 go 版本和操作系统及处理器架构。\n配置环境变量 成功解压后，如果你尝试直接在终端执行 go 指令，你会发现系统并没有识别到你刚安装的 go 二进制文件，这是因为我们还没有对 go 的环境变量进行配置。","title":"配置 go 开发环境"},{"content":"今天学校不知道哪搞了个平台，让我们去上面做模拟实验，我点开一看，好嘛，没啥用的机器人、电焊，继续看下去还有题目，又懒得上网查答案，但是学校给的通知里有一行话引起了我的注意:\n温馨提示:需要从实验空间进入实验,不可直接输入网址进入\n不可直接输入网址？我仔细看了下，发现实验空间的作用就是添加一个 token，如果直接进去就是游客，没有办法登录。\n这下就好办了啊，虽然是游客，但是游客也可以做题啊，我用游客帐号先做了不就拿到答案了吗？\n这个系统果然把正确答案显示在前端了，但是不太好看，于是我就跑去 F12 看了。\n结果我在后台找到了下面的代码:\n$.ajax({ url: \u0026#34;/webApi/experimen/rig/getData\u0026#34;, type: \u0026#34;GET\u0026#34;, data: { courseId: courseId }, dataType: \u0026#34;JSON\u0026#34;, success: function (res) { // 省略的大量代码逻辑 })； 下面的注释是原来就有，不是我加的。\n对，这个系统没有对 js 做混淆甚至在代码里有详细的注释。\n// 单选 var answer = $(\u0026#39;.afterTesting .topic1 form\u0026#39;); for (var k = 0; k \u0026lt; answer.length; k++) { var question1 = $(answer[k]).find(\u0026#34;.question1\u0026#34;); var questionAnswer = question1.attr(\u0026#34;data-answer\u0026#34;); var userAnswer = question1.find(\u0026#34;input[type=\u0026#39;radio\u0026#39;]:checked\u0026#34;).val(); var score = parseFloat(question1.attr(\u0026#34;data-score\u0026#34;)); if (questionAnswer.length \u0026gt; 1) { var userdAnswer = question1.find(\u0026#34;input[type=\u0026#39;checkbox\u0026#39;]:checked\u0026#34;); let userdAnswerStr = \u0026#39;\u0026#39;; for (let i = 0; i \u0026lt; userdAnswer.length; i++) { userdAnswerStr += $(userdAnswer[i]).val(); //console.log($(userdAnswer[i]).val()); } //console.log(userdAnswerStr); userAnswer = userdAnswerStr } var isok = \u0026#34;\u0026#34;; if (questionAnswer == userAnswer) { isok = \u0026#34;正确\u0026#34;; question1.find(\u0026#34;.countItem span\u0026#34;).html(score); resultafter += score } else { isok = \u0026#34;错误\u0026#34;; question1.find(\u0026#34;.countItem span\u0026#34;).html(\u0026#34;0\u0026#34;); } question1.find(\u0026#34;.yourAnswer span\u0026#34;).html(isok); } 好家伙，前端直接向后台发请求拿答案数据，然后判断对错？这就好比考试的时候老师把答案和试卷都给你，让你自己写完试卷自己评分。\n直接发一个请求过去，果然拿到答案了。\n数据示例:\n{ \u0026#34;id\u0026#34;: \u0026#34;570239720236388352\u0026#34;, \u0026#34;courseId\u0026#34;: null, \u0026#34;title\u0026#34;: \u0026#34;07、机器人的运动速度与摇杆的偏转量 （）\u0026#34;, \u0026#34;optionA\u0026#34;: \u0026#34;A、正比 \u0026#34;, \u0026#34;optionB\u0026#34;: \u0026#34;B、反比 \u0026#34;, \u0026#34;optionC\u0026#34;: \u0026#34;C、不成比例 \u0026#34;, \u0026#34;optionD\u0026#34;: \u0026#34;D、以上均不正确\u0026#34;, \u0026#34;optionE\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;optionF\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;optionG\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;optionH\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;answer\u0026#34;: \u0026#34;A\u0026#34;, \u0026#34;tag\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;analysis\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;remarks\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;score\u0026#34;: 3.0, \u0026#34;pid\u0026#34;: \u0026#34;550581359601651712_before\u0026#34;, \u0026#34;countOfRow\u0026#34;: null } ","permalink":"https://aimerneige.com/zh/post/others/complaints-about-stupid-lab-platform/","summary":"今天学校不知道哪搞了个平台，让我们去上面做模拟实验，我点开一看，好嘛，没啥用的机器人、电焊，继续看下去还有题目，又懒得上网查答案，但是学校给的通知里有一行话引起了我的注意:\n温馨提示:需要从实验空间进入实验,不可直接输入网址进入\n不可直接输入网址？我仔细看了下，发现实验空间的作用就是添加一个 token，如果直接进去就是游客，没有办法登录。\n这下就好办了啊，虽然是游客，但是游客也可以做题啊，我用游客帐号先做了不就拿到答案了吗？\n这个系统果然把正确答案显示在前端了，但是不太好看，于是我就跑去 F12 看了。\n结果我在后台找到了下面的代码:\n$.ajax({ url: \u0026#34;/webApi/experimen/rig/getData\u0026#34;, type: \u0026#34;GET\u0026#34;, data: { courseId: courseId }, dataType: \u0026#34;JSON\u0026#34;, success: function (res) { // 省略的大量代码逻辑 })； 下面的注释是原来就有，不是我加的。\n对，这个系统没有对 js 做混淆甚至在代码里有详细的注释。\n// 单选 var answer = $(\u0026#39;.afterTesting .topic1 form\u0026#39;); for (var k = 0; k \u0026lt; answer.length; k++) { var question1 = $(answer[k]).find(\u0026#34;.question1\u0026#34;); var questionAnswer = question1.attr(\u0026#34;data-answer\u0026#34;); var userAnswer = question1.find(\u0026#34;input[type=\u0026#39;radio\u0026#39;]:checked\u0026#34;).val(); var score = parseFloat(question1.attr(\u0026#34;data-score\u0026#34;)); if (questionAnswer.length \u0026gt; 1) { var userdAnswer = question1.","title":"对于某实验平台的吐槽"},{"content":" 平时在使用 Linux 写代码的时候，总有一点让我很难受，那就是当我准备写中文注释的时候，输入 // 的时候，输入法总是希望我手动选择是要输入 / 还是中文的 、，随之弹出来的框非常影响代码编辑，经常打断我的思路，类似的还有反引号等符号，不厌其烦的我去查找了一些资料，终于彻底解决了这个问题。\n准备 阅读本文前，你要保证你在使用 rime 输入法。遇到任何问题请多查阅 rime 提供的文档。\n本文所提到的内容在 fedora34 系统下，ibus-rime 包测试通过。\n找到 rime 用户资料夹 不同的平台下，rime 用户资料夹的位置会有所不同\n平台 rime 用户资料夹位置 ibus ~/.config/ibus/rime fcitx ~/.config/fcitx/rime fcitx5 ~/.local/share/fcitx5/rime 创建你的配置文件 如果你从来没有配置过 rime，那么你可以直接在 rime 用户资料夹下创建名为 default.custom.yaml 的配置文件，写入如下内容:\npatch: punctuator/full_shape: \u0026#34;`\u0026#34;: \u0026#34;｀\u0026#34; \u0026#34;~\u0026#34;: \u0026#34;～\u0026#34; \u0026#34;!\u0026#34;: \u0026#34;！\u0026#34; \u0026#34;@\u0026#34;: \u0026#34;＠\u0026#34; \u0026#34;#\u0026#34;: \u0026#34;＃\u0026#34; \u0026#34;$\u0026#34;: \u0026#34;￥\u0026#34; \u0026#34;%\u0026#34;: \u0026#34;％\u0026#34; \u0026#34;^\u0026#34;: \u0026#34;……\u0026#34; \u0026#34;\u0026amp;\u0026#34;: \u0026#34;＆\u0026#34; \u0026#34;*\u0026#34;: \u0026#34;×\u0026#34; \u0026#34;(\u0026#34;: \u0026#34;（\u0026#34; \u0026#34;)\u0026#34;: \u0026#34;）\u0026#34; \u0026#34;_\u0026#34;: \u0026#34;——\u0026#34; \u0026#34;+\u0026#34;: \u0026#34;＋\u0026#34; \u0026#34;-\u0026#34;: \u0026#34;－\u0026#34; \u0026#34;=\u0026#34;: \u0026#34;＝\u0026#34; \u0026#34;[\u0026#34;: \u0026#34;【\u0026#34; \u0026#34;]\u0026#34;: \u0026#34;】\u0026#34; \u0026#34;{\u0026#34;: \u0026#34;｛\u0026#34; \u0026#34;}\u0026#34;: \u0026#34;｝\u0026#34; \u0026#34;|\u0026#34;: \u0026#34;｜\u0026#34; \u0026#34;\\\\\u0026#34;: \u0026#34;、\u0026#34; \u0026#34;/\u0026#34;: \u0026#34;、\u0026#34; \u0026#34;;\u0026#34;: \u0026#34;；\u0026#34; \u0026#34;\u0026#39;\u0026#34;: \u0026#34;‘\u0026#34; \u0026#34;,\u0026#34;: \u0026#34;，\u0026#34; \u0026#34;.\u0026#34;: \u0026#34;。\u0026#34; \u0026#34;\u0026lt;\u0026#34;: \u0026#34;《\u0026#34; \u0026#34;\u0026gt;\u0026#34;: \u0026#34;》\u0026#34; \u0026#34;?\u0026#34;: \u0026#34;？\u0026#34; punctuator/half_shape: \u0026#34;`\u0026#34;: \u0026#34;`\u0026#34; \u0026#34;~\u0026#34;: \u0026#34;~\u0026#34; \u0026#34;!\u0026#34;: \u0026#34;！\u0026#34; \u0026#34;@\u0026#34;: \u0026#34;@\u0026#34; \u0026#34;#\u0026#34;: \u0026#34;#\u0026#34; \u0026#34;$\u0026#34;: \u0026#34;￥\u0026#34; \u0026#34;%\u0026#34;: \u0026#34;%\u0026#34; \u0026#34;^\u0026#34;: \u0026#34;……\u0026#34; \u0026#34;\u0026amp;\u0026#34;: \u0026#34;\u0026amp;\u0026#34; \u0026#34;*\u0026#34;: \u0026#34;×\u0026#34; \u0026#34;(\u0026#34;: \u0026#34;（\u0026#34; \u0026#34;)\u0026#34;: \u0026#34;）\u0026#34; \u0026#34;_\u0026#34;: \u0026#34;——\u0026#34; \u0026#34;+\u0026#34;: \u0026#34;+\u0026#34; \u0026#34;-\u0026#34;: \u0026#34;-\u0026#34; \u0026#34;=\u0026#34;: \u0026#34;=\u0026#34; \u0026#34;[\u0026#34;: \u0026#34;【\u0026#34; \u0026#34;]\u0026#34;: \u0026#34;】\u0026#34; \u0026#34;{\u0026#34;: \u0026#34;｛\u0026#34; \u0026#34;}\u0026#34;: \u0026#34;｝\u0026#34; \u0026#34;|\u0026#34;: \u0026#34;｜\u0026#34; \u0026#34;\\\\\u0026#34;: \u0026#34;、\u0026#34; \u0026#34;/\u0026#34;: \u0026#34;/\u0026#34; \u0026#34;;\u0026#34;: \u0026#34;；\u0026#34; \u0026#34;\u0026#39;\u0026#34;: \u0026#34;’\u0026#34; \u0026#34;,\u0026#34;: \u0026#34;，\u0026#34; \u0026#34;.\u0026#34;: \u0026#34;。\u0026#34; \u0026#34;\u0026lt;\u0026#34;: \u0026#34;《\u0026#34; \u0026#34;\u0026gt;\u0026#34;: \u0026#34;》\u0026#34; \u0026#34;?\u0026#34;: \u0026#34;？\u0026#34; 以上配置的具体细节请查阅文档。\n应用配置 保存好你的配置文件之后，切换输入法到 rime，在托盘右击你的输入法（fedora 下左键单击也是一样的效果）选择 部署 ，稍等片刻，等待 rime 部署你的配置文件后，如果没有错误警告，那么恭喜你应用成功。之后在中文半角状态下输入 / 时会直接输入 / 而没有烦人的二级窗口提示你选择要输入的内容，可以愉快的写中文注释了。\n其他配置 除了上面提到的内容，还可以修改其他配置，具体可以查看官方文档，这里额外介绍几个常用的配置：\n候选词 水平/垂直 切换 在 rime 用户资料夹下 build/ibus_rime.yaml 这个文件中写入如下内容：\nstyle: horizontal: true 候选词数量设置 在 rime 用户资料夹下 default.custom.yaml 这个文件中写入如下内容：\npatch: menu/page_size: 7 Info\n数值范围为 1 ~ 9\n实用插件 如果你正在使用 Gnome，又懒得修改配置文件，请一定要尝试一下 IBus Tweaker 这个插件。\nNote\n你必须先安装 Extensions 才可以在 Gnome 下使用这个插件。\n参考链接 Rime Rime 定製指南 鼠须管输入法配置 ","permalink":"https://aimerneige.com/zh/post/linux/diy-your-rime-for-better-coding/","summary":"平时在使用 Linux 写代码的时候，总有一点让我很难受，那就是当我准备写中文注释的时候，输入 // 的时候，输入法总是希望我手动选择是要输入 / 还是中文的 、，随之弹出来的框非常影响代码编辑，经常打断我的思路，类似的还有反引号等符号，不厌其烦的我去查找了一些资料，终于彻底解决了这个问题。\n准备 阅读本文前，你要保证你在使用 rime 输入法。遇到任何问题请多查阅 rime 提供的文档。\n本文所提到的内容在 fedora34 系统下，ibus-rime 包测试通过。\n找到 rime 用户资料夹 不同的平台下，rime 用户资料夹的位置会有所不同\n平台 rime 用户资料夹位置 ibus ~/.config/ibus/rime fcitx ~/.config/fcitx/rime fcitx5 ~/.local/share/fcitx5/rime 创建你的配置文件 如果你从来没有配置过 rime，那么你可以直接在 rime 用户资料夹下创建名为 default.custom.yaml 的配置文件，写入如下内容:\npatch: punctuator/full_shape: \u0026#34;`\u0026#34;: \u0026#34;｀\u0026#34; \u0026#34;~\u0026#34;: \u0026#34;～\u0026#34; \u0026#34;!\u0026#34;: \u0026#34;！\u0026#34; \u0026#34;@\u0026#34;: \u0026#34;＠\u0026#34; \u0026#34;#\u0026#34;: \u0026#34;＃\u0026#34; \u0026#34;$\u0026#34;: \u0026#34;￥\u0026#34; \u0026#34;%\u0026#34;: \u0026#34;％\u0026#34; \u0026#34;^\u0026#34;: \u0026#34;……\u0026#34; \u0026#34;\u0026amp;\u0026#34;: \u0026#34;＆\u0026#34; \u0026#34;*\u0026#34;: \u0026#34;×\u0026#34; \u0026#34;(\u0026#34;: \u0026#34;（\u0026#34; \u0026#34;)\u0026#34;: \u0026#34;）\u0026#34; \u0026#34;_\u0026#34;: \u0026#34;——\u0026#34; \u0026#34;+\u0026#34;: \u0026#34;＋\u0026#34; \u0026#34;-\u0026#34;: \u0026#34;－\u0026#34; \u0026#34;=\u0026#34;: \u0026#34;＝\u0026#34; \u0026#34;[\u0026#34;: \u0026#34;【\u0026#34; \u0026#34;]\u0026#34;: \u0026#34;】\u0026#34; \u0026#34;{\u0026#34;: \u0026#34;｛\u0026#34; \u0026#34;}\u0026#34;: \u0026#34;｝\u0026#34; \u0026#34;|\u0026#34;: \u0026#34;｜\u0026#34; \u0026#34;\\\\\u0026#34;: \u0026#34;、\u0026#34; \u0026#34;/\u0026#34;: \u0026#34;、\u0026#34; \u0026#34;;\u0026#34;: \u0026#34;；\u0026#34; \u0026#34;\u0026#39;\u0026#34;: \u0026#34;‘\u0026#34; \u0026#34;,\u0026#34;: \u0026#34;，\u0026#34; \u0026#34;.","title":"定制你的 rime 提升编程体验"},{"content":"前言 距离上一次写博客文章已经很长时间了，因为经常重装系统，而每次在电脑上安装和配置 hexo 的博客都是一件比较麻烦的事情，于是就一直咕了。但是最近我发现了 hugo 这一简洁好用的博客系统，可以让我远离配置安装都又慢又麻烦的 hexo，使用下来体验很棒，而我恰好又打算换一个博客主题，于是决定使用 hugo 来搭建我的新博客。本文简要介绍如何安装和使用 hugo。\n安装 你可能需要 go 的开发环境 git 一个顺手的编辑器 你一定不需要 nodejs npm 安装 hugo 要安装 hugo 非常简单，以 fedora 系统为例，只需要执行如下指令：\nsudo dnf install hugo 创建站点文件夹 使用以下指令创建你的站点文件夹：\nhugo new site blog 切换到工作目录进行后续操作：\ncd blog 使用 git 进行版本控制：\ngit init 安装主题 挑选好合适的主题后，将其直接 clone 在 ./themes 文件夹下即可。\ngit clone https://github.com/adityatelange/hugo-PaperMod themes/PaperMod --depth=1 使用 --depth=1 参数会忽略历史 commit 记录。\n当然，下载解压压缩包的方式也是可以的。\n如果想要方便版本控制和更新，使用如下指令添加 submodule：\ngit submodule add https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod 当重新 clone 仓库后，执行如下指令 clone 主题子仓库：\ngit submodule update --init --recursive 更新主题：\ngit submodule update --remote --merge 配置 hugo 支持多种配置文件格式，由于 yaml 格式的配置文件更易读，下文将默认使用 yaml 配置。\n与 hexo 不同，hugo 的配置文件只有一个，按照你所使用的主题提供的文档来修改你的配置文件即可。\n应用主题 theme: \u0026#34;PaperMod\u0026#34; 修改主题配置 不同的主题会有不同的配置方法，具体查看主题提供的文档。\n请参考如下配置：\nbaseURL: \u0026#34;https://aimerneige.com/\u0026#34; languageCode: \u0026#34;en-us\u0026#34; title: \u0026#34;AimerNeige\u0026#39;s Blog\u0026#34; theme: \u0026#34;PaperMod\u0026#34; enableRobotsTXT: true buildDrafts: false buildFuture: false buildExpired: false defaultContentLanguage: en defaultContentLanguageInSubdir: true languages: en: languageName: \u0026#34;English\u0026#34; weight: 1 menu: main: - name: About url: about/ weight: 5 - name: Friends url: friends/ weight: 6 - name: Post url: post/ weight: 7 - name: Archive url: archives/ weight: 8 - name: Tags url: tags/ weight: 9 - name: Categories url: categories/ weight: 10 - name: Search url: search/ weight: 11 zh: languageName: \u0026#34;中文\u0026#34; weight: 2 menu: main: - name: 关于 url: about/ weight: 5 - name: 朋友 url: friends/ weight: 6 - name: 文章 url: post/ weight: 7 - name: 归档 url: archives/ weight: 8 - name: 标签 url: tags/ weight: 9 - name: 分类 url: categories/ weight: 10 - name: 搜索 url: search/ weight: 11 params: profileMode: enabled: true title: \u0026#34;Aimer Neige\u0026#34; subtitle: \u0026#34;技术宅拯救世界\u0026#34; imageUrl: \u0026#34;https://avatars.githubusercontent.com/u/51701792?v=4\u0026#34; imageTitle: \u0026#34;avatar.jpeg\u0026#34; imageWidth: 140 imageHeight: 140 params: env: production keywords: [Blog, OpenSource, Coding, Golang, Programming] author: \u0026#34;Aimer Neige\u0026#34; defaultTheme: auto disableThemeToggle: false ShowToc: true TocOpen: false ShowBreadCrumbs: true ShowReadingTime: false ShowPostNavLinks: true ShowShareButtons: false ShowCodeCopyButtons: true displayFullLangName: true editPost: URL: \u0026#34;https://github.com/aimerneige/blog/content\u0026#34; Text: \u0026#34;Suggest Changes\u0026#34; appendFilePath: true homeInfoParams: Title: \u0026#34;Aimer Neige\u0026#34; Content: \u0026#34;Tech Otakus Save The World\u0026#34; profileMode: enabled: true title: \u0026#34;Aimer Neige\u0026#34; subtitle: \u0026#34;Tech Otakus Save The World\u0026#34; imageUrl: \u0026#34;https://avatars.githubusercontent.com/u/51701792?v=4\u0026#34; imageTitle: \u0026#34;avatar.jpeg\u0026#34; imageWidth: 140 imageHeight: 140 socialIcons: - name: github url: \u0026#34;https://github.com/AimerNeige\u0026#34; - name: twitter url: \u0026#34;https://twitter.com/NeigeAimer\u0026#34; - name: steam url: \u0026#34;https://steamcommunity.com/id/AimerNeige\u0026#34; - name: Telegram url: \u0026#34;https://t.me/AimerNeige\u0026#34; - name: KoFi url: \u0026#34;https://ko-fi.com/aimerneige\u0026#34; - name: RsS url: \u0026#34;index.xml\u0026#34; taxonomies: category: categories tag: tags series: series outputs: home: - HTML - RSS - JSON 迁移 将原有文章复制到站点文件夹下，修改配置。\n测试 使用如下指令启动本地测试服务。\nhugo serve -D 部署 使用如下指令生成静态文件：\nhugo 之后上传到 github 即可：\ncd public git add -A git commit -m \u0026#34;commit message\u0026#34; git push ","permalink":"https://aimerneige.com/zh/post/others/hello-hugo/","summary":"前言 距离上一次写博客文章已经很长时间了，因为经常重装系统，而每次在电脑上安装和配置 hexo 的博客都是一件比较麻烦的事情，于是就一直咕了。但是最近我发现了 hugo 这一简洁好用的博客系统，可以让我远离配置安装都又慢又麻烦的 hexo，使用下来体验很棒，而我恰好又打算换一个博客主题，于是决定使用 hugo 来搭建我的新博客。本文简要介绍如何安装和使用 hugo。\n安装 你可能需要 go 的开发环境 git 一个顺手的编辑器 你一定不需要 nodejs npm 安装 hugo 要安装 hugo 非常简单，以 fedora 系统为例，只需要执行如下指令：\nsudo dnf install hugo 创建站点文件夹 使用以下指令创建你的站点文件夹：\nhugo new site blog 切换到工作目录进行后续操作：\ncd blog 使用 git 进行版本控制：\ngit init 安装主题 挑选好合适的主题后，将其直接 clone 在 ./themes 文件夹下即可。\ngit clone https://github.com/adityatelange/hugo-PaperMod themes/PaperMod --depth=1 使用 --depth=1 参数会忽略历史 commit 记录。\n当然，下载解压压缩包的方式也是可以的。\n如果想要方便版本控制和更新，使用如下指令添加 submodule：\ngit submodule add https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod 当重新 clone 仓库后，执行如下指令 clone 主题子仓库：","title":"Hello Hugo"},{"content":"前言 之前在学习安卓的时候，很想要给自己的软件增加一个云服务功能，但是苦于没有学过后端，于是开始在互联网上查找资料。但是遗憾的是，后端是一个很大的范围，我查找了很多后端的资料也几乎都是在讲解如何写网页，并没有专门用来给安卓写后端的教程，在广泛地学习了大量后端内容后，成功的为自己的程序开发了一个简单的 API。希望这篇文章能够帮到那些没有系统地学习过后端，但是却想要快速开发一款能用的 API 的安卓开发者。\n前期准备 你要了解互联网通讯原理 你要会一些基础的 JavaScript 你要有一台服务器 你会数据库操作 最好有一个域名（非必须） 掌握基础的终端操作 环境配置 本文章中后端开发使用的开发语言为 JavaScript 配合 nodejs。数据库采用常用的 mysql。\n注： nodejs 开发常用的数据库是 mongodb，但是由于 mysql 比较常用这里就用 mysql 了，当然其他数据库也是可以的，你可以查找一下 nodejs 如何链接这些数据库，并将本文中 mysql 操作的部分替换掉就可以了。\n本地测试客户端安装 你需要在自己用来开发的电脑上安装配置如下环境：\nnodejs npm 安装 nodejs Linux 下直接使用包管理安装即可。如果包管理安装的 node 很旧，可以自行谷歌一下安装方法，这里不再赘述。\n以 Ubuntu 为例，直接在终端执行如下指令：\nsudo apt install nodejs 安装完成后使用 node -v 查看 node 版本来确认安装是否成功。\n如果是 windows 用户就更加简单了，直接在 nodejs 官网 下载安装包运行即可。推荐使用长周期稳定版本。如果你想体验新特性，也可以考虑使用最新的版本。\n安装 npm 通常情况下，安装 nodejs 时会附带安装 npm，你可以直接使用 npm -v 来查看当前系统安装的 npm 版本来检测安装情况。\n如果没有安装，以 Ubuntu 系统为例，可以在终端执行下面的指令：\nsudo apt install npm windows 用户在执行完 node 的安装程序后 npm 会自动安装完成。\n服务器安装 你需要在服务器上安装配置如下环境：\nnodejs npm mysql nginx 安装 nodejs 与 npm 其中 nodejs 和 npm 的安装同客户端完全相同，这里不再赘述。\n安装 mysql mysql 可以一并安装在运行 node 项目的服务器上，也可以使用独立的数据库提供服务器。\n本文章主要讨论如何构建 API ，这里不再赘述如何安装配置 mysql。可以查看我的其他文章。\n安装 nginx nginx 用于将服务反向代理到 80 端口，以 Ubuntu 系统为例，直接在终端执行如下指令：\nsudo apt install nginx Windows 用户自行查阅相关资料。不会吧，不会吧，不会有人服务器用 windows 吧？？\n项目构建 使用模版 为了方便快速构建一个项目，我写了一个模版，你可以在 GitHub 上找到它。\n使用这个模版快速构建一个新的仓库，将它 clone 到本地，并进行下面的修改：\n修改 package.json 修改 LICENSE 修改 README 在 src/config 下新建 db.js 写入数据库服务器的配置。 安装依赖 在项目路径下启动终端，执行如下指令：\nnpm i 这个指令是 npm install 的缩写，npm 会安装需要的依赖，本模版项目只依赖了俩个包：\nexpress mysql 依赖安装完成后，你会在项目路径下看到 node_modules 这个文件夹，它已经被写在 .gitignore 中，这个文件夹下是项目所需要的依赖，即使你意外地删掉了这个文件夹，再次执行 npm i 就可以将这些文件下载回来，所以你不应该在意这个文件夹中有什么内容，npm 会帮我们处理它。\n启动项目 使用 cd 命令切换到 src 目录下，执行下面的指令：\nnode app.js 之后你会在终端看到如下输出：\nServer start in development mode on http://localhost:4000; press Ctrl + C to terminated. 打开你的浏览器访问 http://localhost:4000/\n如果你看到下面的内容，说明项目成功启动了：\n{ \u0026#34;status\u0026#34;: 200, \u0026#34;info\u0026#34;: \u0026#34;If you see this, the server deploy success!\u0026#34; } 如果你在服务器启动项目，假设你的服务器 ip 为 43.192.82.215 并且配置了域名 api.aimerneige.com ，你可以通过在浏览器内访问下面的地址测试服务器：\nhttp://43.192.82.215:4000/ http://api.aimerneige.com:4000/ 注意：\n在本地测试启动的服务器只能通过 本地/内网 访问 在有公网 ip 的服务器上部署的服务可以在 任意浏览器内 打开 如果你在服务器测试，请注意以这样的方式运行仅能用来测试，不可以用作生产环境，后文会介绍如何在服务器部署项目。\n程序入口 项目可以启动后，说明环境配置无误，接下来可以开始写代码了。\n我们简单看一下程序的入口 app.js\n本项目依赖 express 构建，首先导入 express 的模块：\n// require const express = require(\u0026#34;express\u0026#34;); 接下来导入路由目录下的路由模块：\n// user require const indexRouter = require(\u0026#34;./routes/index\u0026#34;); 创建 express 对象：\n// express app var app = express(); 设置监听端口：\n// set port app.set(\u0026#34;port\u0026#34;, process.env.PORT || 4000); 添加可以支持 json 解析的中间件：\n// json parse app.use(express.json()); app.use(express.urlencoded({ extended: false })); 添加路由中间件：\n// routes app.use(\u0026#34;/\u0026#34;, indexRouter); 路由匹配失败后返回 404 错误：\n// catch 404 and forward to error handler app.use(function (req, res, next) { var err = new Error(\u0026#34;Not Found\u0026#34;); err.status = 404; next(err); }); 处理错误信息：\n// error handler app.use(function (err, req, res, next) { res.type(\u0026#34;application/json\u0026#34;); res.status(err.status || 500); res.send({ status: err.status || 500, message: err.message, }); }); 检测当前模块是否被直接执行，如果是则启动服务器，否者导出模块：\n// check if run app.js directly if (require.main === module) { app.listen(app.get(\u0026#34;port\u0026#34;), function () { console.log( \u0026#34;Server start in \u0026#34; + app.get(\u0026#34;env\u0026#34;) + \u0026#34; mode on http://localhost:\u0026#34; + app.get(\u0026#34;port\u0026#34;) + \u0026#34;; press Ctrl + C to terminated.\u0026#34; ); }); } else { module.exports = app; } 其他的代码可以暂时不去理会，最重要的是路由这一部分：\n// 导入路由模块 const indexRouter = require(\u0026#34;./routes/index\u0026#34;); // 添加路由中间件 app.use(\u0026#34;/\u0026#34;, indexRouter); 在编写 api 时，只需要在 /src/routes 目录下新建路由模块，并在 app.js 下引用即可。\n添加路由 接下来我们看一下默认的路由模块 index.js ：\n导入 express 模块：\nconst express = require(\u0026#34;express\u0026#34;); const router = express.Router(); 配置路由规则：\nrouter.get(\u0026#34;/\u0026#34;, function (req, res, next) { res.type(\u0026#34;application/json\u0026#34;); res.status(200); res.send({ status: 200, info: \u0026#34;If you see this, the server deploy success!\u0026#34;, }); }); 导出模块：\nmodule.exports = router; 其中重点即配置路由规则这一部分。\n我相信这几行代码还是很易懂的，相对地，如果我们想要使用 post 方法，访问路径为 /about 需要这样写：\nrouter.post(\u0026#34;/about\u0026#34;, fuction(){ /* function */ } ); 设置好请求方法和请求路径后，回调函数用来向客户端返回数据。\n设置返回数据类型，这里使用 json 进行数据传输：\nres.type(\u0026#34;application/json\u0026#34;); 设置返回状态码：\nres.status(200); 返回指定数据：\nres.send(return_data); 由于开发语言为 js ，而且本项目添加了解析 json 的中间件，如果想要返回 json，不需像其他语言那样要将对象解析为 json 字符串，直接返回一个对象即可，客户端会成功接收到正确的 json 字符串。\n// 服务器返回的对象 { status: 200, info: \u0026#34;If you see this, the server deploy success!\u0026#34;, } // 客户端拿到的字符串 { \u0026#34;status\u0026#34;: 200, \u0026#34;info\u0026#34;: \u0026#34;If you see this, the server deploy success!\u0026#34; } 书写好路由模块后在 app.js 中引用即可：\n// 导入模块 const indexRouter = require(\u0026#34;./routes/index\u0026#34;); // ... 中间的其他代码 // 在 app 中应用路由模块 app.use(\u0026#34;/\u0026#34;, indexRouter); 要注意模块导入的位置，不能乱放。和模版保持一致即可。\n添加更多的路由信息 就像上面的例子中所写的，我们可以继续添加新的路由模块，也可以在同一个路由模块下添加更多的访问路径。\nsrc/app.js // ... const indexRouter = require(\u0026#34;./routes/index\u0026#34;); const userRouter = require(\u0026#34;./routes/user\u0026#34;); // ... app.use(\u0026#34;/\u0026#34;, indexRouter); app.use(\u0026#34;/user\u0026#34;, userRouter); src/routes/index.js // ... // 访问路径 / router.get(\u0026#34;/\u0026#34;, fuction(){ /* function */ } ); // 访问路径 /about router.get(\u0026#34;/about\u0026#34;, function() { /* function */ }); // ... src/routes/user.js // ... // 访问路径 /user/cat router.get(\u0026#34;/cat\u0026#34;, fuction(){ /* function */ } ); // 访问路径 /user/edit router.post(\u0026#34;/edit\u0026#34;, fuction(){ /* function */ } ); // 访问路径 /user/new router.psot(\u0026#34;/new\u0026#34;, fuction(){ /* function */ } ); // ... 获取客户端数据 获取请求参数信息 req.query 对象是由客户端请求参数构成的，在回调函数内，可以直接调用它来获取客户端请求参数，如果客户端传递了参数，我们就可以拿到对应的数据，否者我们只能得到 undefined。由此可以通过判空来确定客户端请求参数是否正确。\n例如我们的请求路径为 /data 所需请求参数为 id 和 class 可以这样写：\n注： 对应的示例请求地址为 https://api.example.com/data?id=1930201\u0026amp;class=302\nrouter.get(\u0026#34;/data\u0026#34;, function (req, res) { res.type(\u0026#34;application/json\u0026#34;); if (req.query.class === undefined || req.query.id === undefined) { res.status(400); // 向客户端返回错误信息，提示客户端返回正确的参数 res.send({ status: 400, info: \u0026#34;Wrong arguments!\u0026#34;, }); } else { // 向用户返回数据（通常会用客户端参数来调用数据库，为了简便这里返回一个类做简单示范） res.status(200); res.send({ status: 200, info: { class: req.query.class, id: req.query.id, }, }); } }); 我们可以通过判空来确定客户端请求参数是否正确，之后可以使用参数来进行其他操作，比如构建类，调取数据库等等。\n获取请求体信息 与请求参数类似，请求体信息也保存在一个类中，就是 req.body。使用方法和之前请求参数完全一致，这里只写一个示例，不多赘述。\nrouter.post(\u0026#34;/new\u0026#34;, function (req, res) { res.type(\u0026#34;application/json\u0026#34;); if (req.body.class === undefined || req.body.id === undefined) { res.status(400); // 向客户端返回错误信息，提示客户端返回正确的参数 res.send({ status: 400, info: \u0026#34;Wrong arguments!\u0026#34;, }); } else { var new_student = { class: req.body.class, id: req.body.id, }; // 向数据库内添加新的学生 res.status(200); res.send({ status: 200, info: \u0026#34;Student create successful!\u0026#34;, }); } }); 获取更多信息 在回调函数中，req 对象中保存了所有来自客户请求的数据，前面介绍的只是比较常用的，其他内容可以查找文档。\n获取数据库信息 配置数据库信息 参考 db.js.example 创建 db.js 写入服务器的配置\nvar mysql = require(\u0026#34;mysql\u0026#34;); var pool = mysql.createPool({ host: \u0026#34;host_ip\u0026#34;, user: \u0026#34;user_name\u0026#34;, password: \u0026#34;password\u0026#34;, database: \u0026#34;data\u0026#34;, port: 3306, }); function query(sql, callback) { pool.getConnection(function (err, connection) { connection.query(sql, function (err, rows) { callback(err, rows); connection.release(); }); }); } exports.query = query; 配置好数据库服务器后，就可以通过下面的方法访问数据库的数据了：\nsql_command = \u0026#34;DROP DATABASE *;\u0026#34;; // ⚠️ 注意修改 db.query(sql_command, function (err, result, fields) { if (err) { // 如果数据库指令执行出现了错误，返回错误信息 requestSQLFailedLog(sql_command, err); res.status(400); res.send({ status: 400, info: err }); } else { // 如果数据库指令执行成功，返回数据 requestSQLSuccessLog(sql_command, result); res.status(200); res.send(result); } }); 服务部署 待完善，咕咕咕\n将项目上传到服务器 修改 db.js 的配置 cd src node cluster.js 如果你想要后台运行，执行 nohup node cluster.js \u0026amp; ","permalink":"https://aimerneige.com/zh/post/javascript/build-api-with-nodejs-quickly/","summary":"前言 之前在学习安卓的时候，很想要给自己的软件增加一个云服务功能，但是苦于没有学过后端，于是开始在互联网上查找资料。但是遗憾的是，后端是一个很大的范围，我查找了很多后端的资料也几乎都是在讲解如何写网页，并没有专门用来给安卓写后端的教程，在广泛地学习了大量后端内容后，成功的为自己的程序开发了一个简单的 API。希望这篇文章能够帮到那些没有系统地学习过后端，但是却想要快速开发一款能用的 API 的安卓开发者。\n前期准备 你要了解互联网通讯原理 你要会一些基础的 JavaScript 你要有一台服务器 你会数据库操作 最好有一个域名（非必须） 掌握基础的终端操作 环境配置 本文章中后端开发使用的开发语言为 JavaScript 配合 nodejs。数据库采用常用的 mysql。\n注： nodejs 开发常用的数据库是 mongodb，但是由于 mysql 比较常用这里就用 mysql 了，当然其他数据库也是可以的，你可以查找一下 nodejs 如何链接这些数据库，并将本文中 mysql 操作的部分替换掉就可以了。\n本地测试客户端安装 你需要在自己用来开发的电脑上安装配置如下环境：\nnodejs npm 安装 nodejs Linux 下直接使用包管理安装即可。如果包管理安装的 node 很旧，可以自行谷歌一下安装方法，这里不再赘述。\n以 Ubuntu 为例，直接在终端执行如下指令：\nsudo apt install nodejs 安装完成后使用 node -v 查看 node 版本来确认安装是否成功。\n如果是 windows 用户就更加简单了，直接在 nodejs 官网 下载安装包运行即可。推荐使用长周期稳定版本。如果你想体验新特性，也可以考虑使用最新的版本。\n安装 npm 通常情况下，安装 nodejs 时会附带安装 npm，你可以直接使用 npm -v 来查看当前系统安装的 npm 版本来检测安装情况。","title":"使用 nodejs 快速为 Android 程序构建 API"},{"content":"在多人协作的项目中，为了同一代码格式，可以使用 editorconfig 来定义，这样不仅可以帮助协作者快速了解当前项目要求的代码风格，也可以方便使用一些格式化工具保证代码风格按照预期格式化。\n快速了解 What is EditorConfig? EditorConfig helps maintain consistent coding styles for multiple developers working on the same project across various editors and IDEs. The EditorConfig project consists of a file format for defining coding styles and a collection of text editor plugins that enable editors to read the file format and adhere to defined styles. EditorConfig files are easily readable and they work nicely with version control systems. Source: https://editorconfig.org/\n简单示例 示例来自 https://editorconfig.org/\n# EditorConfig is awesome: https://EditorConfig.org # top-most EditorConfig file root = true # Unix-style newlines with a newline ending every file [*] end_of_line = lf insert_final_newline = true # Matches multiple files with brace expansion notation # Set default charset [*.{js,py}] charset = utf-8 # 4 space indentation [*.py] indent_style = space indent_size = 4 # Tab indentation (no size specified) [Makefile] indent_style = tab # Indentation override for all JS under lib directory [lib/**.js] indent_style = space indent_size = 2 # Matches the exact files either package.json or .travis.yml [{package.json,.travis.yml}] indent_style = space indent_size = 2 使用方法 直接在项目目录下新建文件 .editorconfig 写入配置，安装对应插件后即可，保存文件时会按照配置文件自动格式化。\n额外地，如果你在 Windows 下如果使用 Windows Explorer 新建 .editorconfig 文件，需要将文件名写为 .editorconfig.，Windows 会自动重命名为 .editorconfig。\n特殊符号的含义 符号 含义 * 匹配任何字符串，除了路径分割符 (/) ** 匹配任何字符串 ? 匹配任何单字符 [name] 匹配 name 中所包含的任一字符 [!name] 匹配不包含在 name 中的任一字符 {s1,s2,s3} 匹配任何给定单字符串 (用逗号分割) (在 EditorConfig Core 0.11.0 后受支持) {num1..num2} 匹配任何在 num1 和 num2 之间的数字，num1 和 num2 可以是正数也可以是负数 支持的配置属性 indent_style 缩进样式 {tab, space} indent_size 每次缩进相当于多少列 {2,4,8\u0026hellip;} (当 indent_style 设置为 space 时使用) tab_width 每次缩进相当于多少列 {2,4,8\u0026hellip;} (当 indent_style 设置为 tab 时使用) end_of_line 换行 {lf, cr, crlf} charset 编码 {latin1, utf-16be, utf-16le, utf-8, utf-8-bom, unset} trim_trailing_whitespace {true, false} 是否删掉结尾的空白字符 insert_final_newline {true, false} 是否在结尾插入新行 root {true, false} 是否顶级配置文件 ","permalink":"https://aimerneige.com/zh/post/tool/editorconfig/","summary":"在多人协作的项目中，为了同一代码格式，可以使用 editorconfig 来定义，这样不仅可以帮助协作者快速了解当前项目要求的代码风格，也可以方便使用一些格式化工具保证代码风格按照预期格式化。\n快速了解 What is EditorConfig? EditorConfig helps maintain consistent coding styles for multiple developers working on the same project across various editors and IDEs. The EditorConfig project consists of a file format for defining coding styles and a collection of text editor plugins that enable editors to read the file format and adhere to defined styles. EditorConfig files are easily readable and they work nicely with version control systems.","title":"利用 EditorConfig 定义代码格式，统一代码风格"},{"content":"前言 Linux 下中文输入法一直是硬伤，各种方面都没有 windows 或 mac 下好用，最近在逛 github 的时候偶然翻到一个仓库 四叶草拼音输入方案，这个仓库提供的输入方案用起来十分舒服，但是在安装的时候也遇到一些坑，于是写了这篇文章来记录。\n测试环境：\n.............. aimerneige@an ..,;:ccc,. ------------- ......\u0026#39;\u0026#39;\u0026#39;;lxO. OS: Kali GNU/Linux Rolling x86_64 .....\u0026#39;\u0026#39;\u0026#39;\u0026#39;..........,:ld; Host: TM1701 .\u0026#39;;;;:::;,,.x, Kernel: 5.9.0-kali4-amd64 ..\u0026#39;\u0026#39;\u0026#39;. 0Xxoc:,. ... Uptime: 2 hours, 11 mins .... ,ONkc;,;cokOdc\u0026#39;,. Packages: 3537 (dpkg) . OMo \u0026#39;:ddo. Shell: zsh 5.8 dMc :OO; Resolution: 1920x1080, 1440x2560 0M. .:o. DE: GNOME 3.38.2 ;Wd WM: Mutter ;XO, WM Theme: Kali-Dark ,d0Odlc;,.. Theme: Kali-Dark [GTK2/3] ..\u0026#39;,;:cdOOd::,. Icons: Flat-Remix-Blue-Dark [GTK2/\u0026gt; 3] .:d;.\u0026#39;:;. Terminal: gnome-terminal \u0026#39;d, .\u0026#39; CPU: Intel i7-8550U (8) @ 4.000GHz ;l .. GPU: NVIDIA GeForce MX250 .o GPU: Intel UHD Graphics 620 c Memory: 3698MiB / 15899MiB .\u0026#39; . 安装 fcitx5 sudo apt install fcitx5 启用 fcitx5 im-config 在开启的图形化界面中启用 fcitx5\n配置 fcitx5 编辑文件 ~/.xprofile 写入如下内容：\nexport GTK_IM_MODULE=fcitx5 export QT_IM_MODULE=fcitx5 export XMODIFIERS=\u0026#34;@im=fcitx5\u0026#34; export LANG=\u0026#34;zh_CN.UTF-8\u0026#34; export LC_CTYPE=\u0026#34;zh_CN.UTF-8\u0026#34; 编辑完成后注销账户，重新启动桌面\n安装 rime sudo apt install fcitx5-rime 启用 rime 在托盘处点击配置，并添加 rime。\n如果你的系统和我一样是英文，取消勾选“Only Show Current Language”即可查看中文选项\n更快地，你可以直接在上面的搜索框搜索 Rime\n安装输入方案 安装 四叶草拼音输入方案 提供的输入方案\n具体安装方法查看 项目 wiki\n更换简体中文 按下 Ctrl + ` 将输入模式切换为简体中文\n你也可以按照自己的喜好更改全角/半角的设置\n后记 如果你在安装中遇到任何问题，请查阅 fcitx rime 四叶草拼音输入方案 提供的文档。\n或是在 Arch Wiki 上查阅相关内容。\n","permalink":"https://aimerneige.com/zh/post/linux/install-fcitx5-with-rime-on-linux/","summary":"前言 Linux 下中文输入法一直是硬伤，各种方面都没有 windows 或 mac 下好用，最近在逛 github 的时候偶然翻到一个仓库 四叶草拼音输入方案，这个仓库提供的输入方案用起来十分舒服，但是在安装的时候也遇到一些坑，于是写了这篇文章来记录。\n测试环境：\n.............. aimerneige@an ..,;:ccc,. ------------- ......\u0026#39;\u0026#39;\u0026#39;;lxO. OS: Kali GNU/Linux Rolling x86_64 .....\u0026#39;\u0026#39;\u0026#39;\u0026#39;..........,:ld; Host: TM1701 .\u0026#39;;;;:::;,,.x, Kernel: 5.9.0-kali4-amd64 ..\u0026#39;\u0026#39;\u0026#39;. 0Xxoc:,. ... Uptime: 2 hours, 11 mins .... ,ONkc;,;cokOdc\u0026#39;,. Packages: 3537 (dpkg) . OMo \u0026#39;:ddo. Shell: zsh 5.8 dMc :OO; Resolution: 1920x1080, 1440x2560 0M. .:o. DE: GNOME 3.38.2 ;Wd WM: Mutter ;XO, WM Theme: Kali-Dark ,d0Odlc;,.. Theme: Kali-Dark [GTK2/3] ..\u0026#39;,;:cdOOd::,. Icons: Flat-Remix-Blue-Dark [GTK2/\u0026gt; 3] .","title":"Linux 下安装 fcitx5 与 Rime"},{"content":"ifconfig ➜ ~ ifconfig enx2c16dba37d18: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1500 inet 10.0.117.154 netmask 255.255.255.0 broadcast 10.0.117.255 inet6 2001:250:c00:218:5bd6:795c:5b92:e787 prefixlen 64 scopeid 0x0\u0026lt;global\u0026gt; inet6 fe80::2224:6ee:2527:f54d prefixlen 64 scopeid 0x20\u0026lt;link\u0026gt; inet6 2001:250:c00:218:44fc:ad73:aeb8:b07d prefixlen 64 scopeid 0x0\u0026lt;global\u0026gt; ether 2c:16:db:a3:7d:18 txqueuelen 1000 (Ethernet) RX packets 110382 bytes 150904005 (150.9 MB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 30811 bytes 3569027 (3.5 MB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 lo: flags=73\u0026lt;UP,LOOPBACK,RUNNING\u0026gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10\u0026lt;host\u0026gt; loop txqueuelen 1000 (Local Loopback) RX packets 26251 bytes 4892192 (4.8 MB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 26251 bytes 4892192 (4.8 MB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 wlp2s0: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1500 inet 192.168.7.243 netmask 255.255.255.0 broadcast 192.168.7.255 inet6 fe80::1dea:1bcb:ae17:fa3b prefixlen 64 scopeid 0x20\u0026lt;link\u0026gt; ether d0:c6:37:dd:91:95 txqueuelen 1000 (Ethernet) RX packets 17759 bytes 19498138 (19.4 MB) RX errors 0 dropped 7 overruns 0 frame 0 TX packets 6341 bytes 911629 (911.6 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 ping Linux 服务器无法上网\nping localhost\n侦测网卡安装或配置有问题 ping 网关\nip route show 查看网关\n侦测局域网中的网关或路由器是否正常 ping dns server\n在 /etc/resolv.conf 查看 dns 配置\ndns 解析是否可以解析 ping 远程地址\n与外部的连接是否正常 mtr 网络侦测工具\nMy traceroute [v0.93] an-xiaomi-book-pro (10.0.117.154) 2020-11-10T10:08:42+0800 Keys: Help Display mode Restart statistics Order of fields quit Packets Pings Host Loss% Snt Last Avg Best Wrst StDev 1. _gateway 0.0% 156 1.2 1.8 0.8 16.4 2.6 2. 10.125.255.2 0.0% 156 0.6 0.5 0.4 0.8 0.1 3. 172.16.1.254 96.8% 156 2.5 5.7 1.7 18.3 7.1 4. 129.210.99.202.internet. 0.0% 156 2.1 3.4 1.7 12.4 2.2 5. 57.53.26.218.internet.sx 0.0% 156 2.7 4.1 2.1 12.9 1.9 6. 165.151.26.218.internet. 0.0% 156 25.9 25.6 24.0 32.0 0.9 7. 219.158.101.109 0.0% 155 17.2 14.0 10.1 18.5 2.3 8. 219.158.5.158 0.0% 155 17.7 15.5 10.9 33.9 3.2 9. 219.158.16.70 0.0% 155 13.1 15.7 11.7 20.8 2.4 10. 219.158.32.30 18.7% 155 121.5 165.3 108.3 226.9 34.2 11. ae-1.r31.tokyjp05.jp.bb. 0.0% 155 56.5 109.5 55.6 173.8 34.5 12. ae-3.r01.tokyjp08.jp.bb. 18.1% 155 109.4 161.9 108.5 222.7 35.2 13. ae-3.fastly.tokyjp08.jp. 20.6% 155 106.5 161.5 105.9 219.5 33.7 14. 185.199.109.153 0.6% 155 159.2 210.4 157.4 271.3 33.6 Loss 丢包率 Snt 发送的次数 Last 最近一次的返回时延 Avg 平均值 Best 最短的一次时间 Wrst 最长的一次时间 StDev 标准偏差 traceroute / tracepath ➜ ~ traceroute aimerneige.com traceroute to aimerneige.com (185.199.109.153), 30 hops max, 60 byte packets 1 10.0.117.1 (10.0.117.1) 11.848 ms 11.768 ms 11.719 ms 2 10.125.255.2 (10.125.255.2) 0.605 ms 0.578 ms 0.544 ms 3 * * * 4 129.210.99.202.internet.sx.cn (202.99.210.129) 2.015 ms 1.965 ms 1.920 ms 5 233.124.26.218.internet.sx.cn (218.26.124.233) 1.874 ms 2.345 ms 237.124.26.218.internet.sx.cn (218.26.124.237) 2.304 ms 6 245.131.26.218.router-switch.sx.cn (218.26.131.245) 2.902 ms 209.151.26.218.internet.sx.cn (218.26.151.209) 40.287 ms 245.131.26.218.router-switch.sx.cn (218.26.131.245) 2.713 ms 7 219.158.105.93 (219.158.105.93) 10.882 ms 219.158.102.249 (219.158.102.249) 9.079 ms 219.158.101.109 (219.158.101.109) 13.673 ms 8 219.158.5.158 (219.158.5.158) 11.302 ms 11.258 ms 219.158.4.174 (219.158.4.174) 20.035 ms 9 219.158.16.70 (219.158.16.70) 11.866 ms 19.391 ms 19.316 ms 10 219.158.32.30 (219.158.32.30) 216.576 ms 220.853 ms 215.579 ms 11 ae-0.r30.tokyjp05.jp.bb.gin.ntt.net (129.250.2.11) 162.897 ms 162.880 ms ae-1.r31.tokyjp05.jp.bb.gin.ntt.net (129.250.2.153) 163.532 ms 12 ae-3.r01.tokyjp08.jp.bb.gin.ntt.net (129.250.6.133) 215.634 ms ae-3.r00.tokyjp08.jp.bb.gin.ntt.net (129.250.6.129) 213.725 ms ae-2.r00.tokyjp08.jp.bb.gin.ntt.net (129.250.6.127) 169.350 ms 13 * * * 14 * * * 15 * * * 16 * * * 17 * * * 18 * * * 19 * * * 20 * * * 21 * * * 22 * * * 23 * * * 24 * * * 25 * * * 26 * * * 27 * * * 28 * * * 29 * * * 30 * * * ➜ ~ tracepath aimerneige.com 1?: [LOCALHOST] pmtu 1500 1: _gateway 1.048ms 1: _gateway 1.195ms 2: 10.125.255.2 0.588ms 3: 172.16.1.254 5.206ms 4: 129.210.99.202.internet.sx.cn 2.954ms 5: 145.53.26.218.internet.sx.cn 2.496ms 6: 245.131.26.218.router-switch.sx.cn 4.198ms 7: 219.158.11.113 13.225ms 8: 219.158.5.158 19.169ms 9: 219.158.16.70 11.860ms 10: 219.158.32.30 226.589ms 11: ae-1.r31.tokyjp05.jp.bb.gin.ntt.net 165.652ms 12: ae-3.r00.tokyjp08.jp.bb.gin.ntt.net 200.616ms 13: no reply 14: no reply 15: no reply 16: no reply 17: no reply 18: no reply 19: no reply 20: no reply 21: no reply 22: no reply 23: no reply 24: no reply 25: no reply 26: no reply 27: no reply 28: no reply 29: no reply 30: no reply Too many hops: pmtu 1500 Resume: pmtu 1500 ip 查看网卡信息 ip addr show ➜ ~ ip addr show 1: lo: \u0026lt;LOOPBACK,UP,LOWER_UP\u0026gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever 2: wlp2s0: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc noqueue state UP group default qlen 1000 link/ether d0:c6:37:dd:91:95 brd ff:ff:ff:ff:ff:ff inet 192.168.7.243/24 brd 192.168.7.255 scope global dynamic noprefixroute wlp2s0 valid_lft 169205sec preferred_lft 169205sec inet6 fe80::1dea:1bcb:ae17:fa3b/64 scope link noprefixroute valid_lft forever preferred_lft forever 3: enx2c16dba37d18: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000 link/ether 2c:16:db:a3:7d:18 brd ff:ff:ff:ff:ff:ff inet 10.0.117.154/24 brd 10.0.117.255 scope global dynamic noprefixroute enx2c16dba37d18 valid_lft 3601sec preferred_lft 3601sec inet6 2001:250:c00:218:44fc:ad73:aeb8:b07d/64 scope global temporary dynamic valid_lft 601397sec preferred_lft 82623sec inet6 2001:250:c00:218:5bd6:795c:5b92:e787/64 scope global dynamic mngtmpaddr noprefixroute valid_lft 2591976sec preferred_lft 604776sec inet6 fe80::2224:6ee:2527:f54d/64 scope link noprefixroute valid_lft forever preferred_lft forever 启用/禁用网卡 sudo ip link set enp0s3 up / dowm 为网卡分配地址 sudo ip addr add 192.168.0.50/255.255.255.0 dev enp0s3 sudo ip addr del 192.168.0.10/24 dev enp0s3 ip route 查看路由\nip route\n➜ ~ ip route default via 10.0.117.1 dev enx2c16dba37d18 proto dhcp metric 100 default via 192.168.7.1 dev wlp2s0 proto dhcp metric 600 10.0.117.0/24 dev enx2c16dba37d18 proto kernel scope link src 10.0.117.154 metric 100 169.254.0.0/16 dev enx2c16dba37d18 scope link metric 1000 192.168.7.0/24 dev wlp2s0 proto kernel scope link src 192.168.7.243 metric 600 添加静态路由\nsudo ip route add 172.16.32.32 via 192.168.0.150/24 dev enp0s3\n删除路由\nsudo ip route del 192.168.0.150/24\narp 查看 arp 记录\nip neigh\n➜ ~ ip neigh 192.168.7.2 dev wlp2s0 lladdr e8:39:35:1f:13:b1 STALE 192.168.7.1 dev wlp2s0 lladdr 28:d1:27:85:38:d7 REACHABLE 10.0.117.177 dev enx2c16dba37d18 lladdr e8:39:35:1f:14:fc STALE 192.168.7.38 dev wlp2s0 lladdr 2c:ff:ee:66:e2:01 STALE 10.0.117.1 dev enx2c16dba37d18 lladdr 58:69:6c:07:71:4b REACHABLE 192.168.7.160 dev wlp2s0 lladdr 3e:22:9c:ef:b8:d2 STALE fe80::5a69:6cff:fe07:714b dev enx2c16dba37d18 lladdr 58:69:6c:07:71:4b router STALE PERM 永久有效并且只能被管理员删除 NOARP 记录有效，过期后可被删除 STALE 记录有效，但可能已经过期 REACHABLE 记录有效，但超时后就失效了 增加 arp 记录\nsudo ip neigh add 192.168.0.150 lladdr 33:1g:75:37:r3:84 dev enp0s3 nud perm\n删除 arp\nsudo ip neigh del 192.168.0.106 dev enp0s3\ncurl / wget curl aimerneige.com\nwget aimerneige.com\nnetstat 网络连接状态以及其相关信息的程序\n告诉用户哪些网络连接正在运作\n列出所有端口 netstat -a 列出所有 tcp 端口 netstat -at 列出所有 udp 端口 netstat -au 显示进程 id 和名称 netstat -p 显示路由信息 netstat -r 显示所有监听的端口 netstat -tnl ","permalink":"https://aimerneige.com/zh/post/linux/daily-linux-command/","summary":"ifconfig ➜ ~ ifconfig enx2c16dba37d18: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1500 inet 10.0.117.154 netmask 255.255.255.0 broadcast 10.0.117.255 inet6 2001:250:c00:218:5bd6:795c:5b92:e787 prefixlen 64 scopeid 0x0\u0026lt;global\u0026gt; inet6 fe80::2224:6ee:2527:f54d prefixlen 64 scopeid 0x20\u0026lt;link\u0026gt; inet6 2001:250:c00:218:44fc:ad73:aeb8:b07d prefixlen 64 scopeid 0x0\u0026lt;global\u0026gt; ether 2c:16:db:a3:7d:18 txqueuelen 1000 (Ethernet) RX packets 110382 bytes 150904005 (150.9 MB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 30811 bytes 3569027 (3.5 MB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 lo: flags=73\u0026lt;UP,LOOPBACK,RUNNING\u0026gt; mtu 65536 inet 127.","title":"每天一个 Linux 指令"},{"content":"今天遇到一个奇怪的问题：\n一个 C 语言初学者写了这样的错误代码：\nswitch (a) { case1: // do something break; case2: // do something break; case3: // do something break; default: break; } 错误很容易解决，但是，在编译这样的程序时，编译器居然没有报错？？！！\n那么 case1 case2 这些东西是哪里来的？\n几番求证无果，最后在翻阅《C 专家编程》这本书的时候突然发现了原因：\n首先像下面这样写是可以的：\nswitch (i) { case 5 + 3: do_again: case 2: printf(\u0026#34;I loop unremittingly\\n\u0026#34;); goto do_again; default: i++; case 3: ; } 这里定义了一个标签 do_again，并且通过 goto 跳转。\n原错误代码中 case1 case2 等被编译器理解为了标签。\n由于 goto 不被建议使用，博主居然已经忘记了标签和 goto 的用法。\n不管怎么说，问题解决了。\n这不是 Bug，而是 C 语言的特性。 #(滑稽)\n类似地，有如下代码：\n#include \u0026lt;stdio.h\u0026gt; int main() { https://aimerneige.com printf(\u0026#34;Hello World!\\n\u0026#34;); return 0; } 这里的代码直接贴上了一个 url，但是编译器也没有报错，是因为 https 被识别为标签，而后面的内容被识别为注释。\n","permalink":"https://aimerneige.com/zh/post/c/this-is-not-bug/","summary":"今天遇到一个奇怪的问题：\n一个 C 语言初学者写了这样的错误代码：\nswitch (a) { case1: // do something break; case2: // do something break; case3: // do something break; default: break; } 错误很容易解决，但是，在编译这样的程序时，编译器居然没有报错？？！！\n那么 case1 case2 这些东西是哪里来的？\n几番求证无果，最后在翻阅《C 专家编程》这本书的时候突然发现了原因：\n首先像下面这样写是可以的：\nswitch (i) { case 5 + 3: do_again: case 2: printf(\u0026#34;I loop unremittingly\\n\u0026#34;); goto do_again; default: i++; case 3: ; } 这里定义了一个标签 do_again，并且通过 goto 跳转。\n原错误代码中 case1 case2 等被编译器理解为了标签。\n由于 goto 不被建议使用，博主居然已经忘记了标签和 goto 的用法。\n不管怎么说，问题解决了。\n这不是 Bug，而是 C 语言的特性。 #(滑稽)","title":"这不是 Bug，而是语言特性"},{"content":"函数指针在大型的 C 语言项目中十分重要，但是学校对它的介绍一带而过，国内一些介绍函数指针的文章十分粗浅甚至存在错误（这里就不点名了），因此博主写了这篇文章介绍函数指针，希望能够帮助一些 C 语言学习者。\n文章部分内容翻译引用于 https://www.geeksforgeeks.org/function-pointer-in-c/\n函数指针的概念 类似变量，函数也会被分配一段存储空间，这段存储空间的首地址即被称做这个函数的地址。而且函数名表示的就是这个地址。既然是地址，我们就可以定义一个指针变量来存放，这个指针变量就叫做函数指针变量，简称函数指针。\n函数指针的定义 下面的语句定义了一个指向函数的指针变量 p。其中 void *表示返回值，(*p) 表示 p 是一个指针变量， (int, float) 是函数的参数列表。\nvoid *(*p) (int, float); 这样我们就得到了一个指针变量 p，它的类型为 void * (*)(int, float)\n所以函数指针的定义方法为：\n函数返回类型 (*指针变量名) (函数参数列表); 这里的函数参数列表类似函数声明，只需写出变量类型即可，并不需要定义变量。\n即下面的俩种写法等价并且第二种写法中定义的变量并没有任何意义，建议使用第一种写法，不要使用第二种写法。\nvoid *(*p) (int, float); void *(*p) (int a, float b); 如何对函数指针赋值 int Func(int x); // 函数的声明 int (*p) (int x); // 函数指针的定义 p = \u0026amp;Func; // 函数指针的赋值 p = Func; // 另一种可行的写法 注：对于俩种赋值写法的详细说明见对函数赋值和调用的一些说明\n函数指针的调用 #include \u0026lt;stdio.h\u0026gt; int max(int a, int b); // 函数声明 int main(int argc, char const *argv[]) { int a = 12; int b = 32; int (*p)(int, int); // 函数指针定义 p = \u0026amp;max; // 函数指针赋值 int c = (*p)(a, b); // 函数指针的调用 printf(\u0026#34;%d\\n\u0026#34;, c); // 输出 `32` return 0; } // 函数定义 int max(int a, int b) { return a \u0026gt; b ? a : b; } 另一种可行的写法\n#include \u0026lt;stdio.h\u0026gt; int max(int a, int b); // 函数声明 int main(int argc, char const *argv[]) { int a = 12; int b = 32; int (*p)(int, int); // 函数指针定义 p = max; // 函数指针赋值 int c = *p(a, b); // 函数指针的调用 printf(\u0026#34;%d\\n\u0026#34;, c); // 输出 `32` return 0; } // 函数定义 int max(int a, int b) { return a \u0026gt; b ? a : b; } 注：对于这俩种调用的写法的详细说明见对函数赋值和调用的一些说明\n函数指针中要注意的一些内容 与一般的指针不同，函数指针指向代码而不是数据。通常，一个函数指针存储了可执行代码的起始位置。 与普通指针不同，我们使用函数指针时不需要分配和释放内存。 函数名也可以用来获取函数的地址。（详见对函数赋值和调用的一些说明） 类似普通的指针，我们也有函数指针数组。（详见函数指针数组示例） 函数指针可被用于 switch case 结构中，例如函数指针数组示例中的示例程序中，用户可以通过输入 0 ～ 2 来选择不同的操作。 就像普通数据的指针一样，一个函数指针同样可以被用作函数的参数和返回值，例如函数指针作为参数的示例中的程序中 wrapper() 函数接受 void (*fun)() 作为参数并且执行这个函数。这个特性有很多的应用，你可以在函数指针作为参数的应用中查看更多内容。 C++ 中的许多面向对象特性都是使用 C 中的函数指针实现的，例如虚函数，类方法是使用函数指针实现的另一个示例。 对函数赋值和调用的一些说明 通常，既然是指针赋值，我们会使用取地址操作来获取地址，然后使用 * 运算符调用，但是，对于函数来说，直接使用函数名也可以获得地址。即如下俩种写法等价：\np = \u0026amp;Func; (*p)(2, 3); p = Func; p(2, 3); 编译执行以下程序：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int max(int a, int b); int main(int argc, char const *argv[]) { printf(\u0026#34;%p\\n\u0026#34;, (max) ); printf(\u0026#34;%p\\n\u0026#34;, (\u0026amp;max) ); return 0; } int max(int a, int b) { return a \u0026gt; b ? a : b; } 你会发现 (max) (\u0026amp;max) 拥有相同的值，即直接使用函数名也可以获得地址。\n因此，我更推荐第二种没有 \u0026amp; 和 * 的写法，更加直观易用。\n函数指针数组示例 #include \u0026lt;stdio.h\u0026gt; void add(int a, int b) { printf(\u0026#34;Addition is %d\\n\u0026#34;, a + b); } void subtract(int a, int b) { printf(\u0026#34;Subtraction is %d\\n\u0026#34;, a - b); } void multiply(int a, int b) { printf(\u0026#34;Multiplication is %d\\n\u0026#34;, a * b); } int main() { // fun_ptr_arr 是一个函数指针的数组 void (*fun_ptr_arr[])(int, int) = {add, subtract, multiply}; unsigned int ch, a = 15, b = 10; printf(\u0026#34;Enter Choice: 0 for add, 1 for subtract and 2 for multiply\\n\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;ch); if (ch \u0026gt; 2) { return 0; } (*fun_ptr_arr[ch])(a, b); return 0; } 函数指针作为参数的示例 // 一个简单的 C 语言程序来演示使用函数指针作为参数 #include \u0026lt;stdio.h\u0026gt; // 俩个简单的函数 void fun1() { printf(\u0026#34;Fun1\\n\u0026#34;); } void fun2() { printf(\u0026#34;Fun2\\n\u0026#34;); } // 一个接受函数作为参数并在内部执行这个函数的函数 void wrapper(void (*fun)()) { fun(); } int main() { wrapper(fun1); wrapper(fun2); return 0; } 函数指针作为参数的应用 我们可以使用将函数指针作为参数来避免书写重复的代码，例如较为简单的函数 qsort() 可以被用来排序数组或其他任何的自定义结构体。不仅这些，有了函数指针和空指针，使用 qsort() 函数可以对任何数据类型进行排序。\n// 一个关于 qsort 和比较器的定义 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; // 一个比较器示例函数 // 它被用对一个整数数组进行排序 // 为了对任何其他数据类型或条件的任何数组进行排序 // 我们需要编写更多的比较函数 // 这样我们就可以使用相同的 qsort() int compare(const void *a, const void *b) { return (*(int *)a - *(int *)b); } int main() { int arr[] = {10, 5, 15, 12, 90, 80}; int n = sizeof(arr) / sizeof(arr[0]); qsort(arr, n, sizeof(int), compare); for (int i = 0; i \u0026lt; n; i++) { printf(\u0026#34;%d \u0026#34;, arr[i]); } return 0; } 类似 qsort() 函数，我们可以定义自己的可以用于任何数据类型的函数来处理不同的任务。下面是一个搜索函数的示例，它可以被用于任何数据类型。事实上，我们可以通过写一个专门的比较函数使用这个搜索函数来找到相近的元素（低于某阈值）。\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; // 一个被用来对整数数组进行搜索的比较函数 bool compare(const void *a, const void *b) { return (*(int *)a == *(int *)b); } // 可以被用来在一个长度为 arr_size 的数组 arr[] 中 // 搜索元素 *x 的通用 search() 函数。 // 注意这里使用 void 指针，这样函数就可以在调用 // 的时候传入任何类型的参数 // ele_size 是数组元素的大小 int search(void *arr, int arr_size, int ele_size, void *x, bool compare(const void *, const void *)) { // 因为 char 占用一个字节，因此我们使用 char 指针 // 来可以保证用于任何类型的指针运算都正确，我们 // 需要将 index 与元素的大小 ele_size 相乘 char *ptr = (char *)arr; int i; for (i = 0; i \u0026lt; arr_size; i++) if (compare(ptr + i * ele_size, x)) return i; // 如果没有找到元素 return -1; } int main() { int arr[] = {2, 5, 7, 90, 70}; int n = sizeof(arr) / sizeof(arr[0]); int x = 7; printf(\u0026#34;Returned index is %d \u0026#34;, search(arr, n, sizeof(int), \u0026amp;x, compare)); return 0; } 这个函数可以被用于任何类型的数据，只要定义一个比较函数。\n如何使用 typedef 定义函数指针类型 与一般的定义不同，函数指针在使用 typedef 重命名时，新的变量名不是在末尾而是类似函数指针变量定义的写法。\n下面是一个简单的例子：\ntypedef int (*type_name) (const void *, double); 其中 int 为函数返回值类型， const void *, double 是函数接受的参数列表，(*type_name) 表明定义的是一个函数指针，它的类型为 int (*)(const void *, double)，新的类型名为 type_name，你可以使用 type_name 来定义一个类型为 int (*)(const void *, double) 的函数指针。\n也就是说，使用定义函数指针类型的格式如下：\ntypedef 函数返回值类型 (*类型名) (函数参数列表) 接下来看一下 qsort() 函数的源代码：\n首先是函数 qsort() 的声明：\nextern void qsort (void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar) __nonnull ((1, 4)); 这里有一个新的数据类型 __compar_fn_t，我们知道它是一个函数指针，我们找一下它的定义：\ntypedef int (*__compar_fn_t) (const void *, const void *); 上例中 search() 函数可以这样定义：\n// 类型定义 typedef bool (*compare_fun)(const void *, const void *); // 函数声明 int search(void *arr, int arr_size, int ele_size, void *x, compare_fun compare); 建议阅读： https://www.geeksforgeeks.org/function-pointer-in-c/\n","permalink":"https://aimerneige.com/zh/post/c/c-function-point/","summary":"函数指针在大型的 C 语言项目中十分重要，但是学校对它的介绍一带而过，国内一些介绍函数指针的文章十分粗浅甚至存在错误（这里就不点名了），因此博主写了这篇文章介绍函数指针，希望能够帮助一些 C 语言学习者。\n文章部分内容翻译引用于 https://www.geeksforgeeks.org/function-pointer-in-c/\n函数指针的概念 类似变量，函数也会被分配一段存储空间，这段存储空间的首地址即被称做这个函数的地址。而且函数名表示的就是这个地址。既然是地址，我们就可以定义一个指针变量来存放，这个指针变量就叫做函数指针变量，简称函数指针。\n函数指针的定义 下面的语句定义了一个指向函数的指针变量 p。其中 void *表示返回值，(*p) 表示 p 是一个指针变量， (int, float) 是函数的参数列表。\nvoid *(*p) (int, float); 这样我们就得到了一个指针变量 p，它的类型为 void * (*)(int, float)\n所以函数指针的定义方法为：\n函数返回类型 (*指针变量名) (函数参数列表); 这里的函数参数列表类似函数声明，只需写出变量类型即可，并不需要定义变量。\n即下面的俩种写法等价并且第二种写法中定义的变量并没有任何意义，建议使用第一种写法，不要使用第二种写法。\nvoid *(*p) (int, float); void *(*p) (int a, float b); 如何对函数指针赋值 int Func(int x); // 函数的声明 int (*p) (int x); // 函数指针的定义 p = \u0026amp;Func; // 函数指针的赋值 p = Func; // 另一种可行的写法 注：对于俩种赋值写法的详细说明见对函数赋值和调用的一些说明\n函数指针的调用 #include \u0026lt;stdio.","title":"C 函数指针"},{"content":"线程于进程的对比\nthread 线程 有共享内存 process 进程 没有共享内存 gcc file.c -lpthread 创建线程\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;pthread.h\u0026gt; void *myfunc(void *args) { for (int i = 0; i \u0026lt; 50; i++) { printf(\u0026#34;%d\\n\u0026#34;, i); } return NULL; } int main() { pthread_t th1; pthread_t th2; pthread_create(\u0026amp;th1, NULL, myfunc, NULL); pthread_create(\u0026amp;th2, NULL, myfunc, NULL); pthread_join(th1, NULL); pthread_join(th2, NULL); return 0; } 传入参数\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;pthread.h\u0026gt; void *myfunc(void *args) { char *name = (char *)args; for (int i = 0; i \u0026lt; 50; i++) { printf(\u0026#34;%s %d\\n\u0026#34;, name, i); } return NULL; } int main() { pthread_t th1; pthread_t th2; pthread_create(\u0026amp;th1, NULL, myfunc, \u0026#34;th1\u0026#34;); pthread_create(\u0026amp;th2, NULL, myfunc, \u0026#34;th2\u0026#34;); pthread_join(th1, NULL); pthread_join(th2, NULL); return 0; } 分部计算\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;pthread.h\u0026gt; int arr[5000]; int s1 = 0; int s2 = 0; void *myfunc1(void *args) { for (int i = 0; i \u0026lt; 2500; i++) { s1 += arr[i]; } return NULL; } void *myfunc2(void *args) { for (int i = 2500; i \u0026lt; 5000; i++) { s2 += arr[i]; } return NULL; } int main() { for (int i = 0; i \u0026lt; 5000; i++) { arr[i] = rand() % 50; } pthread_t th1; pthread_t th2; pthread_create(\u0026amp;th1, NULL, myfunc1, NULL); pthread_create(\u0026amp;th2, NULL, myfunc2, NULL); pthread_join(th1, NULL); pthread_join(th2, NULL); int S = s1 + s2; printf(\u0026#34;Result: %d\\n\u0026#34;, S); return 0; } 单参数的写法\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;pthread.h\u0026gt; int arr[5000]; int s1 = 0; int s2 = 0; void *myfunc(void *args) { int a = 0 [(int *)args]; if (a == 1) { for (int i = 0; i \u0026lt; 2500; i++) { s1 += arr[i]; } } else { for (int i = 2500; i \u0026lt; 5000; i++) { s2 += arr[i]; } } return NULL; } int main() { for (int i = 0; i \u0026lt; 5000; i++) { arr[i] = rand() % 50; } pthread_t th1; pthread_t th2; pthread_create(\u0026amp;th1, NULL, myfunc, (int []){1}); pthread_create(\u0026amp;th2, NULL, myfunc, (int []){2}); pthread_join(th1, NULL); pthread_join(th2, NULL); int S = s1 + s2; printf(\u0026#34;Result: %d\\n\u0026#34;, S); return 0; } 传入结构体\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;pthread.h\u0026gt; typedef struct { int first; int last; } MY_ARGS; int arr[5000]; int s1 = 0; int s2 = 0; void *myfunc(void *args) { MY_ARGS *arg = (MY_ARGS *)args; for (int i = arg-\u0026gt;first; i \u0026lt; arg-\u0026gt;last; i++) { s1 += arr[i]; } return NULL; } int main() { for (int i = 0; i \u0026lt; 5000; i++) { arr[i] = rand() % 50; } pthread_t th1; pthread_t th2; MY_ARGS args_1 = {0, 2500}; MY_ARGS args_2 = {2500, 5000}; pthread_create(\u0026amp;th1, NULL, myfunc, \u0026amp;args_1); pthread_create(\u0026amp;th2, NULL, myfunc, \u0026amp;args_2); pthread_join(th1, NULL); pthread_join(th2, NULL); int S = s1 + s2; printf(\u0026#34;Result: %d\\n\u0026#34;, S); return 0; } 结构体的更多参数\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;pthread.h\u0026gt; typedef struct { int first; int last; int result; } MY_ARGS; int arr[5000]; void *myfunc(void *args) { MY_ARGS *arg = (MY_ARGS *)args; for (int i = arg-\u0026gt;first; i \u0026lt; arg-\u0026gt;last; i++) { arg-\u0026gt;result += arr[i]; } return NULL; } int main() { for (int i = 0; i \u0026lt; 5000; i++) { arr[i] = rand() % 50; } pthread_t th1; pthread_t th2; MY_ARGS args_1 = {0, 2500, 0}; MY_ARGS args_2 = {2500, 5000, 1}; pthread_create(\u0026amp;th1, NULL, myfunc, \u0026amp;args_1); pthread_create(\u0026amp;th2, NULL, myfunc, \u0026amp;args_2); pthread_join(th1, NULL); pthread_join(th2, NULL); int S = args_1.result + args_2.result; printf(\u0026#34;Result: %d\\n\u0026#34;, S); return 0; } 一些错误的写法\n它会造成 race condition\n// dangerous operation #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;pthread.h\u0026gt; int a = 0; void *myfunc(void *args) { for (int i = 0; i \u0026lt; 1000000; i++) { a++; } return NULL; } int main() { pthread_t pt1; pthread_t pt2; pthread_create(\u0026amp;pt1, NULL, myfunc, NULL); pthread_create(\u0026amp;pt2, NULL, myfunc, NULL); pthread_join(pt1, NULL); pthread_join(pt2, NULL); printf(\u0026#34;%d\\n\u0026#34;, a); return 0; } 加锁\n// in this way, it is slow #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;pthread.h\u0026gt; #define MAX_SIZE 5000000 pthread_mutex_t lock; int a = 0; void *myfunc(void *args) { for (int i = 0; i \u0026lt; 100000; i++) { pthread_mutex_lock(\u0026amp;lock); a++; pthread_mutex_unlock(\u0026amp;lock); } return NULL; } int main() { pthread_t pt1; pthread_t pt2; pthread_mutex_init(\u0026amp;lock, NULL); pthread_create(\u0026amp;pt1, NULL, myfunc, NULL); pthread_create(\u0026amp;pt2, NULL, myfunc, NULL); pthread_join(pt1, NULL); pthread_join(pt2, NULL); printf(\u0026#34;%d\\n\u0026#34;, a); return 0; } 较为完整的写法\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;pthread.h\u0026gt; #define ZERO 0 #define HALF 2500000 #define MAX_SIZE 5000000 typedef struct { int first; int last; int id; } MY_ARGS; int *arr; int result[2]; void *myfunc(void *args) { MY_ARGS *arg = (MY_ARGS *)args; for (int i = arg-\u0026gt;first; i \u0026lt; arg-\u0026gt;last; i++) { result[arg-\u0026gt;id] += arr[i]; } return NULL; } int main() { arr = (int *)malloc(sizeof(int) * MAX_SIZE); for (int i = 0; i \u0026lt; MAX_SIZE; i++) { arr[i] = rand() % 5; } result[0] = 0; result[1] = 0; pthread_t th1; pthread_t th2; MY_ARGS args_1 = {ZERO, HALF, 0}; MY_ARGS args_2 = {HALF, MAX_SIZE, 1}; pthread_create(\u0026amp;th1, NULL, myfunc, \u0026amp;args_1); pthread_create(\u0026amp;th2, NULL, myfunc, \u0026amp;args_2); pthread_join(th1, NULL); pthread_join(th2, NULL); int S = result[0] + result[1]; printf(\u0026#34;Result: %d\\n\u0026#34;, S); return 0; } ","permalink":"https://aimerneige.com/zh/post/c/c-thread-basic/","summary":"线程于进程的对比\nthread 线程 有共享内存 process 进程 没有共享内存 gcc file.c -lpthread 创建线程\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;pthread.h\u0026gt; void *myfunc(void *args) { for (int i = 0; i \u0026lt; 50; i++) { printf(\u0026#34;%d\\n\u0026#34;, i); } return NULL; } int main() { pthread_t th1; pthread_t th2; pthread_create(\u0026amp;th1, NULL, myfunc, NULL); pthread_create(\u0026amp;th2, NULL, myfunc, NULL); pthread_join(th1, NULL); pthread_join(th2, NULL); return 0; } 传入参数\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;pthread.h\u0026gt; void *myfunc(void *args) { char *name = (char *)args; for (int i = 0; i \u0026lt; 50; i++) { printf(\u0026#34;%s %d\\n\u0026#34;, name, i); } return NULL; } int main() { pthread_t th1; pthread_t th2; pthread_create(\u0026amp;th1, NULL, myfunc, \u0026#34;th1\u0026#34;); pthread_create(\u0026amp;th2, NULL, myfunc, \u0026#34;th2\u0026#34;); pthread_join(th1, NULL); pthread_join(th2, NULL); return 0; } 分部计算","title":"C 语言多线程基础"},{"content":"在 C 语言中，函数默认是全局的。在函数前加“static”关键字可以使一个函数变成静态函数。例如，下面的函数 fun() 是静态的：\nstatic int fun(void) { printf(\u0026#34;I am a static funciton.\\n\u0026#34;); } 与 C 语言中的全局函数不同，对静态函数的访问仅限于声明它们的文件。因此，当我们想要限制函数的访问时，我们可以将函数定义为静态的。另外，如果我们想要在其他文件中使用相同的函数名，我们也可以将函数定义为静态的。\n例如，我们在文件 file.c 中存储了下面的程序：\n// in file `file1.c` #include \u0026lt;stdio.h\u0026gt; static void fun1() { printf(\u0026#34;fun1 called.\\n\u0026#34;); } 然后，我们在文件 file2.c 中存储了这样的程序：\n// in file `file2.c` #include \u0026lt;stdio.h\u0026gt; int main(void) { fun1(); return 0; } 接下来，如果我们按照如下的命令编译：\ngcc file2.c file1.c 你会得到这样的链接错误：\nundefined reference to `fun1\u0026#39; 这是因为 fun1() 函数在 file1.c 中被定义为静态，因而不能在 file2.c 中引用。\n","permalink":"https://aimerneige.com/zh/post/c/c-static-function/","summary":"在 C 语言中，函数默认是全局的。在函数前加“static”关键字可以使一个函数变成静态函数。例如，下面的函数 fun() 是静态的：\nstatic int fun(void) { printf(\u0026#34;I am a static funciton.\\n\u0026#34;); } 与 C 语言中的全局函数不同，对静态函数的访问仅限于声明它们的文件。因此，当我们想要限制函数的访问时，我们可以将函数定义为静态的。另外，如果我们想要在其他文件中使用相同的函数名，我们也可以将函数定义为静态的。\n例如，我们在文件 file.c 中存储了下面的程序：\n// in file `file1.c` #include \u0026lt;stdio.h\u0026gt; static void fun1() { printf(\u0026#34;fun1 called.\\n\u0026#34;); } 然后，我们在文件 file2.c 中存储了这样的程序：\n// in file `file2.c` #include \u0026lt;stdio.h\u0026gt; int main(void) { fun1(); return 0; } 接下来，如果我们按照如下的命令编译：\ngcc file2.c file1.c 你会得到这样的链接错误：\nundefined reference to `fun1\u0026#39; 这是因为 fun1() 函数在 file1.c 中被定义为静态，因而不能在 file2.c 中引用。","title":"C 语言静态函数"},{"content":" 注意将本文章提到的路径中 AimerNeige 修改为自己的用户名，之后不再赘述。\n安装 alacritty 按照自己的喜好 在 GitHub 下载最新版 release 或自己编译。\n本次演示中可执行文件存储目录：\nC:\\Tools\\Alacritty\\alacritty.exe\n配置 alacritty 将配置文件放置在如下目录：\nC:\\Users\\AimerNeige\\AppData\\Roaming\\alacritty\\alacritty.yml\n配置方法和 Linux 下类似。\n我的配置文件\n将 alacrity 注册为右键菜单启动 新建文本文件，填入如下内容，修改后缀为 .reg 运行，将配置写入注册表。\nWindows Registry Editor Version 5.00 [HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\alacritty] @=\u0026#34;Alacritty terminal here\u0026#34; \u0026#34;Icon\u0026#34;=\u0026#34;C:\\\\Tools\\\\Alacritty\\\\alacritty.ico\u0026#34; [HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\alacritty\\command] @=\u0026#34;C:\\\\Tools\\\\Alacritty\\\\alacritty.exe\u0026#34; 当然，你也可以按照自己的喜好手动编辑注册表。\n其中 Icon 这一行中使用的的图标文件可以在 GitHub 官方仓库 下载，或者也可以使用自己喜欢的内容。\n你也可以将 @=\u0026quot;Alacritty terminal here\u0026quot; 修改为自己喜欢的内容。\n","permalink":"https://aimerneige.com/zh/post/others/alacritty-on-windows/","summary":"注意将本文章提到的路径中 AimerNeige 修改为自己的用户名，之后不再赘述。\n安装 alacritty 按照自己的喜好 在 GitHub 下载最新版 release 或自己编译。\n本次演示中可执行文件存储目录：\nC:\\Tools\\Alacritty\\alacritty.exe\n配置 alacritty 将配置文件放置在如下目录：\nC:\\Users\\AimerNeige\\AppData\\Roaming\\alacritty\\alacritty.yml\n配置方法和 Linux 下类似。\n我的配置文件\n将 alacrity 注册为右键菜单启动 新建文本文件，填入如下内容，修改后缀为 .reg 运行，将配置写入注册表。\nWindows Registry Editor Version 5.00 [HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\alacritty] @=\u0026#34;Alacritty terminal here\u0026#34; \u0026#34;Icon\u0026#34;=\u0026#34;C:\\\\Tools\\\\Alacritty\\\\alacritty.ico\u0026#34; [HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\alacritty\\command] @=\u0026#34;C:\\\\Tools\\\\Alacritty\\\\alacritty.exe\u0026#34; 当然，你也可以按照自己的喜好手动编辑注册表。\n其中 Icon 这一行中使用的的图标文件可以在 GitHub 官方仓库 下载，或者也可以使用自己喜欢的内容。\n你也可以将 @=\u0026quot;Alacritty terminal here\u0026quot; 修改为自己喜欢的内容。","title":"在 Windows10 安装和配置 alacritty"},{"content":"GCC 简介 GCC 是 Linux 下的编译工具集，是 GNU Compiler Collection 的缩写,包含 gcc 、 g++ 等编译器。这个工具集不仅包含编译器，还包含其他工具集，例如 ar 、 nm 等。\nGCC 工具集不仅能编译 C/C++ 语言，其他例如 Objective-C 、 Pascal 、 Fortran 、 Java 、 Ada 等语言均能进行编译。\nGCC 在可以根据不同的硬件平台进行编译，即能进行交叉编译，在 A 平台上编译 B 平台的程序，支持常见的 X86 、 ARM 、 PowerPC 、 mips 等，以及 Linux 、 Windows 等软件平台。\nGCC 的 C 编译器 是 gcc，其命令格式为 :\nUsage: gcc [options] file... GCC 下默认文扩展名的含义：\n文件扩展名 GCC 所理解的含义 *.c 该类文件为 C 语言的源文件 *.h 该类文件为 C 语言的头文件 *.i 该类文件为预处理后的 C 文件 *.C 该类文件为 C++ 语言的源文件 *.cc 该类文件为 C++ 语言的源文件 *.cxx 该类文件为 C++ 语言的源文件 *.m 该类文件为 Objective-C 语言的源文件 *.s 该类文件为汇编语言的源文件 *.o 该类文件为汇编后的目标文件 *.a 该类文件为静态库 *.so 该类文件为共享库 a.out 该类文件为链接后的输出文件 GCC 下有很多编译器，可以支持 C 语言，C++语言等多种语言\nGCC 编译器命令 含义 cc 指的是 C 语言编译器 cpp 指的是预处理编译器 gcc 指的是 C 语言编译器 g++ 指的是 C++语言编译器 编译程序的基本知识 GCC 编译器对程序的编译分为 4 个阶段：\n预编译 编译和优化 汇编 链接 GCC 的编译器可以将这 4 个步骤合并成一个。\n源文件指存放可编辑代码的文件，如存放 C/C++ 和汇编语言的文件。\n目标文件是指经过编译器的编译生成的 CPU 可识别的二进制代码，但是目标文件一般不能执行，因为其中的一些函数过程没有相关的指示和说明。\n可执行文件就是目标文件与相关的库链接后的文件，它是可以执行的。\n预编译过程将程序中引用的头文件包含进源代码中，并对一些宏进行替换。\n编译过程将用户可识别的语言翻译成一组处理器可识别的操作码，生成目标文件，通常翻译成汇编语言，而汇编语言通常和机器操作码之间是一种一对一的关系。 GNU 中有 C/C++ 编译器 GCC 和汇编器 as。\n所有的目标文件必须用某种方式组合起来才能运行，这就是链接的作用。目标文件中通常仅解析了文件内部的变量和函数，对于引用的函数和变量还没有解析，这需要将其他已经编写好的目标文件引用进来，将没有解析的变量和函数进行解析，通常引用的目标是库。链接完成后会生成可执行文件。\n单个文件编译成执行文件 下面是一个示例程序的源代码：\n// hello.c #include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;Hello World!\\n\u0026#34;); return 0; } 将其保存在 hello.c 文件中，运行如下命令将代码直接编译成可执行文件：\n$ gcc hello.c 上述命令没有指定生成执行文件的名称， GCC 将生成默认的文件名 a.out。 运行结果如下：\n$ ./a.out Hello World! 如果希望生成指定的可执行文件名，选项 -o 可以使编译程序生成指定文件名，例如将上述程序编译输出一个名称为 test 的执行程序：\n$ gcc -o test hello.c 上述命令把 hello.c 源文件编译成可执行文件 test。 运行可执行文件 test，向终端输出 \u0026quot;Hello World!\u0026quot; 字符串。运行结果如下：\n$ ./test Hello World! 编译生成目标文件 GCC 的 -c 选项可以用于生成目标文件，这一选项将源文件生成目标文件，而不是生成可执行文件。默认情况下生成的目标文件的文件名和源文件的名称一样，只是扩展名为 .o。例如，下面的命令会生成一个名字为 Hello.o 的目标文件：\n$ gcc -c hello.c 如果需要生成指定的文件名，可以使用 -o 选项。下面的命令将源文件 hello.c 编译成目标文件，文件名为 test.o：\n$ gcc -c -o test.o hello.c 可以用一条命令编译多个源文件，生成目标文件，这通常用于编写库文件或者一个项目中包含多个源文件。例如一个项目包含 filel.c 、 file2.c 和 file3.c, 下面的命令可以将源文件生成 3 个目标文件 : filel.o 、 file2.o 和 file3.o：\n$ gcc -c file1.c file2.c file3.c 多文件编译 GCC 可以自动链接多个文件，不管是目标文件还是源文件，都可以使用同一个命令编译到一个可执行文件中。例如一个项目包含俩个文件，文件 string.c 中有一个函数 StrLen 用于计算字符串的长度，而在 main.c 中调用这个函数将计算结果显示出来。\n源文件 string.c // string.c #define ENDSTRING \u0026#39;\\0\u0026#39; int StrLen(char *string) { int len = 0; while (*string++ != ENDSTRING) { len++; } return len; } 源文件 main.c // main.c #include \u0026lt;stdio.h\u0026gt; extern int StrLen(char *str); int main() { char src[] = \u0026#34;Hello AimerNeige!\\n\u0026#34;; printf(\u0026#34;String length is: %d\\n\u0026#34;, StrLen(src)); return 0; } 编译运行 下面的命令将俩个源文件中的程序编译成一个执行文件，文件名为 test。\n$ gcc -o test strung.c main.c 执行编译出来的可执行文件 test，程序的运行结果如下：\n$ ./test String length is: 18 当然也可以先将源文件编成目标文件，然后进行链接。例如，下面的过程将 string.c 和 main.c 源文件编译成目标文件 string.o 和 main.o，然后将 string.o 和 main.o 链接生成 test ：\n$ gcc -c string.c main.c $ gcc -o test string.o main.o 预处理 在 C 语言程序中，通常需要包含头文件并会定义一些宏。 预处理过程将源文件中的头文件包含进源文件中，并且将文件中定义的宏进行扩展。\n编译程序时选项 -E 告诉编译器进行预编译操作。例如如下命令将文件 string.c 的预处理结果显示在计算机屏幕上 :\n$ gcc -E string.c 如果需要指定源文件编译后生成的中间结果文件名，需要使用选项 -o。例如，下面的代码将文件 string.c 进行预编译，生成文件 string.i。\n$ gcc -o string.i -E string.c 编译成汇编语言 生成汇编语言的 GCC 选项 是 -S，默认情况下生成的文件名和源文件一致，扩展名为 .s。例如，下面的命令将 C 语言源文件 string.c 编译成汇编语言，文件名为 string.s。\n$ gcc -S string.c 生成和使用静态链接库 静态库是 obj 文件的一个集合，通常静态库以 .a 为后缀。静态库由程序 ar 生成，现在静态库已经不像之前那么普遍了，这主要是由于程序都在使用动态库。\n静态库的优点是可以在不用重新编译程序库代码的情况下，进行程序的重新链接，这种方法节省了编译过程的时间（在编译大型程序的时候，需要花费很长时间）。但是由于现在系统的强大，编译的时间已经不是问题。静态库的另一个优势是开发者可以提供库文件给使用的人员，不用开放源代码，这是库函数提供者经常采用的手段。当然这也是程序模块化开发的一种手段，使每个软件开发人员的精力集中在自己的部分。在理论上，静态库的执行速度比共享库和动态库要快（1% ～ 5% ）。\n生成静态链接库 生成静态库，或者将一个 obj 文件加到已经存在的静态库的命令为 ar 库文件 obj文件1 obj文件2。创建静态库的最基本步骤是生成目标文件，这点前面已经介绍过。然后使用工具 ar 对目标文件进行归档。工具 ar 的 -r 选项，可以创建库，并把目标文件插入到指定库中。例如，将 string.o 打包为库文件 libstr.a 的命令为：\n$ ar -rcs libstr.a string.o 使用静态链接库 在编译程序的时候经常需要使用函数库，例如经常使用的 C 标准库等。GCC 链接时使用库函数和一般的 obj 文件的形式是一致的，例如对 main.c 进行链接的时候，需要使用之前已经编译好的静态链接库 libstr.a, 命令格式如下：\n$ gcc -o test main.c libstr.a 也可以使用命令 -l 库名 进行，库名是不包含函数库和扩展名的字符串。例如编译 main.c 链接静态库 libstr.a 的命令可以修改为：\n$ gcc -o test main.c -lstr 上面的命令将在系统默认的路径下查找 str 函数库，并把它链接到要生成的目标程序上。可能系统会提示无法找到库文件 str , 这是由于 str 库函数没有在系统默认的查找路径下，需要显示指定库函数的路径，例如库文件和当前编译文件在同一目录下：\n$ gcc -o test main.c -L./ -lstr 生成动态链接库 动态链接库是程序运行时加载的库，当动态链接库正确安装后，所有的程序都可以使用动态库来运行程序。动态链接库是目标文件的集合，目标文件在动态链接库中的组织方式是按照特殊方式形成的。库中函数和变量的地址是相对地址，不是绝对地址，其真实地址在调用动态库的程序加载时形成。\n动态链接库的名称有别名(soname)、真名(realname)和链接名(linker name)。别名由一个前缀 lib，然后是库的名字，再加上一个后缀 .so 构成。真名是动态链接库的真实名称，一般总是在别名的基础上加上一个小版本号、发布版本等构成。除此之外，还有一个链接名，即程序链接时使用的库的名字。在动态链接库安装的时候，总是复制库文件到某个目录下，然后用一个软链接生成别名，在库文件进行更新的时候，仅仅更新软链接即可。\n生成动态链接库 生成动态链接库的命令很简单，使用 -fPIC 选项或者 -fpic。 -fPIC 和 -fpic 选项的作用是使得 gcc 生成的代码是位置无关的，例如下面的命令将 string.c 编译生成动态链接库：\n$ gcc -shared -Wl,-soname,libstr.so -o libstr.so.1 string.c 其中，选项 -soname,libstr.so 表示生成动态库时的别名是 libstr.so； -o libstr.so.l 选项则表示是生成名字为 libstr.so.1 的实际动态链接库文件； -shared 告诉编译器生成一个动态链接库。\n生成动态链接库之后一个很重要的问题就是安装，一般情况下将生成的动态链接库复制到系统默认的动态链接库的搜索路径下，通常有/lib 、 /usr/lib 、 /usr/local/lib，放到以上任何一个目录下都可以。\n动态链接库的配置 动态链接库不能随意使用，要在运行的程序中使用动态链接库，需要指定系统的动态链接库搜索的路径，让系统找到运行所需的动态链接库才可以。系统中的配置文件 /etc/ld.so.conf 是动态链接库的搜索路径配置文件。在这个文件内，存放着可被 Linux 共享的动态链接库所在目录的名字（系统目录/lib 、/usr/lib 除外），多个目录名间以空白字符（空格、换行等）或冒号或逗号分隔。查看系统中的动态链接库配置文件的内容：\n$ cat /etc/ld.so.conf include /etc/ld.so.conf.d/*.conf 查看这个文件夹\n$ ls /etc/ld.so.conf.d fakeroot-x86_64-linux-gnu.conf x86_64-linux-gnu.conf i386-linux-gnu.conf zz_i386-biarch-compat.conf libc.conf 从上面的配置文件可以看出， 在系统的动态链接库配置中，包含了该动态库 /lib/i386-linux-gnu 、 /usr/lib/i386-linux-gnu 和 /lib/i686- linux-gnu 、 /usr/lib/i686-linux-gnu 四个目录。\n动态链接库管理命令 为了让新增加的动态链接库能够被系统共享，需要运行动态链接库的管理命令 ldconfig。 ldconfig 命令的作用是在系统的默认搜索路径，和动态链接库配置文件中所列出的目录里搜索动态链接库，创建动态链接装入程序需要的链接和缓存文件。搜索完毕后，将结果写入缓存文件 /etc/ld.so.cache 中，文件中保存的是已经排好序的动态链接库名字列表。ldconfig 命令行的用法如下：\nldconfig [-v|--verbose] [-n] [-N] [-X] [-f CONF] [-C CACHE] [-r ROOT] [-l] [-p|--print-cache] [-c FORMAT] [--format=FORMAT] [-V] [-?|--help|--usage] path... ldconfig 的选项含义：\n选项 含义 -v 此选项打印 ldconfig 的当前版本号，显示所扫描的每一个目录和动态链接库 -n 此选项处理命令行指定的目录，不对系统的默认目录 /lib 、 /usr/lib 进行扫描，也不对配置文件 /etc/ld.so.conf 中所指定的目录进行扫描 -N 此选项 ldconfig 不会重建缓存文件 -X 此选项 ldconfig 不更新链接 -f CONF 此选项使用用户指定的配置文件代替默认文件 /etc/ld.so.conf -C CACHE 此选项使用用户指定的缓存文件代替系统默认的缓存文件 /etc/ld.so.cache -r ROOT 此选项改变当前应用程序的根目录 -l 此选项用于手动链接单个动态链接库 -p \u0026ndash;print-cache 此选项用于打印出缓存文件中共享库的名字 如果想知道系统中有哪些动态链接库，可以使用 ldconfig 的 -p 选项来列出缓存文件中的动态链接库列表。\n使用 ldconfig 命令，默认情况下并不将扫描的结果输出。使用 -v 选项会将 ldconfig 在运行过程中扫描到的目录和共享库信息输出到终端，用户可以看到运行的结果和中间的信息。在执行 ldconfig 后，将刷新缓存文件 /etc/ld.so.cache 。\n当用户的目录并不在系统动态链接库配置文件 etc/ld.so.conf 中指定的时候，可以使用 ldconfig 命令显示指定要扫描的目录，将用户指定目录中的动态链接库放入系统中进行共享。命令格式的形式为：\n$ ldconfig 目录名 这个命令将 ldconfig 指定的目录名中的动态链接库放入系统的缓存 /etc/ld.so.cache 中，从而可以被系统共享使用。\n下面的代码将扫描当前用户的 lib 目录，将其中的动态链接库加入系统：\n$ ldconfig ~/lib 如果在运行上还命令后，再次运行 ldconfig 而没有加参数，系统会将 /lib 、 /usr/lib 及 etc/ld.so.conf 中指定目录中的动态库加入缓存，这时候上述代码中的动态链接库可能不被系统共享了。\n使用动态链接库 在编译程序时，使用动态链接库和静态链接库是一致的，使用 -l 库名 的方式，在生成可执行文件的时候会链接库文件。例如下面的命令将源文件 main.c 编译成可执行文件 test ，并链接库文件 libstr.a 或者 libstr.so：\n$ gcc -o test main.c -L./ -lstr -L 指定链接动态链接库的路径， -lstr 链接库函数 str 。但是运行 test 一般会出现如下问题：\n./test: error while loading shared libraries: libstr.so: cannot open shared object file: No such file or directory 这是由于程序运行时没有找到动态链接库造成的。程序编译时链接动态链接库和运行时使用动态链接库的概念是不同的，在运行时，程序链接的动态链接库需要在系统目录下才行。有以下几种办法可以解决此问题。\n将动态链接库的目录放到程序搜索路径中，可以将库的路径加到环境变量 LD_LIBRARY_PATH 中实现，例如： $ export LD_LIBRARY_PATH=/example/ex02: $LD_LIBRARY_PATH 将存放库文件 libstr.so 的路径 /example/ex02 加入到搜索路径中，再运行程序就没有之前的警告了。\n另一种方法是使用 ld-Linux.so.2 来加载程序，命令格式为： /lib/ld-Linux.so.2 --library-path 路径 程序名 加载 test 程序的命令为：\n/lib/ld-Linux.so.2 --library-path /example/ex02 test 如果系统的搜索路径下同时存在静态链接库和动态链接库，默认情况下会链接动态链接库。如果需要强制链接静态链接库， 需要加上 -static 选项，即上述的编译方法改为如下的方式：\n$ gcc -o test main.c -static -lstr 动态加载库 动态加载库和一般的动态链接库所不同的是，一般动态链接库在程序启动的时候就要寻找动态库，找到库函数；而动态加载库可以用程序的方法来控制什么时候加载。\n动态加载库主要有函数 dlopen() dlerror() dlsym() dlclose() 。\n打开动态库 dlopen() 函数 函数 dlopen() 按照用户指定的方式打开动态链接库，其中参数 filename 为动态链接库的文件名，flag为打开方式，一般为 RTLD_LASY， 函数的返回值为库的指针。其函数原型如下：\nvoid *dlopen(const char *filename, int flag); 例如，下面的代码使用 dlopen 打开当前目录下的动态库 libstr.so 。\nvoid *phandle = dlopen(\u0026#34;./libstr.so\u0026#34;, RTLD_LAZY); 获得函数指针 dlsym() 使用动态链接库的目的是调用其中的函数，完成特定的功能。函数 dlsym() 可以获得动态链接库中指定函数的指针，然后可以使用这个函数指针进行操作。函数 dlsym() 的原型如下：\nvoid *dlsym(void *handle, char *symbol); 其中参数 handle 为 dlopen() 打开动态库后返回的句柄，参数 symbol 为函数的名称，返回值为函数指针。\n使用动态加载库的一个例子 下面是一个动态加载库使用的例子。首先使用函数 dlopen() 来打开动态链接库，判断是否正常打开，可以使用函数 dlerror() 判断错误。如果上面的过程正常，使用函数 dlsym() 来获得动态链接库中的某个函数，可以使用这个函数来完成某些功能。其代码如下：\n#include \u0026lt;dlfcn.h\u0026gt; int main(void) { char src[] = \u0026#34;Hello AimerNeige!\u0026#34;; int (*pStrLenFun) (char *str); void *phandle = NULL; char *perr = NULL; phandle = dlopen(\u0026#34;./libstr.so\u0026#34;, RTLD_LAZY); if (!phandle) { printf(\u0026#34;Failed Load library!\\n\u0026#34;); } perr = dlerror(); if (perr != NULL) { printf(\u0026#34;%s\\n\u0026#34;, perr); return 0; } pStrLenFun = dlsym(phandle, \u0026#34;StrLen\u0026#34;); perr = dlerror(); if (perr != NULL) { printf(\u0026#34;%s\\n\u0026#34;, perr); return 0; } printf(\u0026#34;The string length is: %d\\n\u0026#34;, pStrLenFun(src)); dlclose(phandle); return 0; } 编译上述文件的时候需要链接动态库 libdl.so，使用如下的命令将上述代码编译成可执行文件 testdl。命令将 main.c 编译成可执行文件 testdl，并链接动态链接库 libdl.so。\n$ gcc -o testdl main.c libstr.so -ldl 执行文件 testdl 的结果为：\n$ ./testdl string length is: 18 GCC 常用选项 -DMACRO 选项 定义一个宏，在多种预定义的程序中会经常使用。如下代码根据系统是否定义 Linux 宏来执行不同代码。使用 -D 选项可以选择不同的代码段，例如 -DOS_LINUX 选项将执行代码段（1）。\n#ifdef OS_LINUX ...代码段（1） #else ...代码段（2） #endif -Idir 将头文件的搜索路径扩大，包含 dir 目录。 -Ldir 将链接时使用的链接库搜索路径扩大，包含 dir 目录。gcc 都会优先使用共享程序库。 -static 仅选用静态程序库进行链接，如果一个目录中静态库和动态库都存在，则仅选用静态库。 -g 包括调试信息。 -On 优化程序，程序优化后执行速度会更快，程序的占用空间会更小。通常 gcc 会进行很小的优化，优化的级别可以选择，即 n。最常用的优化级别是 2。 -Wall 打开所有的 gcc 能够提供的、常用的警告信息。 GCC 常用选项及含义 -Wall 选项集合 GCC 的警告选项 含义 -Wchar-subscripts 这个选项针对数组的下标值，如果下标值是 char 类型的则给出警告。因为在一些平台上， char 类型的变量可能定义为 signed char, 是一个符号类型的整数，所以 char 类型的变量做下标时，当下标的值为负数时可能造成内存溢出。 -Wcomment 这个选项针对代码中的注释，如果出现不合适的注释格式的时候会出现警告。例如在 /*...*/ 中间出现 /*，或者在 //... 类型的注释末尾出现符号 \\ 的时候， GCC 给出警告 -Wformat 这个选项针对输入输出的格式，检查 printf 和 scanf 等格式化输入输出函数的格式字符串与参数类型的匹配情况，如果发现不匹配则发出警告 -Wimplicit 这个选项针对函数的声明，这个选项是选项 -Wimplicit-int 和选项 -Wimplicit-function-declaration 两个选项的集合。第一个选项在声明函数时如果没有指定返回值会给出警告；第二个参数如果在声明前调用函数会给出警告 -Wmissing-braces 这个选项针对结构类型或者数组初始化时的不合适格式。例如， int array[2][2] = {0, 0, 1, 1}; -Wm1ssmg-braces 由于初始化的表达式没有充分用 {} 括起来， GCC 会给出警告，应该采用下面的定义方法：int array[2][2] = { {0, 0}, {1, 1} }; -Wparentheses 这个选项针对多种优先级的操作符在一起或者代码结构难以看明白的操作，如果没有将操作进行明晰地分离， GCC 会给出警告。例如，`if (a \u0026amp;\u0026amp; b -Wsequenve-point 这个选项针对顺序点，如果在代码中使用了有可能造成顺序点变化的语句， GCC 会给出警告。例如，代码 i = i++ 在不同的平台上 i 值的结果是不同的，如果使用了这样的代码，GCC 会给出警告 -Wswitch 这个选项针对 switch 语句，如果一个 switch 语句中没有 default 条件，GCC 会给出警告信息 -Wunused 这个选项针对代码中没有用到的变量、函数、值、转跳点等， 它是 -Wunused-function 、 -Wunused-label 、 -Wunused-variable 、 -Wunosed-value 选项的集合。 -Wunused-function 选项警告代码中存在没有使用的静态函数，或者只定义却没有实现的静态函数； -Wunused-label 选项警告代码中存在定义了却没有使用，或者使用了却没有定义的标签； -Wunused-variable 选项警告代码中存在定义了却没有使用的局部变量； -Wunused-value 选项警告代码中计算表达式的结果没有使用 -Wunused-parameter 这个选项针对函数参数，如果一个函数的参数在函数实现中没有用到， GCC 会给出警告信息 -Wuninitialized 这个选项针对没有初始化变量的使用，如果一个局部变量在使用之前没有初始化， GCC 会给出警告信息 非 -Wall 警告选项 GCC 的警告选项 含义 -Wflot-equal 这个选项针对浮点值相等的判定，由千浮点值的确切值难以得知，所以如果浮点值出现在相等判定的表达式中， GCC 会给出警告。浮点值的相等判定可以用浮点值的差与某个小值比较判定是否相等 -Wshadow 这个选项用千局部变量作用域内的同名变量，如果局部变量的作用域-Wshadow 范围内有其他同名变量时，局部变量会遮蔽全局变量，这时 GCC 会给出警告信息 -Wbad-functuin-cast 这个选项针对函数的返回值，当函数的返回值赋给不匹配的类型时，GCC 会给出警告信息 -Wsign-compare 这个选项针对有符号数和无符号数的比较，由于无符号数的优先级比有符号数的优先级高，二者进行比较运算的时候，会先将有符号数转换为无符号数。在负的有符号数和无符号数进行比较的时候，容易出现错误 -Waggregate-return 这个选项针对结构类型的函数返回值，如果函数的返回值为结构、联合等类型时， GCC 会给出警告信息 -Wmultichar 这个选项针对字符类型变量的错误赋值，当使用类似 char c = 'test' 这样的代码时， GCC 会给出警告 -Wunreachable-code 这个选项针对冗余代码，如果代码中有不能到达的代码时， GCC 会给出警告信息 其他 GCC 的警告选项 含义 -Wtraditional 选项 traditional 试图支待传统 C 编译器的某些方面 ANSI 兼容 GCC 的警告选项 含义 -ansi 与 ansi 的 C 语言兼容 -pedantic 允许发出 ANSI/ISO C 标准所列出的所有警告 -pedantic-errors 允许发出 ANSI/ISO C 标准所列出的所有错误 编译检查 GCC 的警告选项 含义 -fsynatax-only 仅进行编译检查而不实际编译程序 在编写代码的时候，不好的习惯会造成程序执行过程中发生错误。在一个比较大的项目中， 当程序运行起未后再查找这些错误是很困难的。因此一种好的习惯是使用编译选项将代码的警告信息显示出来，并对代码进行改正。例如，打开编译选项 -Wall 和 -W 来显示所有的警告信息，甚至更严格一些，打开 -Werror 将编译时的警告信息作为错误信息未处理，中断编译。\n","permalink":"https://aimerneige.com/zh/post/tool/gcc-basic/","summary":"GCC 简介 GCC 是 Linux 下的编译工具集，是 GNU Compiler Collection 的缩写,包含 gcc 、 g++ 等编译器。这个工具集不仅包含编译器，还包含其他工具集，例如 ar 、 nm 等。\nGCC 工具集不仅能编译 C/C++ 语言，其他例如 Objective-C 、 Pascal 、 Fortran 、 Java 、 Ada 等语言均能进行编译。\nGCC 在可以根据不同的硬件平台进行编译，即能进行交叉编译，在 A 平台上编译 B 平台的程序，支持常见的 X86 、 ARM 、 PowerPC 、 mips 等，以及 Linux 、 Windows 等软件平台。\nGCC 的 C 编译器 是 gcc，其命令格式为 :\nUsage: gcc [options] file... GCC 下默认文扩展名的含义：\n文件扩展名 GCC 所理解的含义 *.c 该类文件为 C 语言的源文件 *.","title":"GCC 基础"},{"content":" 使用 Nginx 搭建静态网页服务本身是一件非常简单的事，但是我之前在 CSDN 找了几篇教程，弄了一下午也没弄好（不愧是屎山淘金），学了一段时间后端和 Linux 后，我大概只用了五分钟就弄好了，这里写一篇文章来帮助一下小白。\n阅读须知 在阅读本文章前，你需要准备以下内容\n掌握基础的 Linux 命令行操作 （本文章将介绍如何在 Linux 服务器上部署静态网页，需要进行终端操作，因此你必须掌握命令行的使用。如果你打算使用 Windows ，请查阅其他文章。） 拥有一台 Linux 服务器 （可以购买 VPS 也可以使用 虚拟机 本文章以 VPS 为例，并购置了域名 （域名非必须） ） 拥有一个静态网站的源码 （如果仅仅作为学习目的，你可以写一个简单的 HTML 文件，这里以使用 hexo 生成的静态网站为例。） 知道 Nginx 是什么，有什么用 （不需要掌握 Nginx） 不同 Linux 发行版下命令会有所区别，本文章以 Ubuntu20.04 为例\n准备服务器 如果你已经有了一台服务器并安装好了 Nginx ，你可以直接跳过这一部分，但是如果你的服务器是新的，没有经过任何配置，请参阅以下内容进行配置。\n升级系统 sudo apt update \u0026amp;\u0026amp; sudo apt upgrade 安装 Nginx sudo apt install nginx 启动 Nginx sudo systemctl start nginx # 开机自动启动 sudo systemctl enable nginx 测试服务 直接在浏览器访问你服务器的 ip，如果你部署了 DNS 服务的话，你也可以直接使用域名。如果哦看到 Nginx 的欢迎界面，服务器准备成功！\n将网站源码发送到服务器 这一步可以有很多的选择，你可以通过 github 来 clone，也可以直接使用一些 ftp 工具。这里演示使用 tar 打包并使用 scp 上传。\n打包压缩源文件 当然，你可以使用其他指令打包压缩或者不压缩，这里使用 xz 压缩以节省网络流量。\ntar -Jcv -f site.tar.xz public/ 将压缩包上传到服务器 scp site.tar.xz root@test.aimerneige.com:~/ 在服务器解压压缩包 通常，我们会将静态网站的源文件放置在 /var/www/ 这个目录下，但是你也可以放置在家目录或其他你喜欢的位置下。\ntar -Jxv -f site.tar.xz -C ./ sudo mv public/ /var/www/blog 配置 Nginx 本文章并不会介绍如何使用 Nginx ，并且阅读本文章并不需要掌握 Nginx，你只需要了解 Nginx 有什么用即可。因为如果只是部署一个简单的静态网页，只需要简单修改默认配置即可。如果你想了解更多关于 Nginx 的内容请查阅其他文章。\n修改配置 直接使用 vim 修改默认的配置文件即可。 如果你没有安装 vim ，执行 sudo apt install vim 来安装它，当然你也可以使用自己喜欢的编辑器。\nsudo vim /etc/nginx/sites-available/default 找到这一行：\nroot /var/www/html; 修改为源文件所在目录：\nroot /var/www/blog; 如果你需要配置域名，找到这一行：\nserver_name _; 将 _ 修改为你的域名。\n检查配置是否正确 sudo nginx -t 如果得到类似如下的输出，则证明配置文件没有错误。\nnginx: the configuration file /etc/nginx/nginx.conf syntax is ok nginx: configuration file /etc/nginx/nginx.conf test is successful 如果你的配置文件出现了问题，请重新修改。\n重启 Nginx sudo nginx -s reload 检查站点 重新访问你的服务器 ip 或域名，检查服务是否成功部署。\n后记 为什么 Nginx 的配置文件要这样改 Nginx 的默认配置文件位于 /etc/nginx/ 目录下，主配置文件为 nginx.conf\n我们首先看一下默认的主配置文件\nuser www-data; worker_processes auto; pid /run/nginx.pid; include /etc/nginx/modules-enabled/*.conf; events { worker_connections 768; # multi_accept on; } http { ## # Basic Settings ## sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; # server_tokens off; # server_names_hash_bucket_size 64; # server_name_in_redirect off; include /etc/nginx/mime.types; default_type application/octet-stream; ## # SSL Settings ## ssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3; # Dropping SSLv3, ref: POODLE ssl_prefer_server_ciphers on; ## # Logging Settings ## access_log /var/log/nginx/access.log; error_log /var/log/nginx/error.log; ## # Gzip Settings ## gzip on; # gzip_vary on; # gzip_proxied any; # gzip_comp_level 6; # gzip_buffers 16 8k; # gzip_http_version 1.1; # gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript; ## # Virtual Host Configs ## include /etc/nginx/conf.d/*.conf; include /etc/nginx/sites-enabled/*; } #mail { # # See sample authentication script at: # # http://wiki.nginx.org/ImapAuthenticateWithApachePhpScript # # # auth_http localhost/auth.php; # # pop3_capabilities \u0026#34;TOP\u0026#34; \u0026#34;USER\u0026#34;; # # imap_capabilities \u0026#34;IMAP4rev1\u0026#34; \u0026#34;UIDPLUS\u0026#34;; # # server { # listen localhost:110; # protocol pop3; # proxy on; # } # # server { # listen localhost:143; # protocol imap; # proxy on; # } #} 去掉全部的注释\nuser www-data; worker_processes auto; pid /run/nginx.pid; include /etc/nginx/modules-enabled/*.conf; events { worker_connections 768; } http { sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; include /etc/nginx/mime.types; default_type application/octet-stream; ssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3; # Dropping SSLv3, ref: POODLE ssl_prefer_server_ciphers on; access_log /var/log/nginx/access.log; error_log /var/log/nginx/error.log; gzip on; xml application/xml application/xml+rss text/javascript; include /etc/nginx/conf.d/*.conf; include /etc/nginx/sites-enabled/*; } 默认的服务为什么可以跑呢？注意这一行：\ninclude /etc/nginx/sites-enabled/*; 切换到 /etc/nginx/sites-enabled/ 目录下，并查看文件\ncd /etc/nginx/sites-enabled/ ls 我们会发现只有一个 default 文件\n查看它的内容：\n## # You should look at the following URL\u0026#39;s in order to grasp a solid understanding # of Nginx configuration files in order to fully unleash the power of Nginx. # https://www.nginx.com/resources/wiki/start/ # https://www.nginx.com/resources/wiki/start/topics/tutorials/config_pitfalls/ # https://wiki.debian.org/Nginx/DirectoryStructure # # In most cases, administrators will remove this file from sites-enabled/ and # leave it as reference inside of sites-available where it will continue to be # updated by the nginx packaging team. # # This file will automatically load configuration files provided by other # applications, such as Drupal or Wordpress. These applications will be made # available underneath a path with that package name, such as /drupal8. # # Please see /usr/share/doc/nginx-doc/examples/ for more detailed examples. ## # Default server configuration # server { listen 80 default_server; listen [::]:80 default_server; # SSL configuration # # listen 443 ssl default_server; # listen [::]:443 ssl default_server; # # Note: You should disable gzip for SSL traffic. # See: https://bugs.debian.org/773332 # # Read up on ssl_ciphers to ensure a secure configuration. # See: https://bugs.debian.org/765782 # # Self signed certs generated by the ssl-cert package # Don\u0026#39;t use them in a production server! # # include snippets/snakeoil.conf; root /var/www/html; # Add index.php to the list if you are using PHP index index.html index.htm index.nginx-debian.html; # index test.json; server_name _; location / { # First attempt to serve request as file, then # as directory, then fall back to displaying a 404. try_files $uri $uri/ =404; } # pass PHP scripts to FastCGI server # #location ~ \\.php$ { # include snippets/fastcgi-php.conf; # # # With php-fpm (or other unix sockets): # fastcgi_pass unix:/var/run/php/php7.4-fpm.sock; # # With php-cgi (or other tcp sockets): # fastcgi_pass 127.0.0.1:9000; #} # deny access to .htaccess files, if Apache\u0026#39;s document root # concurs with nginx\u0026#39;s one # #location ~ /\\.ht { # deny all; #} } # Virtual Host configuration for example.com # # You can move that to a different file under sites-available/ and symlink that # to sites-enabled/ to enable it. # #server { # listen 80; # listen [::]:80; # # server_name example.com; # # root /var/www/example.com; # index index.html; # # location / { # try_files $uri $uri/ =404; # } #} 去掉注释：\nserver { listen 80 default_server; listen [::]:80 default_server; root /var/www/html; index index.html index.htm index.nginx-debian.html; server_name _; location / { try_files $uri $uri/ =404; } } 我相信哪怕没有学习过 Nginx 应该也能理解部分含义。\n接下来我们看一下 /var/www/html 这个目录\ncd /var/www/html ls 只有一个 index.nginx-debian.html 文件，正是欢迎界面的源代码。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Welcome to nginx!\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; body { width: 48em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Welcome to Nginx!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;If you see this page, the nginx web server is successfully installed and working. Further configuration is required.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;For online documentation and support please refer to \u0026lt;a href=\u0026#34;http://nginx.org/\u0026#34;\u0026gt;nginx.org\u0026lt;/a\u0026gt;.\u0026lt;br/\u0026gt; Commercial support is available at \u0026lt;a href=\u0026#34;http://nginx.com/\u0026#34;\u0026gt;nginx.com\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Thank you for using nginx.\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 回到 /etc/nginx/sites-enabled/ 目录下，我想你应该明白应该修改什么了吧。\n","permalink":"https://aimerneige.com/zh/post/devops/deploy-web-page-with-nginx/","summary":"使用 Nginx 搭建静态网页服务本身是一件非常简单的事，但是我之前在 CSDN 找了几篇教程，弄了一下午也没弄好（不愧是屎山淘金），学了一段时间后端和 Linux 后，我大概只用了五分钟就弄好了，这里写一篇文章来帮助一下小白。\n阅读须知 在阅读本文章前，你需要准备以下内容\n掌握基础的 Linux 命令行操作 （本文章将介绍如何在 Linux 服务器上部署静态网页，需要进行终端操作，因此你必须掌握命令行的使用。如果你打算使用 Windows ，请查阅其他文章。） 拥有一台 Linux 服务器 （可以购买 VPS 也可以使用 虚拟机 本文章以 VPS 为例，并购置了域名 （域名非必须） ） 拥有一个静态网站的源码 （如果仅仅作为学习目的，你可以写一个简单的 HTML 文件，这里以使用 hexo 生成的静态网站为例。） 知道 Nginx 是什么，有什么用 （不需要掌握 Nginx） 不同 Linux 发行版下命令会有所区别，本文章以 Ubuntu20.04 为例\n准备服务器 如果你已经有了一台服务器并安装好了 Nginx ，你可以直接跳过这一部分，但是如果你的服务器是新的，没有经过任何配置，请参阅以下内容进行配置。\n升级系统 sudo apt update \u0026amp;\u0026amp; sudo apt upgrade 安装 Nginx sudo apt install nginx 启动 Nginx sudo systemctl start nginx # 开机自动启动 sudo systemctl enable nginx 测试服务 直接在浏览器访问你服务器的 ip，如果你部署了 DNS 服务的话，你也可以直接使用域名。如果哦看到 Nginx 的欢迎界面，服务器准备成功！","title":"使用 Nginx 搭建静态网页服务"},{"content":" 本文章项目地址 https://github.com/AimerNeige/Tutorial.git\n计算机使用技巧 如果你是一个几乎没有接触过电脑但是却打算入门计算机专业，这篇文章将为你介绍一些基本的计算机使用技巧。\n主要介绍 Windows10 的一些使用技巧，如果你是 mac 用户，请自行查阅其他文章，但是如果你是 Linux 用户，我觉得你应该不需要看我的文章。\n杀毒软件 或许你会在较旧的电脑上见到诸如360 安全卫士，金山毒霸，电脑管家等杀毒软件，受其影响，你或许也会在电脑上安装这些软件，但是，对于计算机专业来说，这些软件不仅无用而且会给你的学习带来很多麻烦。请 务必 立即 删除它们。\n但是，没有杀毒软件的话，电脑中毒怎么办啊？\n如果你的电脑是刚到手的笔记本，我相信你的预装系统是 Windows10。 而 windows 本身会预装 Windows Defender ，对于一般的病毒，Windows Defender 完全可以保护你的电脑，而且如果使用习惯良好，不下载使用来源不明的文件的话，即使没有任何杀毒软件也是可以的。但是你非要有双保险才放心，一定要安装杀毒软件的话，我推荐 火绒杀毒 https://www.huorong.cn/ 。这款软件的个人版完全免费而且没用任何广告弹窗。\n删了它们我怎么清理电脑垃圾啊？\n在旧电脑上用的硬盘是机械硬盘，而机械硬盘的磁盘碎片会影响电脑系统运行速度，在旧电脑上清理垃圾确实有用且会提升电脑运行速度，但是现在的电脑用的都是固态硬盘，这些磁盘垃圾并不会影响电脑性能，不会影响系统的运行速度，最多只是占一些存储空间，如果你非要清理的话，我推荐你使用 CCleaner https://www.ccleaner.com/。\n没有软件管家我不会下载软件了怎么办？\n要养成去官网下载软件的好习惯，比如我们想要安装 QQ 就使用搜索引擎搜索 QQ 的官网，找到 QQ 的官网 http://im.qq.com/ ，然后在官网下载安装包。类是地，我们同样可以在 Visual Studio Code 的官网 https://code.visualstudio.com/ 上下载 Visual Studio Code 的安装包。如果一个软件没有官网，你也可以在一些受信任的网站上下载它，不过大部分软件都会有官网的，除非你在下载破解软件或者其他上古软件。\n没有电脑管家我如何管理系统自启动啊？\n禁用开机自启动：\n启动任务管理器，点击 启动 找到想要禁用的自启项，右击，选择禁用。\n设置开机自启动：\n按住 Win 键（左下角有 windows 徽标的按键）然后按 R, 在弹出的运行框中输入 shell:startup 将软件的 快捷方式 放在这个目录下即可。\n我想要那个网速显示的悬浮窗！！\n这个软件可能会帮到你 https://github.com/zhongyang219/TrafficMonitor。\n没有加速球电脑会不会卡啊？\n首先，如果你的电脑配置不是很差的话，写代码基本上不会发生卡顿现象，加速球的用处并不大，相反的，它还会占用系统资源，反而有可能导致电脑卡顿。\n你说的有道理，但是我就是想点那个加速球怎么办啊？\n慢慢习惯吧。\n文章好棒，但是我就是只要不点加速球，不发射小火箭就浑身难受，习惯不了啊怎么办？\n，，，，保安呢？保安在那里啊！这里有人捣乱，砸场子呢！！！\n浏览器 浏览器首推 Chrome 你可以在 Chrome 的官网 https://www.google.com/chrome/ 快速下载它，同时，我也推荐以下几款浏览器：\nChromium https://www.chromium.org/ Chrome 的开源版。\nCentBrowser 百分浏览器 http://www.centbrowser.com/ Chromium 的一个分支版本，有一些额外的小功能。\n当然，如果你无法访问谷歌的话，上面这几款浏览器没有同步还是很难受的，你同样可以选择这几款：\nFirefox https://www.mozilla.org/zh-CN/firefox/\n注意不要下载国内定制版 https://www.firefox.com.cn/ FireFox (AD Pro Plus For China User)\nEdge https://www.microsoft.com/zh-cn/edge 注意是新版 Edge 不是 Win10 自带的那个。\n此外还有 Firefox Dev 版本 https://www.mozilla.org/zh-CN/firefox/developer/ 可以用来调试 web 程序。\n至于其他浏览器，诸如 QQ 浏览器，猎豹急速浏览器，360 安全浏览器之类的软件请立即卸载。\n更多 大概就说这么多吧，只要不安装国产的垃圾杀毒软件和浏览器，你的电脑使用起来绝对会很舒服。\n本仓库保持更新，想到其他内容之后会添加。\n如果你有好的内容欢迎 pr。\nhttps://github.com/AimerNeige/Tutorial.git\n","permalink":"https://aimerneige.com/zh/post/others/tips-using-windows10/","summary":"本文章项目地址 https://github.com/AimerNeige/Tutorial.git\n计算机使用技巧 如果你是一个几乎没有接触过电脑但是却打算入门计算机专业，这篇文章将为你介绍一些基本的计算机使用技巧。\n主要介绍 Windows10 的一些使用技巧，如果你是 mac 用户，请自行查阅其他文章，但是如果你是 Linux 用户，我觉得你应该不需要看我的文章。\n杀毒软件 或许你会在较旧的电脑上见到诸如360 安全卫士，金山毒霸，电脑管家等杀毒软件，受其影响，你或许也会在电脑上安装这些软件，但是，对于计算机专业来说，这些软件不仅无用而且会给你的学习带来很多麻烦。请 务必 立即 删除它们。\n但是，没有杀毒软件的话，电脑中毒怎么办啊？\n如果你的电脑是刚到手的笔记本，我相信你的预装系统是 Windows10。 而 windows 本身会预装 Windows Defender ，对于一般的病毒，Windows Defender 完全可以保护你的电脑，而且如果使用习惯良好，不下载使用来源不明的文件的话，即使没有任何杀毒软件也是可以的。但是你非要有双保险才放心，一定要安装杀毒软件的话，我推荐 火绒杀毒 https://www.huorong.cn/ 。这款软件的个人版完全免费而且没用任何广告弹窗。\n删了它们我怎么清理电脑垃圾啊？\n在旧电脑上用的硬盘是机械硬盘，而机械硬盘的磁盘碎片会影响电脑系统运行速度，在旧电脑上清理垃圾确实有用且会提升电脑运行速度，但是现在的电脑用的都是固态硬盘，这些磁盘垃圾并不会影响电脑性能，不会影响系统的运行速度，最多只是占一些存储空间，如果你非要清理的话，我推荐你使用 CCleaner https://www.ccleaner.com/。\n没有软件管家我不会下载软件了怎么办？\n要养成去官网下载软件的好习惯，比如我们想要安装 QQ 就使用搜索引擎搜索 QQ 的官网，找到 QQ 的官网 http://im.qq.com/ ，然后在官网下载安装包。类是地，我们同样可以在 Visual Studio Code 的官网 https://code.visualstudio.com/ 上下载 Visual Studio Code 的安装包。如果一个软件没有官网，你也可以在一些受信任的网站上下载它，不过大部分软件都会有官网的，除非你在下载破解软件或者其他上古软件。\n没有电脑管家我如何管理系统自启动啊？\n禁用开机自启动：\n启动任务管理器，点击 启动 找到想要禁用的自启项，右击，选择禁用。\n设置开机自启动：\n按住 Win 键（左下角有 windows 徽标的按键）然后按 R, 在弹出的运行框中输入 shell:startup 将软件的 快捷方式 放在这个目录下即可。","title":"写给小白的 win10 使用技巧"},{"content":"官方文档\n较常用的检索限制 项目名称\nin:name \u0026lt;keyword\u0026gt; 项目 README\nin:readme \u0026lt;keyword\u0026gt; 项目描述\nin:description \u0026lt;keyword\u0026gt; 语言\nlanguage: java star 数\nstars:\u0026gt;1000 fork 数\nforks:\u0026gt;500 更新时间\npushed:\u0026gt;2020-08-01 使用示例\nin:name marp in:description theme stars:\u0026gt;5 pushed:\u0026gt;2020-01-01 参考链接:\nhttps://www.youtube.com/watch?v=Uj6WWAqg0NY\n","permalink":"https://aimerneige.com/zh/post/others/use-github-gracefully/","summary":"官方文档\n较常用的检索限制 项目名称\nin:name \u0026lt;keyword\u0026gt; 项目 README\nin:readme \u0026lt;keyword\u0026gt; 项目描述\nin:description \u0026lt;keyword\u0026gt; 语言\nlanguage: java star 数\nstars:\u0026gt;1000 fork 数\nforks:\u0026gt;500 更新时间\npushed:\u0026gt;2020-08-01 使用示例\nin:name marp in:description theme stars:\u0026gt;5 pushed:\u0026gt;2020-01-01 参考链接:\nhttps://www.youtube.com/watch?v=Uj6WWAqg0NY","title":"优雅地使用 GitHub"},{"content":"首先来看下 w3schools 的解释：\nExample Check if the number 5 is an integer:\nx = isinstance(5, int) Definition and Usage The isinstance() function returns True if the specified object is of the specified type, otherwise False.\nIf the type parameter is a tuple, this function will return True if the object is one of the types in the tuple.\nSyntax isinstance(object, type)\nParameter Values Parameter Description object Required. An object. type A type or a class, or a tuple of types and/or classes More Examples Example Check if \u0026ldquo;Hello\u0026rdquo; is one of the types described in the type parameter:\nx = isinstance(\u0026#34;Hello\u0026#34;, (float, int, str, list, dict, tuple)) Example Check if y is an instance of myObj:\nclass myObj: name = \u0026#34;John\u0026#34; y = myObj() x = isinstance(y, myObj) Related Pages The issubclass() function, to check if an object is a subclass of another object.\n来源： https://www.w3schools.com/python/ref_func_isinstance.asp\n帮助那些英语不好的 python 学习者翻译一下：\n示例 检查数字 5 是否是一个整数。\nx = isinstance(5, int) 定义和用法 如果给定的对象是一个已知的对象类型，函数 isinstance() 返回 True ，否则返回False 。\n如果参数 type 是元组的话，当对象是元组中的一个类型时，这个函数会返回 True 。\n语法 isinstance(object, type) 参数 参数 描述 object 必须。 一个示例对象。 type 基本类型或者类，或是由他们组成的元组。 更多示例 示例 检查 \u0026ldquo;Hello\u0026rdquo; 是否是参数表中描述的类型之一。\nx = isinstance(\u0026#34;Hello\u0026#34;, (float, int, str, list, dict, tuple)) 示例 检查 y 是否是 myObj 的实例。\nclass myObj: name = \u0026#34;John\u0026#34; y = myObj() x = isinstance(y, myObj) 相关内容： issubclass() 函数用来检查一个对象是否是另一个对象的子类。\n接下来看一下菜鸟教程的解释\nPython isinstance() 函数 描述 isinstance() 函数来判断一个对象是否是一个已知的类型，类似 type()。\nisinstance() 与 type() 区别：\ntype() 不会认为子类是一种父类类型，不考虑继承关系。 isinstance() 会认为子类是一种父类类型，考虑继承关系。 如果要判断两个类型是否相同推荐使用 isinstance()。\n语法 以下是 isinstance() 方法的语法:\nisinstance(object, classinfo) 参数 object \u0026ndash; 实例对象。 classinfo \u0026ndash; 可以是直接或间接类名、基本类型或者由它们组成的元组。 返回值 如果对象的类型与参数二的类型（classinfo）相同则返回 True，否则返回 False。。\n实例 以下展示了使用 isinstance 函数的实例：\n\u0026gt;\u0026gt;\u0026gt; a = 2 \u0026gt;\u0026gt;\u0026gt; isinstance (a,int) True \u0026gt;\u0026gt;\u0026gt; isinstance (a,str) False \u0026gt;\u0026gt;\u0026gt; isinstance (a,(str,int,list)) # 是元组中的一个返回 True True type() 与 isinstance()区别： class A: pass class B(A): pass isinstance(A(), A) # returns True type(A()) == A # returns True isinstance(B(), A) # returns True type(B()) == A # returns False 来源： https://aimerneige.com/2020/05/29/Daily-Python-Tips-isinstance/\n更多示例：\n# 检查传入的参数是否符合要求 def log(val:\u0026#39;str\u0026#39;): assert isinstance(val, str), \u0026#39;val is not str\u0026#39; print(val） ","permalink":"https://aimerneige.com/zh/post/python/daily-python-tips-isinstance/","summary":"首先来看下 w3schools 的解释：\nExample Check if the number 5 is an integer:\nx = isinstance(5, int) Definition and Usage The isinstance() function returns True if the specified object is of the specified type, otherwise False.\nIf the type parameter is a tuple, this function will return True if the object is one of the types in the tuple.\nSyntax isinstance(object, type)\nParameter Values Parameter Description object Required. An object. type A type or a class, or a tuple of types and/or classes More Examples Example Check if \u0026ldquo;Hello\u0026rdquo; is one of the types described in the type parameter:","title":"每天一个 Python 小知识 isinstance"},{"content":"首先来看下 w3schools 的解释\nExample Test if a condition returns True:\nx = \u0026#34;hello\u0026#34; #if condition returns True, then nothing happens: assert x == \u0026#34;hello\u0026#34; #if condition returns False, AssertionError is raised: assert x == \u0026#34;goodbye\u0026#34; Definition and Usage The assert keyword is used when debugging code.\nThe assert keyword lets you test if a condition in your code returns True, if not, the program will raise an AssertionError.\nYou can write a message to be written if the code returns False, check the example below.\nMore Examples Example Write a message if the condition is False:\nx = \u0026#34;hello\u0026#34; #if condition returns False, AssertionError is raised: assert x == \u0026#34;goodbye\u0026#34;, \u0026#34;x should be \u0026#39;hello\u0026#39;\u0026#34; 来源： https://www.w3schools.com/python/ref_keyword_assert.asp\n帮助那些英语不好的 python 学习者翻译一下\n示例 测试一个条件的返回值是否为真\nx = \u0026#34;hello\u0026#34; #if condition returns True, then nothing happens: assert x == \u0026#34;hello\u0026#34; #if condition returns False, AssertionError is raised: assert x == \u0026#34;goodbye\u0026#34; 定义和用法： 当调试代码的时候，会使用 assert 关键字。\nassert 关键字可以允许你测试你代码中的一个条件判断的返回值是否返回 True，如果不是的话，程序将会抛出一个AssertionError 。\n你可以写一条用来在条件返回假时打印的信息，测试下面的示例代码：\n更多示例 示例 如果条件为假，输出一条信息\nx = \u0026#34;hello\u0026#34; #if condition returns False, AssertionError is raised: assert x == \u0026#34;goodbye\u0026#34;, \u0026#34;x should be \u0026#39;hello\u0026#39;\u0026#34; 然后我们看下菜鸟教程的解释：\nPython3 assert（断言） Python assert（断言）用于判断一个表达式，在表达式条件为 false 的时候触发异常。\n断言可以在条件不满足程序运行的情况下直接返回错误，而不必等待程序运行后出现崩溃的情况，例如我们的代码只能在 Linux 系统下运行，可以先判断当前系统是否符合条件。\n语法格式如下：\nassert expression 等价于：\nif not expression: raise AssertionError assert 后面也可以紧跟参数:\nassert expression [, arguments] 等价于：\nif not expression: raise AssertionError(arguments) 以下为 assert 使用实例：\n\u0026gt;\u0026gt;\u0026gt; assert True # 条件为 true 正常执行 \u0026gt;\u0026gt;\u0026gt; assert False # 条件为 false 触发异常 Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; AssertionError \u0026gt;\u0026gt;\u0026gt; assert 1==1 # 条件为 true 正常执行 \u0026gt;\u0026gt;\u0026gt; assert 1==2 # 条件为 false 触发异常 Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; AssertionError \u0026gt;\u0026gt;\u0026gt; assert 1==2, \u0026#39;1 不等于 2\u0026#39; Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; AssertionError: 1 不等于 2 \u0026gt;\u0026gt;\u0026gt; 以下实例判断当前系统是否为 Linux，如果不满足条件则直接触发异常，不必执行接下来的代码：\n实例 import sys assert (\u0026#39;linux\u0026#39; in sys.platform), \u0026#34;该代码只能在 Linux 下执行\u0026#34; # 接下来要执行的代码 来源： https://www.runoob.com/python3/python3-assert.html\n更多示例：\n# 检查传入的参数是否符合要求 def log(val:\u0026#39;str\u0026#39;): assert isinstance(val, str), \u0026#39;val is not str\u0026#39; print(val） ","permalink":"https://aimerneige.com/zh/post/python/daily-python-tips-assert/","summary":"首先来看下 w3schools 的解释\nExample Test if a condition returns True:\nx = \u0026#34;hello\u0026#34; #if condition returns True, then nothing happens: assert x == \u0026#34;hello\u0026#34; #if condition returns False, AssertionError is raised: assert x == \u0026#34;goodbye\u0026#34; Definition and Usage The assert keyword is used when debugging code.\nThe assert keyword lets you test if a condition in your code returns True, if not, the program will raise an AssertionError.\nYou can write a message to be written if the code returns False, check the example below.","title":"每天一个 Python 小知识 assert"},{"content":"在平时使用 markdown 的时候，图片一般是一个痛点，在本地引用图片后转到其他平台就有可能失效，尤其是上传到自己的博客的时候就很麻烦，在线图片可以解决这个问题，但是手动上传也是一件麻烦事，不过，已经有一些好心的程序员写了一个软件来解决这个问题，这里我推荐 PicGo 这款应用。\n这款应用完全开源、免费，支持跨平台特性。\nGitHub 主页\n官方文档\n软件的配置也十分简单，按照官方的教程新建一个 GitHub 仓库并连接软件就好了。\n官方的文档就很棒了，没必要提供更详细的教程。（话说这篇文章也太水了）\n","permalink":"https://aimerneige.com/zh/post/others/picgo/","summary":"在平时使用 markdown 的时候，图片一般是一个痛点，在本地引用图片后转到其他平台就有可能失效，尤其是上传到自己的博客的时候就很麻烦，在线图片可以解决这个问题，但是手动上传也是一件麻烦事，不过，已经有一些好心的程序员写了一个软件来解决这个问题，这里我推荐 PicGo 这款应用。\n这款应用完全开源、免费，支持跨平台特性。\nGitHub 主页\n官方文档\n软件的配置也十分简单，按照官方的教程新建一个 GitHub 仓库并连接软件就好了。\n官方的文档就很棒了，没必要提供更详细的教程。（话说这篇文章也太水了）","title":"使用 PicGo 搭建便捷的图片上传服务"},{"content":"介绍 使用安卓手机阅读一些漫画的时候，因为屏幕较小，查看文字的时候需要放大，很麻烦。博主虽然有一个 iPad4，屏幕够大，但是把这么多图片文件发送到 iPad 上面十分的麻烦，一天，偶然看到了一个 pdf 格式的漫画，在 iPad 上面的阅读体验十分棒，于是博主就打算写一个程序来将大量的漫画图片转化为 pdf 来方便在 iPad 上阅读。\n查阅资料，我们会发现 Pillow 这个第三方 python 库可以来处理图片，同时也可以将大量的图片转化为 pdf 文档。\n简单地查看下 官方文档 。\nemmm，官方文档的东西有点多，为了快速解决问题还是直接查找下有没有相关代码把。\n随便查了下，发现了这个：\nfrom PIL import Image image1 = Image.open(r\u0026#39;C:\\Users\\Ron\\Desktop\\Test\\image1.png\u0026#39;) image2 = Image.open(r\u0026#39;C:\\Users\\Ron\\Desktop\\Test\\image2.png\u0026#39;) image3 = Image.open(r\u0026#39;C:\\Users\\Ron\\Desktop\\Test\\image3.png\u0026#39;) image4 = Image.open(r\u0026#39;C:\\Users\\Ron\\Desktop\\Test\\image4.png\u0026#39;) im1 = image1.convert(\u0026#39;RGB\u0026#39;) im2 = image2.convert(\u0026#39;RGB\u0026#39;) im3 = image3.convert(\u0026#39;RGB\u0026#39;) im4 = image4.convert(\u0026#39;RGB\u0026#39;) imagelist = [im2,im3,im4] im1.save(r\u0026#39;C:\\Users\\Ron\\Desktop\\Test\\myImages.pdf\u0026#39;,save_all=True, append_images=imagelist) 来源： https://datatofish.com/images-to-pdf-python/\n不需要仔细看又臭又长的官方文档了，nice！\n了解了如何使用这个强大的库，就可以开始写代码了，vsc 一条龙服务!\n代码很简单，直接上源码了：\n源码 项目文件目录：\n- comic/ # 包含了漫画的图片 - example_001.png - example_002.png - example_003.png ... - example_202.png - output/ # 保存输出的pdf文件 - ろりっぽいの.pdf main.py main.py\nfrom PIL import Image import os # change these config DOC_NAME = \u0026#39;ろりっぽいの\u0026#39; # 输出pdf文件的名字 COMIC_PATH = \u0026#39;comic/\u0026#39; # 漫画的保存路径 SAVE_PATH = \u0026#39;output/\u0026#39; # pdf输出路径 USE_ABSLUTE = False # 是否使用绝对路径 PAGE_NUMBER = 220 # 漫画的页数 NAME_BEFORE = \u0026#39;example_\u0026#39; # 漫画图片文件数字前的内容 FILE_TYPE = \u0026#39;.png\u0026#39; # 漫画文件的文件类型 FILL_NUMBER = 2 # 填充的数字的个数 if not USE_ABSLUTE: DIR_PATH = os.path.dirname(os.path.realpath(__file__)) + \u0026#39;/\u0026#39; COMIC_PATH = DIR_PATH + COMIC_PATH SAVE_PATH = DIR_PATH + SAVE_PATH cover_path = COMIC_PATH + NAME_BEFORE + \u0026#39;1\u0026#39;.zfill(FILL_NUMBER) + FILE_TYPE cover = Image.open(cover_path).convert(\u0026#39;RGB\u0026#39;) comic_images_list = [] for i in range(2, PAGE_NUMBER + 1): comic_image_path = COMIC_PATH + NAME_BEFORE + str(i).zfill(FILL_NUMBER) + FILE_TYPE comic_image = Image.open(comic_image_path).convert(\u0026#39;RGB\u0026#39;) comic_images_list.append(comic_image) pdf_file_path = SAVE_PATH + DOC_NAME + \u0026#39;.pdf\u0026#39; cover.save(pdf_file_path, save_all=True, append_images=comic_images_list) 使用说明 唔，能打开我的文章并看懂我上面在说什么的读者应该知道如何使用吧，甚至可以自己手撸一个功能相同的软件出来，不过这里还是稍微解释一下我的代码。\n使用的话，代码部分不需要修改，直接按照注释，修改前面的几个全局变量就可以了。\n唯一需要说明的是最后一个变量 __FILL_NUMBER__ ：\n由于大部分的漫(ben)画(zi)一般都是 001.jpg, 002.jpg, 003.jpg, ... , 102.jpg 这样或者 01.png, 02.png, 03.png, ... , 42.png 这样的命名规则，所以这里我使用了 zfill 这个函数来快速将循环数转化为文件名，而这个参数就是给 zfill 这个函数用的。\n如果你不清楚 zfill 这个函数是干什么的。这里我准备了几个网站。\nhttps://python-reference.readthedocs.io/en/latest/docs/str/zfill.html\nhttps://www.w3schools.com/python/ref_string_zfill.asp\n软件效率 值得一提的是转化效率，200 多页，大概 100 多 M 的漫(ben)画(zi)转化只用了不到 10 秒钟，转化后 pdf 文件只有 60 多 M，还有压缩效果，nice。pillow 牛逼就完事了。可以使用 iPad 继续愉快的看漫(ben)画(zi)了。\n后记 本来想上传 GitHub 的，但是代码太简单了，干脆直接水一篇博客算了。\n话说如果把漫(ben)画(zi)连代码一起打包发到 GitHub 上会不会被 ban 帐号啊？（听说 GitHub 在打击网盘行为？）传播淫秽物品罪了解一下？\n","permalink":"https://aimerneige.com/zh/post/python/using-pillow-to-convert-comic-to-pdf-quickly/","summary":"介绍 使用安卓手机阅读一些漫画的时候，因为屏幕较小，查看文字的时候需要放大，很麻烦。博主虽然有一个 iPad4，屏幕够大，但是把这么多图片文件发送到 iPad 上面十分的麻烦，一天，偶然看到了一个 pdf 格式的漫画，在 iPad 上面的阅读体验十分棒，于是博主就打算写一个程序来将大量的漫画图片转化为 pdf 来方便在 iPad 上阅读。\n查阅资料，我们会发现 Pillow 这个第三方 python 库可以来处理图片，同时也可以将大量的图片转化为 pdf 文档。\n简单地查看下 官方文档 。\nemmm，官方文档的东西有点多，为了快速解决问题还是直接查找下有没有相关代码把。\n随便查了下，发现了这个：\nfrom PIL import Image image1 = Image.open(r\u0026#39;C:\\Users\\Ron\\Desktop\\Test\\image1.png\u0026#39;) image2 = Image.open(r\u0026#39;C:\\Users\\Ron\\Desktop\\Test\\image2.png\u0026#39;) image3 = Image.open(r\u0026#39;C:\\Users\\Ron\\Desktop\\Test\\image3.png\u0026#39;) image4 = Image.open(r\u0026#39;C:\\Users\\Ron\\Desktop\\Test\\image4.png\u0026#39;) im1 = image1.convert(\u0026#39;RGB\u0026#39;) im2 = image2.convert(\u0026#39;RGB\u0026#39;) im3 = image3.convert(\u0026#39;RGB\u0026#39;) im4 = image4.convert(\u0026#39;RGB\u0026#39;) imagelist = [im2,im3,im4] im1.save(r\u0026#39;C:\\Users\\Ron\\Desktop\\Test\\myImages.pdf\u0026#39;,save_all=True, append_images=imagelist) 来源： https://datatofish.com/images-to-pdf-python/\n不需要仔细看又臭又长的官方文档了，nice！\n了解了如何使用这个强大的库，就可以开始写代码了，vsc 一条龙服务!\n代码很简单，直接上源码了：\n源码 项目文件目录：\n- comic/ # 包含了漫画的图片 - example_001.","title":"使用 pillow 库快速将漫画转化为 pdf 便于转发与阅读"},{"content":" 本来是在查资料，无意间看到了这个知乎文章，感觉内容值得学习，但是排版实在难受，代码和注释混在一起，没有换行，同时解释也很奇怪（感觉是机翻的），当我无法忍受想关闭网页的时候，发现这篇文章是翻译自Medium的文章，但是原文章是英语写的，为了帮到那些英语不太好的 Python 学习者，同时方便自己之后看，于是写了这篇博文（算是笔记吧）\n基于 Medium 的文章 《20 Python Snippets You Should Learn Today》 ，除了翻译外添加了自己的解释。水平有限，如果有错误欢迎读者指正。\n大部分示例代码均引用自 Medium 《20 Python Snippets You Should Learn Today》\n1 反转字符串 下面的代码使用 Python 切片操作来反转字符串。\n# Reversing a string using slicing my_string = \u0026#34;ABCDE\u0026#34; reversed_string = my_string[::-1] print(reversed_string) # Output # EDCBA 这里用到的是 Python切片\n切片某种意义上就是对如下代码的书写进行了简化（不考虑 Python 中-1 的情况）\n// [a🅱️c] for (int i = a, i \u0026lt; b; i = i + c) { // do something } 推荐阅读： 《How to reverse a string in Python?》\n2 转化为标题（首字母大写） 下面的代码把字符串转化为标题格式。这里用了字符串类的 title()方法来实现。\nmy_string = \u0026#34;my name is chaitanya baweja\u0026#34; # using the title() function of string class new_string = my_string.title() print(new_string) # Output # My Name Is Chaitanya Baweja 把字符串中单词的首字母都大写，转变为标题格式，就是调用了字符串类的 title()方法，很简单，不需要解释。\n值得一提的是，虽然叫 title， 但是它是完全不加判断地把所有单词的首字母大写，并没有遵循英语的语法规则。\n英文标题首字母大写规则 按照规则的优先级从高到底应该是：\n标题的第一个单词的首字母要大写； 冠词都不需要大写； 字母个数多于 3 个（不含 3 个）的介词、连词的首字母要大写； 名词、动词、形容词、副词、代词、感叹词首字母应大写； 大写所有英语中要求大写的单词。如月份、人名、地名等等。 根据优先级递减的规则，如果后面的规则与前面的规则冲突，则优先执行前面的规则。\n来源： https://www.cnblogs.com/crackpotisback/p/5547249.html\ntest_str = \u0026#34;the story of an magical apple and me\u0026#34; title_str = test_str.title() print(title_str) # Output # The Story Of An Magical Apple And Me 另外，函数只识别空格分割的单词\nmy_string = \u0026#34;helloworld\u0026#34; new_string = my_string.title() print(new_string) # Output # Helloworld 3 查找字符串的唯一元素 下面的代码可以用于查找字符串中所有的唯一元素，我们利用了集合内元素的唯一性。\nmy_string = \u0026#34;aavvccccddddeee\u0026#34; # converting the string to a set temp_set = set(my_string) # stitching set into a string using join new_string = \u0026#39;\u0026#39;.join(temp_set) print(new_string) # Output # ecdva 效果是把字符串中用到的字符都提取出来，构成一个新的字符串。\n比如对 hello ，它内部包含 h, e, l, o 这几四字符，于是我们就会得到一个由这四个字符构成的新字符串，顺序通常是乱的，比如 oelh 就是一种可能的结果。\n输出结果并没有排序，是随机的，比如你期望如下代码返回abcdefghijklmnopqrstuvwxyz .，但是结果却是杂乱的。\nmy_string = \u0026#34;the quick brown fox jumps over the lazy dog.\u0026#34; temp_set = set(my_string) new_string = \u0026#39;\u0026#39;.join(temp_set) print(new_string) # Output # trzixup.efbajovcdnslywhg qmk 这里用到了 python 中的 集合 和 join()方法\n首先利用集合的唯一性，用原始字符串构造一个集合，然后利用 join()方法把集合内的元素用空字符串进行连接，相当于将集合内的元素连接成字符串。\n推荐阅读： 《An Introduction to Python Sets - Part I》\n4 输出 n 次字符串或列表 你可以对字符串或列表使用乘法(*)。这让我们可以按照我们的需求输出多次。\nn = 3 # number of repetitions my_string = \u0026#34;abcd\u0026#34; my_list = [1,2,3] print(my_string*n) # abcdabcdabcd print(my_list*n) # [1,2,3,1,2,3,1,2,3] 关于这个内容的一个有趣的用例是定义一个具有恒定值的列表——假设为零。\nn = 4 my_list = [0]*n # n denotes the length of the required list # [0, 0, 0, 0] 乘法的特殊用法，没什么需要解释的。\n5 列表解析 列表解析为创建列表提供了一种可以以其他列表为基础来创建新的列表的优雅方式。\n下面的代码通过把旧列表中的每个元素都乘以 2 来创建新列表。\n# Multiplying each element in a list by 2 original_list = [1,2,3,4] new_list = [2*x for x in original_list] print(new_list) # [2,4,6,8] 推荐阅读： 《List Comprehensions in Python》\n6 交换俩个变量的值 Python 使得交换俩个变量的值变得十分简单，并不需要使用另一个变量。\na = 1 b = 2 a, b = b, a print(a) # 2 print(b) # 1 很简单，不需要解释。\n7 把字符串分解为子字符串列表 我们可以通过字符串类的 split() 方法来把字符串分解成子字符串列表。你同样可以传递一个参数来决定用什么字符进行分割。\nstring_1 = \u0026#34;My name is Chaitanya Baweja\u0026#34; string_2 = \u0026#34;sample/ string 2\u0026#34; # default separator \u0026#39; \u0026#39; print(string_1.split()) # [\u0026#39;My\u0026#39;, \u0026#39;name\u0026#39;, \u0026#39;is\u0026#39;, \u0026#39;Chaitanya\u0026#39;, \u0026#39;Baweja\u0026#39;] # defining separator as \u0026#39;/\u0026#39; print(string_2.split(\u0026#39;/\u0026#39;)) # [\u0026#39;sample\u0026#39;, \u0026#39; string 2\u0026#39;] 这里使用了 split()方法 不多解释了。\n8 将字符串列表组合成单字符串 join()方法可以通过传入的参数作为间隔把字符串数组组合成单字符串。\n在本例中。我们使用逗号作为分割符。\nlist_of_strings = [\u0026#39;My\u0026#39;, \u0026#39;name\u0026#39;, \u0026#39;is\u0026#39;, \u0026#39;Chaitanya\u0026#39;, \u0026#39;Baweja\u0026#39;] # Using join with the comma separator print(\u0026#39;,\u0026#39;.join(list_of_strings)) # Output # My,name,is,Chaitanya,Baweja 使用了 join()方法 ，不多解释了。\n9 检查给定字符串是否为回文（Palindrome） 我们已经讨论了如何反转字符串，因此，在 Python 中，回文检查变得很简单。\nmy_string = \u0026#34;abcba\u0026#34; if my_string == my_string[::-1]: print(\u0026#34;palindrome\u0026#34;) else: print(\u0026#34;not palindrome\u0026#34;) # Output # palindrome 10 列表中元素出现的次数 有很多的方法来做这件事，但是我最喜欢的方法是使用 Python 中的 Counter 类。\nPython 的 Counter 会记录容器内每个元素的出现次数。Counter() 返回一个字典，字典内以元素为键，出现次数为值。\n同样的，我们可以使用函数 most_common() 来获得列表中出现次数最多的元素。\n# finding frequency of each element in a list from collections import Counter my_list = [\u0026#39;a\u0026#39;,\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;d\u0026#39;] count = Counter(my_list) # defining a counter object print(count) # Of all elements # Counter({\u0026#39;d\u0026#39;: 5, \u0026#39;b\u0026#39;: 3, \u0026#39;a\u0026#39;: 2, \u0026#39;c\u0026#39;: 1}) print(count[\u0026#39;b\u0026#39;]) # of individual element # 3 print(count.most_common(1)) # most frequent element # [(\u0026#39;d\u0026#39;, 5)] 使用列表作为参数构建 Counter 类，返回值即为所需内容。\n推荐阅读：《An Introduction to Python Counter》\n11 判断俩个字符串是否为易位词 Counter 的一个有趣的应用是判断易位词。\n如果一个单词或者短语是由另一个单词或短语重新排序构成的，那么这个俩单词或者短语就被称为易位词。（百科词条可能会帮到你）\n易位构词游戏的英文词汇是 anagram，这个词来源于有“反向”或“再次”的含义的希腊语字根ana-和有“书写”、“写下”的意思的词根gramma。易位构词是一类文字游戏（更准确地说是一类“词语游戏”），是将组成一个词或短句的字母重新排列顺序，原文中所有字母的每次出现都被使用一次，这样构造出另外一些新的词或短句。\n来源: 中文维基 易位构词游戏\n推荐阅读：百度百科 易位词 English wiki Anagram\n如果俩个字符串的 Counter 对象是相同的，那么他们是易位词。\nfrom collections import Counter str_1, str_2, str_3 = \u0026#34;acbde\u0026#34;, \u0026#34;abced\u0026#34;, \u0026#34;abcda\u0026#34; cnt_1, cnt_2, cnt_3 = Counter(str_1), Counter(str_2), Counter(str_3) if cnt_1 == cnt_2: print(\u0026#39;1 and 2 anagram\u0026#39;) if cnt_1 == cnt_3: print(\u0026#39;1 and 3 anagram\u0026#39;) # Output # 1 and 2 anagram 12 使用 try-except-else 在 python 中，通过使用 try/except 代码块可以简单地处理错误。在这个代码块中添加 else 可能是有用的。\n如果没有错误发生的话，else 后的代码就会被执行。\n如果你有一些不管错误是否发生都需要执行的代码，使用 finally。\na, b = 1,0 try: print(a/b) # exception raised when b is 0 except ZeroDivisionError: print(\u0026#34;division by zero\u0026#34;) else: print(\u0026#34;no exceptions raised\u0026#34;) finally: print(\u0026#34;Run this always\u0026#34;) # Output # division by zero # Run this always try: some_dangerous_operation() # something may cause exception except: exception_handle() # something run when the exception happens else: no_exception() # something run when no exception happens finally: something_must_to_been_done() # something run weather the exception happens or not 13 使用 Enumerate 来取得 索引-值 对 下面的脚本使用了 Enumerate 来迭代列表中的值及其索引。\nmy_list = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;] for index, value in enumerate(my_list): print(\u0026#39;{0}: {1}\u0026#39;.format(index, value)) # 0: a # 1: b # 2: c # 3: d # 4: e 推荐阅读： 菜鸟教程 enumerate() 函数\n14 检查对象的内存使用 下面的脚本可以用于检查对象的内存使用。\n在这里阅读更多： 这里\nimport sys num = 21 print(sys.getsizeof(num)) # In Python 2, 24 # In Python 3, 28 15 合并俩个字典 在 Python 2，我们使用 update() 方法来合并俩个字典。\nPython 3.5 简化了这个过程。\n在下面的脚本中，俩个字典被合并。为了防止交叉的情况，使用第二个字典的值。\ndict_1 = {\u0026#39;apple\u0026#39;: 9, \u0026#39;banana\u0026#39;: 6} dict_2 = {\u0026#39;banana\u0026#39;: 4, \u0026#39;orange\u0026#39;: 8} combined_dict = {**dict_1, **dict_2} print(combined_dict) # Output # {\u0026#39;apple\u0026#39;: 9, \u0026#39;banana\u0026#39;: 4, \u0026#39;orange\u0026#39;: 8} 16 执行一段代码所需时间 下面的代码使用 time 库计算运行一段代码所需要的时间。\nimport time start_time = time.time() # Code to check follows a, b = 1,2 c = a+ b # Code to check ends end_time = time.time() time_taken_in_micro = (end_time- start_time)*(10**6) print(\u0026#34; Time taken in micro_seconds: {0} ms\u0026#34;).format(time_taken_in_micro) 17 嵌套列表扁平化 有时，你并不清楚你的列表的嵌套深度，并且你仅仅只是想要让所有元素变成一个扁平的列表。\n这个代码告诉你如何实现！\nfrom iteration_utilities import deepflatten # if you only have one depth nested_list, use this def flatten(l): return [item for sublist in l for item in sublist] l = [[1,2,3],[3]] print(flatten(l)) # [1, 2, 3, 3] # if you don\u0026#39;t know how deep the list is nested l = [[1,2,3],[4,[5],[6,7]],[8,[9,[10]]]] print(list(deepflatten(l, depth=3))) # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 如果你有一个正确格式化的数组， Numpy flatten 可能是一个更好的选择。\n18 列表取样 下面的代码生使用 random 库从给定的列表中生成了 n 个随机的样本。\nimport random my_list = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;] num_samples = 2 samples = random.sample(my_list,num_samples) print(samples) # [ \u0026#39;a\u0026#39;, \u0026#39;e\u0026#39;] this will have any 2 random values 我十分推荐使用 secrets 库来生成用于加密的随机样本。\n下面的代码只能在 python 3 运行。\nimport secrets # imports secure module. secure_random = secrets.SystemRandom() # creates a secure random object. my_list = [\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;e\u0026#39;] num_samples = 2 samples = secure_random.sample(my_list, num_samples) print(samples) # [ \u0026#39;e\u0026#39;, \u0026#39;d\u0026#39;] this will have any 2 random values 19 数字化 下面的代码将会把一个整数转化成数字的列表。\nnum = 123456 # using map list_of_digits = list(map(int, str(num))) print(list_of_digits) # [1, 2, 3, 4, 5, 6] # using list comprehension list_of_digits = [int(x) for x in str(num)] print(list_of_digits) # [1, 2, 3, 4, 5, 6] 20 检查唯一性 下面的函数会检查一个列表内的所有元素是否是唯一的。\ndef unique(l): if len(l)==len(set(l)): print(\u0026#34;All elements are unique\u0026#34;) else: print(\u0026#34;List has duplicates\u0026#34;) unique([1,2,3,4]) # All elements are unique unique([1,1,2,3]) # List has duplicates 这里利用了集合的唯一性。\n总结 不得不说对于计算机学习来说，英语还是很重要的，很多资料都是英语的。\n推荐阅读： https://www.30secondsofcode.org/python/p/1\n","permalink":"https://aimerneige.com/zh/post/python/20-python-skills/","summary":"本来是在查资料，无意间看到了这个知乎文章，感觉内容值得学习，但是排版实在难受，代码和注释混在一起，没有换行，同时解释也很奇怪（感觉是机翻的），当我无法忍受想关闭网页的时候，发现这篇文章是翻译自Medium的文章，但是原文章是英语写的，为了帮到那些英语不太好的 Python 学习者，同时方便自己之后看，于是写了这篇博文（算是笔记吧）\n基于 Medium 的文章 《20 Python Snippets You Should Learn Today》 ，除了翻译外添加了自己的解释。水平有限，如果有错误欢迎读者指正。\n大部分示例代码均引用自 Medium 《20 Python Snippets You Should Learn Today》\n1 反转字符串 下面的代码使用 Python 切片操作来反转字符串。\n# Reversing a string using slicing my_string = \u0026#34;ABCDE\u0026#34; reversed_string = my_string[::-1] print(reversed_string) # Output # EDCBA 这里用到的是 Python切片\n切片某种意义上就是对如下代码的书写进行了简化（不考虑 Python 中-1 的情况）\n// [a🅱️c] for (int i = a, i \u0026lt; b; i = i + c) { // do something } 推荐阅读： 《How to reverse a string in Python?","title":"20 个 Python 进阶技巧"},{"content":"在构建布局的时候，是不是感到要写很多的 findViewById 很浪费时间呢？尤其是布局文件变化的时候，也要在 Activity 中更改很多内容，极大的降低了开发效率，而谷歌在 JetPack 中提供了一种十分有效的方法来精简代码结构，提升开发效率，那就是 DataBinding 下面来介绍 DataBinding 的使用\n用到的依赖 implementation 'androidx.lifecycle:lifecycle-extensions:2.2.0'\n开启 dataBinding 在 app 的 build.gradle 文件中添加以下内容\ndataBinding { enabled true } 位置参考\nandroid { compileSdkVersion 29 buildToolsVersion \u0026#34;29.0.3\u0026#34; defaultConfig { applicationId \u0026#34;com.aimerneige.databindingdemo\u0026#34; minSdkVersion 24 targetSdkVersion 29 versionCode 1 versionName \u0026#34;1.0\u0026#34; testInstrumentationRunner \u0026#34;androidx.test.runner.AndroidJUnitRunner\u0026#34; dataBinding { enabled true } } buildTypes { release { minifyEnabled false proguardFiles getDefaultProguardFile(\u0026#39;proguard-android-optimize.txt\u0026#39;), \u0026#39;proguard-rules.pro\u0026#39; } } } 为布局文件提供 dataBinding 支持 在布局文件开头点击黄色灯泡（或按ALT + Enter），选择以下操作将布局文件转换为 data binding layout ，获取 data binding 支持\nconvert to data binding layout\n之后你的布局将会变成这样\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;layout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34;\u0026gt; \u0026lt;data\u0026gt; \u0026lt;/data\u0026gt; \u0026lt;!--这里是你之前的布局--\u0026gt; \u0026lt;/layout\u0026gt; 你就可以在 \u0026lt;data\u0026gt; 标签内填写代码了。\n在 MainActivity 绑定布局 添加 DataBinding 之后， setContentView 就不能继续使用了，这里需要用到新的方法绑定布局\n删除旧布局 删除 onCreate 方法中的 setContentView 那一行的代码\n构建 DataBinding 的引用 使用 DataBinding 之后，系统会自动生成一个类，类名取决于你的布局名称。\n比如：\nactivity_main.xml \u0026ndash;\u0026gt; ActivityMainBinding activity_test \u0026ndash;\u0026gt; ActivityTestBinding my_own_layout_for_test.xml \u0026ndash;\u0026gt; MyOwnLayoutForTestBinding 知道类名之后在添加如下字段：\nActivityMainBinding activityMainBinding; 绑定布局 在 onCreate 方法中添加如下内容\nactivityMainBinding = DataBindingUtil.setContentView(this, R.layout.activity_main); 搭建布局 通常情况下，一般会搭配 ViewModel 和 LiveData 使用，这里不多介绍这俩种技术（之前的文章有专门的介绍）。\n这里搭建了一个很简单的布局，代码是完整的，之后解释。\nactivity_main.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;layout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34;\u0026gt; \u0026lt;data\u0026gt; \u0026lt;variable name=\u0026#34;data\u0026#34; type=\u0026#34;com.aimerneige.databindingdemo.MyViewModel\u0026#34; /\u0026gt; \u0026lt;/data\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/textView\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;@{String.valueOf(data.number)}\u0026#34; /\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/add\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:onClick=\u0026#34;@{()-\u0026gt;data.addValue(1)}\u0026#34; android:text=\u0026#34;+1\u0026#34; /\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/minus\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:onClick=\u0026#34;@{()-\u0026gt;data.addValue(-1)}\u0026#34; android:text=\u0026#34;-1\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;/layout\u0026gt; MyViewModel.java\npackage com.aimerneige.databindingdemo; import androidx.lifecycle.LiveData; import androidx.lifecycle.MutableLiveData; import androidx.lifecycle.ViewModel; public class MyViewModel extends ViewModel { private MutableLiveData\u0026lt;Integer\u0026gt; number; public MutableLiveData\u0026lt;Integer\u0026gt; getNumber() { if (number == null) { number = new MutableLiveData\u0026lt;\u0026gt;(); number.setValue(0); } return number; } public void addValue(int n) { number.setValue(number.getValue() + n); } } MainActivity.java\npackage com.aimerneige.databindingdemo; import androidx.appcompat.app.AppCompatActivity; import androidx.databinding.DataBindingUtil; import androidx.lifecycle.ViewModelProvider; import android.os.Bundle; import com.aimerneige.databindingdemo.databinding.ActivityMainBinding; public class MainActivity extends AppCompatActivity { MyViewModel myViewModel; ActivityMainBinding activityMainBinding; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); activityMainBinding = DataBindingUtil.setContentView(this, R.layout.activity_main); myViewModel = new ViewModelProvider(this).get(MyViewModel.class); activityMainBinding.setData(myViewModel); activityMainBinding.setLifecycleOwner(this); } } 创建好 MyViewModel 后，需要在 MainActivity 和 \u0026lt;data\u0026gt; 标签内引用\n如何在 MainActivity 使用就不解释了，之前的文章有说明，这里只解释如何在布局文件内使用。\n找到之前生成的 \u0026lt;data\u0026gt; 标签，在其内部填写 \u0026lt;variable /\u0026gt; 标签，填好之后会有自动补全，在 name 内填一个自定义的名称，这里使用 data ，然后在 type 内填写创建的 ViewModel 类。\n示例如下：\n\u0026lt;data\u0026gt; \u0026lt;variable name=\u0026#34;data\u0026#34; type=\u0026#34;com.aimerneige.databindingdemo.MyViewModel\u0026#34; /\u0026gt; \u0026lt;/data\u0026gt; 然后就可以在布局内写一些类似 java 代码的东西\n可以通过如下方法访问 ViewModel 中的变量或者方法\n访问变量：\n@{String.valueOf(data.number)}\n访问方法：\n@{()-\u0026gt;data.addValue(1)}\n最后在 MainActivity 内添加如下代码即可\nactivityMainBinding.setData(myViewModel); activityMainBinding.setLifecycleOwner(this); ","permalink":"https://aimerneige.com/zh/post/android/data-binding/","summary":"在构建布局的时候，是不是感到要写很多的 findViewById 很浪费时间呢？尤其是布局文件变化的时候，也要在 Activity 中更改很多内容，极大的降低了开发效率，而谷歌在 JetPack 中提供了一种十分有效的方法来精简代码结构，提升开发效率，那就是 DataBinding 下面来介绍 DataBinding 的使用\n用到的依赖 implementation 'androidx.lifecycle:lifecycle-extensions:2.2.0'\n开启 dataBinding 在 app 的 build.gradle 文件中添加以下内容\ndataBinding { enabled true } 位置参考\nandroid { compileSdkVersion 29 buildToolsVersion \u0026#34;29.0.3\u0026#34; defaultConfig { applicationId \u0026#34;com.aimerneige.databindingdemo\u0026#34; minSdkVersion 24 targetSdkVersion 29 versionCode 1 versionName \u0026#34;1.0\u0026#34; testInstrumentationRunner \u0026#34;androidx.test.runner.AndroidJUnitRunner\u0026#34; dataBinding { enabled true } } buildTypes { release { minifyEnabled false proguardFiles getDefaultProguardFile(\u0026#39;proguard-android-optimize.txt\u0026#39;), \u0026#39;proguard-rules.pro\u0026#39; } } } 为布局文件提供 dataBinding 支持 在布局文件开头点击黄色灯泡（或按ALT + Enter），选择以下操作将布局文件转换为 data binding layout ，获取 data binding 支持","title":"使用 DataBinding 精简代码"},{"content":"在进行一些耗时操作的时候，经常需要加载提示框来提醒用户当前在进行耗时操作，需要等待。\n而实现这样一个加载框十分简单。\n构建 ProgressDialog 对象 你可以在耗时操作开始前临时建立新的 ProgressDialog 对象，你也同样可以在 Activity 中构建 ProgressDialog 的引用，并在 OnCreate 方法内构建实体，在需要的时候直接显示和隐藏。\n其中前者相对灵活，但是使用范围有限，后者使用范围较广，但是可以会使得 OnCreate 中的代码较为繁琐。\n但是，不管使用那种方法，ProgressDialog 的构建都是非常简单。\nProgressDialog progressDialog; progressDialog = new ProgressDialog(MainActivity.this); // ProgressDialog progressDialog = new ProgressDialog(MainActivity.this); progressDialog.setTitle(\u0026#34;This is Title\u0026#34;); progressDialog.setMessage(\u0026#34;This is Message\u0026#34;); progressDialog.setCancelable(true); 其他属性可自行探索或者查阅官方文档\n显示加载框 在耗时操作开始前(或者任何你想要显示提示框的地方)，通过以下操作显示加载框:\nprogressDialog.show(); 关闭提示框 在耗时操作关闭时(或者任何你想要关闭提示框的地方)，通过以下操作关闭加载框:\nprogressDialog.hide(); 很简单不是吗又水了一期，不过好像没人看我的博客\n","permalink":"https://aimerneige.com/zh/post/android/progress-dialog/","summary":"在进行一些耗时操作的时候，经常需要加载提示框来提醒用户当前在进行耗时操作，需要等待。\n而实现这样一个加载框十分简单。\n构建 ProgressDialog 对象 你可以在耗时操作开始前临时建立新的 ProgressDialog 对象，你也同样可以在 Activity 中构建 ProgressDialog 的引用，并在 OnCreate 方法内构建实体，在需要的时候直接显示和隐藏。\n其中前者相对灵活，但是使用范围有限，后者使用范围较广，但是可以会使得 OnCreate 中的代码较为繁琐。\n但是，不管使用那种方法，ProgressDialog 的构建都是非常简单。\nProgressDialog progressDialog; progressDialog = new ProgressDialog(MainActivity.this); // ProgressDialog progressDialog = new ProgressDialog(MainActivity.this); progressDialog.setTitle(\u0026#34;This is Title\u0026#34;); progressDialog.setMessage(\u0026#34;This is Message\u0026#34;); progressDialog.setCancelable(true); 其他属性可自行探索或者查阅官方文档\n显示加载框 在耗时操作开始前(或者任何你想要显示提示框的地方)，通过以下操作显示加载框:\nprogressDialog.show(); 关闭提示框 在耗时操作关闭时(或者任何你想要关闭提示框的地方)，通过以下操作关闭加载框:\nprogressDialog.hide(); 很简单不是吗又水了一期，不过好像没人看我的博客","title":"使用 ProgressDialog 实现加载提示"},{"content":"ViewModel 提供了一个可以管理数据的优雅的容器，但是它也只是存储数据而已，并不能对数据进行处理，只是存储数据而已，但是如果使用 LiveData 来辅助， ViewModel 不再只是存储数据，它本身也能处理界面内容，就像它的名字一样，能让数据活起来。\n在 ViewModel 中构建 LiveData 对象 与 ViewModel 不同， LiveData 不需要构建类，直接在 ViewModel 中创建对象即可。\n首先创建 ViewModel 对象，然后在 ViewModel 对象中创建 LiveData 字段\npackage com.aimerneige.livedatatest; import androidx.lifecycle.MutableLiveData; import androidx.lifecycle.ViewModel; public class ViewModelWithLiveData extends ViewModel { private MutableLiveData\u0026lt;Integer\u0026gt; LikedNumber; } 然后为 LiveData 对象构建 get 方法\n// May Cause Error public MutableLiveData\u0026lt;Integer\u0026gt; getLikedNumber() { return LikedNumber; } 要注意的是构建的对象如果没有构建的话是为空的，直接返回会有空指针错误，所以要对空指针进行处理。\n在构造方法中解决 // One possible wey to make the LikedNumber not null ViewModelWithLiveData () { LikedNumber = new MutableLiveData\u0026lt;\u0026gt;(); LikedNumber.setValue(0); } 在 get 方法中解决(推荐) public MutableLiveData\u0026lt;Integer\u0026gt; getLikedNumber() { if (LikedNumber == null) { LikedNumber = new MutableLiveData\u0026lt;\u0026gt;(); LikedNumber.setValue(0); } return LikedNumber; } 接下来为数据提供操作方法，要注意的是这里非常不建议直接提供 set 方法对数据进行修改。这里以增加（减少）数据大小为例：\npublic void addLikedNumber(int n) { LikedNumber.setValue(LikedNumber.getValue() + n); } 需要增加（减少）数据大小的时候通过这个方法传入正数（负数）即可。\n要注意的是经过 LiveData 包装后 int 数据不能进行直接的加减操作，只能通过 setValue 、 getValue 等对数据进行处理（当然这并不是难事）\n在 Activity 中使用 LiveData 首先在 Activity 中构建 ViewModel 的引用\nViewModelWithLiveData viewModelWithLiveData; ``` 在 `onCreate` 方法内获得 `ViewModel` 的实体 ```java viewModelWithLiveData = ViewModelProviders.of(this).get(ViewModelWithLiveData.class); ``` 对 `LiveData` 数据创建观察者 ```java viewModelWithLiveData.getLikedNumber().observe(this, new Observer\u0026lt;Integer\u0026gt;() { @Override public void onChanged(Integer integer) { textView.setText(String.valueOf(integer)); } }); ``` 添加观察后，当数据发生变化后，会自动更改组件上的内容，当然这个行为完全可以自己改。 别忘了使用数据操作方法 ```java liked.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { viewModelWithLiveData.addLikedNumber(1); } }); disliked.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { viewModelWithLiveData.addLikedNumber(-1); } }); ``` ","permalink":"https://aimerneige.com/zh/post/android/live-data/","summary":"ViewModel 提供了一个可以管理数据的优雅的容器，但是它也只是存储数据而已，并不能对数据进行处理，只是存储数据而已，但是如果使用 LiveData 来辅助， ViewModel 不再只是存储数据，它本身也能处理界面内容，就像它的名字一样，能让数据活起来。\n在 ViewModel 中构建 LiveData 对象 与 ViewModel 不同， LiveData 不需要构建类，直接在 ViewModel 中创建对象即可。\n首先创建 ViewModel 对象，然后在 ViewModel 对象中创建 LiveData 字段\npackage com.aimerneige.livedatatest; import androidx.lifecycle.MutableLiveData; import androidx.lifecycle.ViewModel; public class ViewModelWithLiveData extends ViewModel { private MutableLiveData\u0026lt;Integer\u0026gt; LikedNumber; } 然后为 LiveData 对象构建 get 方法\n// May Cause Error public MutableLiveData\u0026lt;Integer\u0026gt; getLikedNumber() { return LikedNumber; } 要注意的是构建的对象如果没有构建的话是为空的，直接返回会有空指针错误，所以要对空指针进行处理。\n在构造方法中解决 // One possible wey to make the LikedNumber not null ViewModelWithLiveData () { LikedNumber = new MutableLiveData\u0026lt;\u0026gt;(); LikedNumber.","title":"使用 LiveData 优雅地管理布局显示的数据"},{"content":"如果不进行处理的话，布局上的临时数据可能会因为屏幕反转，切换系统语言等而消失，但是处理过程略微繁琐，较为麻烦，但是谷歌为我们提供了一种更加简洁的方式来管理界面数据，那就是 ViewModel。\n构建自己的 ViewModel 类 新建 Java 类，继承至ViewModel，名字自定义，这里以MyViewModel为例。\npackage com.aimerneige.viewmoudeltest; import androidx.lifecycle.ViewModel; public class MyViewMoude extends ViewModel { } 新建好类之后，直接将需要用到的数据填写在内部，可以直接使用 public 的数据类型（不推荐），或者使用 private 数据加 get 方法。\npackage com.aimerneige.viewmoudletest; import androidx.lifecycle.ViewModel; public class MyViewMoude extends ViewModel { public int number = 0; public String test = \u0026#34;Test for 100\u0026#34;; private int age = 0; public int getAge() { return age; } public void setAge(int age) { this.age = age; } } 然后把ViewModel当成一个智能地存储数据的结构体使用即可。\n在 Activity 中使用 ViewModel 在MainActivity内构建MyViewMoude的引用\nMyViewMoude myViewMoude; 在 onCreate 方法内获得 MyViewMoude 的实体\nmyViewMoude = ViewModelProviders.of(this).get(MyViewMoude.class); 直接使用即可，操作类似结构体\ntextView.setText(String.valueOf(myViewMoude.number)); textView.setText(myViewMoude.test); textView.setText(String.valueOf(myViewMoude.getAge())); 额外的说明 ViewModelProviders.of()目前已被官方弃用官方文档\n以下是解决方案， 参考资料\n将\nboardViewModel = ViewModelProviders.of(this).get(BoardViewModel::class.java) 替换为：\nboardViewModel = ViewModelProvider(this).get(BoardViewModel::class.java) 本例中，使用如下代码：\nmyViewMoude = new ViewModelProvider(this).get(MyViewMoude.class); ","permalink":"https://aimerneige.com/zh/post/android/view-module/","summary":"如果不进行处理的话，布局上的临时数据可能会因为屏幕反转，切换系统语言等而消失，但是处理过程略微繁琐，较为麻烦，但是谷歌为我们提供了一种更加简洁的方式来管理界面数据，那就是 ViewModel。\n构建自己的 ViewModel 类 新建 Java 类，继承至ViewModel，名字自定义，这里以MyViewModel为例。\npackage com.aimerneige.viewmoudeltest; import androidx.lifecycle.ViewModel; public class MyViewMoude extends ViewModel { } 新建好类之后，直接将需要用到的数据填写在内部，可以直接使用 public 的数据类型（不推荐），或者使用 private 数据加 get 方法。\npackage com.aimerneige.viewmoudletest; import androidx.lifecycle.ViewModel; public class MyViewMoude extends ViewModel { public int number = 0; public String test = \u0026#34;Test for 100\u0026#34;; private int age = 0; public int getAge() { return age; } public void setAge(int age) { this.age = age; } } 然后把ViewModel当成一个智能地存储数据的结构体使用即可。","title":"使用 ViewModel 管理布局上的数据"},{"content":"MaterialDesign 依赖库 implementation \u0026#39;com.google.android.material:material:1.1.0\u0026#39; 在布局文件中加入 TooBar \u0026lt;androidx.appcompat.widget.Toolbar android:id=\u0026#34;@+id/toolBar\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; \u0026lt;!--其他属性设置--\u0026gt; /\u0026gt; 关于旧版的说明\n旧版需要使用兼容包\ncompile 'com.android.support:appcompat-v7:23.1.1'\n使用以下布局方法\n\u0026lt;android.support.v7.widget.Toolbar android:id=\u0026#34;@+id/toolbar\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;标题\u0026#34; android:textSize=\u0026#34;20sp\u0026#34;/\u0026gt; \u0026lt;/android.support.v7.widget.Toolbar\u0026gt; 很多文章都是这么写的，此处代码也是拷贝的，但是在开发中出了一些问题，博主是没有成功运行，仅供参考，挂了请自行查阅资料，不做解释。这里主要介绍新版 ToolBar 的使用\n在 MainActivity 中引用 Toolbar Toolbar toolbar = findViewById(R.id.toolBar); 使用 ToolBar 作为界面布局 toolbar.setTitle(\u0026#34;AppBarLayoutTest\u0026#34;); setSupportActionBar(toolbar); 导包的时候导这个，不要导错了，否则会报错\nimport androidx.appcompat.widget.Toolbar;\n添加自定义属性 按需添加自定义属性，可以修改的内容包括标题的文字、图标、颜色等。不详细介绍，官方文档里很详细。\n官方文档：https://developer.android.com/reference/android/widget/Toolbar\n添加菜单 构建菜单的布局文件 这里添加的 item 会按顺序显示在 ToolBar 上面。\nshowAsAction 属性：\nalways:总是显示 ifRoom:空间足够时显示 never:永不显示（收纳在右侧的三条横线那个更多按钮里） \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;menu xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34;\u0026gt; \u0026lt;item android:id=\u0026#34;@+id/toolbar_setting\u0026#34; android:icon=\u0026#34;@drawable/ic_setting\u0026#34; android:title=\u0026#34;@string/toolbar_setting\u0026#34; app:showAsAction=\u0026#34;always\u0026#34; /\u0026gt; \u0026lt;item android:id=\u0026#34;@+id/toolbar_about\u0026#34; android:title=\u0026#34;@string/toolbar_about\u0026#34; app:showAsAction=\u0026#34;never\u0026#34; /\u0026gt; \u0026lt;item android:id=\u0026#34;@+id/toolbar_exit\u0026#34; android:title=\u0026#34;@string/toolbar_exit\u0026#34; app:showAsAction=\u0026#34;never\u0026#34; /\u0026gt; \u0026lt;/menu\u0026gt; 在主菜单中引用菜单的布局文件 @Override public boolean onCreateOptionsMenu(Menu menu) { getMenuInflater().inflate(R.menu.toolbar, menu); return true; } 设置菜单点击事件 @Override public boolean onOptionsItemSelected(@NonNull MenuItem item) { switch (item.getItemId()) { case android.R.id.home: drawerLayout.openDrawer(GravityCompat.START); break; case R.id.toolbar_setting: Toast.makeText(MainActivity.this, \u0026#34;Waiting for coding for setting\u0026#34;, Toast.LENGTH_SHORT).show(); break; case R.id.toolbar_about: Toast.makeText(MainActivity.this, \u0026#34;Waiting for coding for about\u0026#34;, Toast.LENGTH_SHORT).show(); break; case R.id.toolbar_exit: Toast.makeText(MainActivity.this, \u0026#34;Waiting for coding for exit\u0026#34;, Toast.LENGTH_SHORT).show(); break; default: break; } return true; } AppBarLayout 使用 AppBarLayout 可以给 ToolBar 定义更多的内容，并且 TabLayout 一般也是嵌套在其内部。\n这里省略了属性，主要关注布局层次即可。\n\u0026lt;com.google.android.material.appbar.AppBarLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34;\u0026gt; \u0026lt;androidx.appcompat.widget.Toolbar android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34;/\u0026gt; \u0026lt;com.google.android.material.tabs.TabLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;46dp\u0026#34;\u0026gt; \u0026lt;/com.google.android.material.tabs.TabLayout\u0026gt; \u0026lt;/com.google.android.material.appbar.AppBarLayout\u0026gt; 用 AppBarLayout 套住 ToolBar 即可，内部还可以嵌套一个 TabLayout。\n你也可以将整个布局放置在 CoordinatorLayout 中实现更好的效果。\n完整代码 代码很垃圾，只是一个壳子，凑合看\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;androidx.drawerlayout.widget.DrawerLayout android:id=\u0026#34;@+id/draw_layout\u0026#34; xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;androidx.coordinatorlayout.widget.CoordinatorLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;com.google.android.material.appbar.AppBarLayout android:id=\u0026#34;@+id/app_bar\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34;\u0026gt; \u0026lt;androidx.appcompat.widget.Toolbar android:id=\u0026#34;@+id/toolBar\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; app:titleTextColor=\u0026#34;@color/write\u0026#34; app:layout_scrollFlags=\u0026#34;scroll|enterAlwaysCollapsed\u0026#34;/\u0026gt; \u0026lt;com.google.android.material.tabs.TabLayout android:id=\u0026#34;@+id/tabLayout\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;46dp\u0026#34; android:minHeight=\u0026#34;46dp\u0026#34; app:tabMode=\u0026#34;fixed\u0026#34; app:layout_scrollFlags=\u0026#34;scroll|exitUntilCollapsed|enterAlways\u0026#34;\u0026gt; \u0026lt;com.google.android.material.tabs.TabItem android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Test1\u0026#34; /\u0026gt; \u0026lt;com.google.android.material.tabs.TabItem android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Test2\u0026#34; /\u0026gt; \u0026lt;com.google.android.material.tabs.TabItem android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Test3\u0026#34; /\u0026gt; \u0026lt;/com.google.android.material.tabs.TabLayout\u0026gt; \u0026lt;/com.google.android.material.appbar.AppBarLayout\u0026gt; \u0026lt;androidx.viewpager.widget.ViewPager android:id=\u0026#34;@+id/view_pager\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; app:layout_behavior=\u0026#34;@string/appbar_scrolling_view_behavior\u0026#34; /\u0026gt; \u0026lt;com.google.android.material.floatingactionbutton.FloatingActionButton android:id=\u0026#34;@+id/fab\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_gravity=\u0026#34;bottom|end\u0026#34; android:layout_margin=\u0026#34;16dp\u0026#34; android:src=\u0026#34;@drawable/ic_add\u0026#34; android:elevation=\u0026#34;8dp\u0026#34; /\u0026gt; \u0026lt;/androidx.coordinatorlayout.widget.CoordinatorLayout\u0026gt; \u0026lt;com.google.android.material.navigation.NavigationView android:id=\u0026#34;@+id/nav_view\u0026#34; android:layout_width=\u0026#34;300dp\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:layout_gravity=\u0026#34;start\u0026#34; app:headerLayout=\u0026#34;@layout/nav_header\u0026#34; app:menu=\u0026#34;@menu/nav_menu\u0026#34; /\u0026gt; \u0026lt;/androidx.drawerlayout.widget.DrawerLayout\u0026gt; package com.aimerneige.appbarlayoutyesy; import androidx.annotation.NonNull; import androidx.appcompat.app.ActionBar; import androidx.appcompat.app.AppCompatActivity; import androidx.appcompat.widget.Toolbar; import androidx.core.view.GravityCompat; import androidx.drawerlayout.widget.DrawerLayout; import androidx.viewpager.widget.ViewPager; import android.annotation.SuppressLint; import android.os.Bundle; import android.view.Menu; import android.view.MenuItem; import android.view.View; import android.widget.Toast; import com.google.android.material.appbar.AppBarLayout; import com.google.android.material.floatingactionbutton.FloatingActionButton; import com.google.android.material.navigation.NavigationView; import com.google.android.material.snackbar.Snackbar; import com.google.android.material.tabs.TabLayout; public class MainActivity extends AppCompatActivity { private DrawerLayout drawerLayout; @SuppressLint(\u0026#34;ResourceAsColor\u0026#34;) @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); AppBarLayout appBarLayout = findViewById(R.id.app_bar); Toolbar toolbar = findViewById(R.id.toolBar); TabLayout tabLayout = findViewById(R.id.tabLayout); ViewPager viewPager = findViewById(R.id.view_pager); NavigationView navigationView = findViewById(R.id.nav_view); FloatingActionButton fab = findViewById(R.id.fab); drawerLayout = findViewById(R.id.draw_layout); // Set toolbar as ActionBar toolbar.setTitle(\u0026#34;AppBarLayoutTest\u0026#34;); setSupportActionBar(toolbar); // Set menu icon ActionBar actionBar = getSupportActionBar(); if (actionBar != null) { actionBar.setDisplayHomeAsUpEnabled(true); actionBar.setHomeAsUpIndicator(R.drawable.ic_menu); } // Set TabLayout selected tabLayout.addOnTabSelectedListener(new TabLayout.OnTabSelectedListener() { @Override public void onTabSelected(TabLayout.Tab tab) { } @Override public void onTabUnselected(TabLayout.Tab tab) { } @Override public void onTabReselected(TabLayout.Tab tab) { } }); // Navigation selected navigationView.setCheckedItem(R.id.nav_alien); navigationView.setNavigationItemSelectedListener(new NavigationView.OnNavigationItemSelectedListener() { @Override public boolean onNavigationItemSelected(@NonNull MenuItem item) { switch (item.getItemId()) { case R.id.nav_alien: Toast.makeText(MainActivity.this, \u0026#34;alien\u0026#34;, Toast.LENGTH_SHORT).show(); break; case R.id.nav_games: Toast.makeText(MainActivity.this, \u0026#34;Games\u0026#34;, Toast.LENGTH_SHORT).show(); break; case R.id.nav_icecream: Toast.makeText(MainActivity.this, \u0026#34;IceCream\u0026#34;, Toast.LENGTH_SHORT).show(); break; case R.id.nav_camping: Toast.makeText(MainActivity.this, \u0026#34;Camping\u0026#34;, Toast.LENGTH_SHORT).show(); break; case R.id.nav_basketball: Toast.makeText(MainActivity.this, \u0026#34;Basketball\u0026#34;, Toast.LENGTH_SHORT).show(); break; case R.id.nav_cloud: Toast.makeText(MainActivity.this, \u0026#34;Cloud\u0026#34;, Toast.LENGTH_SHORT).show(); break; default: break; } return true; } }); fab.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Snackbar.make(v, \u0026#34;Waiting for coding\u0026#34;, Snackbar.LENGTH_LONG) .setAction(\u0026#34;Undo\u0026#34;, new View.OnClickListener() { @Override public void onClick(View v) { Toast.makeText(MainActivity.this, \u0026#34;Undo success\u0026#34;, Toast.LENGTH_SHORT).show(); } }).show(); } }); } // Set menu for toolbar @Override public boolean onCreateOptionsMenu(Menu menu) { getMenuInflater().inflate(R.menu.toolbar, menu); return true; } // ToolBar MenuOption @Override public boolean onOptionsItemSelected(@NonNull MenuItem item) { switch (item.getItemId()) { case android.R.id.home: drawerLayout.openDrawer(GravityCompat.START); break; case R.id.toolbar_setting: Toast.makeText(MainActivity.this, \u0026#34;Waiting for coding for setting\u0026#34;, Toast.LENGTH_SHORT).show(); break; case R.id.toolbar_about: Toast.makeText(MainActivity.this, \u0026#34;Waiting for coding for about\u0026#34;, Toast.LENGTH_SHORT).show(); break; case R.id.toolbar_exit: Toast.makeText(MainActivity.this, \u0026#34;Waiting for coding for exit\u0026#34;, Toast.LENGTH_SHORT).show(); break; default: break; } return true; } } ","permalink":"https://aimerneige.com/zh/post/android/toolbar/","summary":"MaterialDesign 依赖库 implementation \u0026#39;com.google.android.material:material:1.1.0\u0026#39; 在布局文件中加入 TooBar \u0026lt;androidx.appcompat.widget.Toolbar android:id=\u0026#34;@+id/toolBar\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; \u0026lt;!--其他属性设置--\u0026gt; /\u0026gt; 关于旧版的说明\n旧版需要使用兼容包\ncompile 'com.android.support:appcompat-v7:23.1.1'\n使用以下布局方法\n\u0026lt;android.support.v7.widget.Toolbar android:id=\u0026#34;@+id/toolbar\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;标题\u0026#34; android:textSize=\u0026#34;20sp\u0026#34;/\u0026gt; \u0026lt;/android.support.v7.widget.Toolbar\u0026gt; 很多文章都是这么写的，此处代码也是拷贝的，但是在开发中出了一些问题，博主是没有成功运行，仅供参考，挂了请自行查阅资料，不做解释。这里主要介绍新版 ToolBar 的使用\n在 MainActivity 中引用 Toolbar Toolbar toolbar = findViewById(R.id.toolBar); 使用 ToolBar 作为界面布局 toolbar.setTitle(\u0026#34;AppBarLayoutTest\u0026#34;); setSupportActionBar(toolbar); 导包的时候导这个，不要导错了，否则会报错\nimport androidx.appcompat.widget.Toolbar;\n添加自定义属性 按需添加自定义属性，可以修改的内容包括标题的文字、图标、颜色等。不详细介绍，官方文档里很详细。\n官方文档：https://developer.android.com/reference/android/widget/Toolbar\n添加菜单 构建菜单的布局文件 这里添加的 item 会按顺序显示在 ToolBar 上面。\nshowAsAction 属性：\nalways:总是显示 ifRoom:空间足够时显示 never:永不显示（收纳在右侧的三条横线那个更多按钮里） \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;menu xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34;\u0026gt; \u0026lt;item android:id=\u0026#34;@+id/toolbar_setting\u0026#34; android:icon=\u0026#34;@drawable/ic_setting\u0026#34; android:title=\u0026#34;@string/toolbar_setting\u0026#34; app:showAsAction=\u0026#34;always\u0026#34; /\u0026gt; \u0026lt;item android:id=\u0026#34;@+id/toolbar_about\u0026#34; android:title=\u0026#34;@string/toolbar_about\u0026#34; app:showAsAction=\u0026#34;never\u0026#34; /\u0026gt; \u0026lt;item android:id=\u0026#34;@+id/toolbar_exit\u0026#34; android:title=\u0026#34;@string/toolbar_exit\u0026#34; app:showAsAction=\u0026#34;never\u0026#34; /\u0026gt; \u0026lt;/menu\u0026gt; 在主菜单中引用菜单的布局文件 @Override public boolean onCreateOptionsMenu(Menu menu) { getMenuInflater().","title":"ToolBar"},{"content":"新建项目 导入 Gson 依赖\nimplementation \u0026#39;com.google.code.gson:gson:2.8.5\u0026#39; 设计布局 这里设计俩个 TextView 和一个 Button，点击 Button 后发送 Http 请求获取 Json 数据，并且通过 Gson 进行解析，将解析结果显示在 TextView 上，以此验证解析成功。\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/text1\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;nodata\u0026#34;/\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/text2\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;nodata\u0026#34;/\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/button\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;test\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; 代码很简单就不多解释了。另外 在 Activity 中注册控件 的内容也省略。\n发送 Http 请求并获取数据 操作同一般的 HTML 源码获取，这里不多解释。由于保存在网络上的 Json 数据其源码就是合法的 Json 字符串，因此通过解析网页源码的方法获取的内容就是 Json 数据。这里有一个网页保存了 Json 数据，可用于测试。\nhttps://user.moecraft.net:8443/API/Mc/authlib/ 获取源码之后将其保存在一个字符串内即可继续进行下一步操作。此处命名为 jsonData。\n利用 GsonFormat 插件生成映射对象 具体操作方法不解释了，具体看之前发布的博客文章。这里新建的类命名为 ApiTest 。\n以下代码为 GsonFormat 自动生成。\nimport java.util.List; public class ApiTest { /** * meta : {\u0026#34;serverName\u0026#34;:\u0026#34;MoeCraft\u0026#34;,\u0026#34;implementationName\u0026#34;:\u0026#34;MoeCraft Account Center: Minecraft Yggdrasil API (Completely Implemented by Kenvix) for Authlib-Injector 1.1.23\u0026#34;,\u0026#34;implementationVersion\u0026#34;:\u0026#34;5.0\u0026#34;} * skinDomains : [\u0026#34;.moecraft.net\u0026#34;,\u0026#34;.kenvix.com\u0026#34;,\u0026#34;accounts.moecraft.net\u0026#34;,\u0026#34;user.moecraft.net\u0026#34;,\u0026#34;user.moecraft.net:8443\u0026#34;,\u0026#34;localhost\u0026#34;] * signaturePublickey : -----BEGIN PUBLIC KEY----- MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDYM0MxKIv4ybovs4XlwMk4g/0r O4+HDK+ltpFDkFjiBY5pDHK4J5Z2tdtkliK7DC2mwIAK5wOeTXYb9uHO8VAVxuE9 enMSOiVl9uvSVPelDU/t/JH3gSE6yYT7aNHT6xpvqnSQrCUGDvTbsqXvjxEr3F/H zORoqhiGR+F27XfOhQIDAQAB -----END PUBLIC KEY----- * status : 0 * info : */ private MetaBean meta; private String signaturePublickey; private int status; private String info; private List\u0026lt;String\u0026gt; skinDomains; public MetaBean getMeta() { return meta; } public void setMeta(MetaBean meta) { this.meta = meta; } public String getSignaturePublickey() { return signaturePublickey; } public void setSignaturePublickey(String signaturePublickey) { this.signaturePublickey = signaturePublickey; } public int getStatus() { return status; } public void setStatus(int status) { this.status = status; } public String getInfo() { return info; } public void setInfo(String info) { this.info = info; } public List\u0026lt;String\u0026gt; getSkinDomains() { return skinDomains; } public void setSkinDomains(List\u0026lt;String\u0026gt; skinDomains) { this.skinDomains = skinDomains; } public static class MetaBean { /** * serverName : MoeCraft * implementationName : MoeCraft Account Center: Minecraft Yggdrasil API (Completely Implemented by Kenvix) for Authlib-Injector 1.1.23 * implementationVersion : 5.0 */ private String serverName; private String implementationName; private String implementationVersion; public String getServerName() { return serverName; } public void setServerName(String serverName) { this.serverName = serverName; } public String getImplementationName() { return implementationName; } public void setImplementationName(String implementationName) { this.implementationName = implementationName; } public String getImplementationVersion() { return implementationVersion; } public void setImplementationVersion(String implementationVersion) { this.implementationVersion = implementationVersion; } } } 源 Json 数据中内容较多，这里我们只挑选部分内容基础进行测试。\n此处我们选择解析的对象（目标）是 MetaBean 下的 serverName 和 implementationName 字段。\n通过 Gson 解析对应内容 构建 Gson 对象 Gson gson = new Gson(); 通过 Gson 解析来构建 ApiTest 实体类 ApiTest apiTest = gson.fromJson(jsonData, ApiTest.class); 直接通过 get 方法访问 apiTest 实体类中的内容即可 text1.setText(apiTest.getMeta().getServerName()); text2.setText(apiTest.getMeta().getImplementationName()); 结束 其实很简单，利用谷歌提供的 Gson 配合 GsonFormat 简直不要太爽。\n","permalink":"https://aimerneige.com/zh/post/android/gson/","summary":"新建项目 导入 Gson 依赖\nimplementation \u0026#39;com.google.code.gson:gson:2.8.5\u0026#39; 设计布局 这里设计俩个 TextView 和一个 Button，点击 Button 后发送 Http 请求获取 Json 数据，并且通过 Gson 进行解析，将解析结果显示在 TextView 上，以此验证解析成功。\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/text1\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;nodata\u0026#34;/\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/text2\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;nodata\u0026#34;/\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/button\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;test\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; 代码很简单就不多解释了。另外 在 Activity 中注册控件 的内容也省略。\n发送 Http 请求并获取数据 操作同一般的 HTML 源码获取，这里不多解释。由于保存在网络上的 Json 数据其源码就是合法的 Json 字符串，因此通过解析网页源码的方法获取的内容就是 Json 数据。这里有一个网页保存了 Json 数据，可用于测试。\nhttps://user.moecraft.net:8443/API/Mc/authlib/ 获取源码之后将其保存在一个字符串内即可继续进行下一步操作。此处命名为 jsonData。\n利用 GsonFormat 插件生成映射对象 具体操作方法不解释了，具体看之前发布的博客文章。这里新建的类命名为 ApiTest 。","title":"使用 Gson 解析 Json 数据"},{"content":"Ubuntu 19.10 配置 Kotlin 开发环境 使用工具 VSCode\n安装 Kotlin 编译器 sudo snap install kotlin --classic 如果出现错误，执行以下命令：\nsudo apt install snap 这条指令执行后，系统安装的内容有：\nkotlinc kotlinc-jvm kotlinc-js kotlin-dce-js 可以通过以下指令查看版本，如果有输出证明安装成功。\n俩条指令都可以，建议使用上面的。\nkotlin -version kotlinc -version 安装插件 这俩个貌似安装一个就可以了，也可以都安装。\nKotlin Kotlin Language 安装下面这个插件后在 文件 -\u0026gt; 首选项 -\u0026gt; 设置 -\u0026gt; 扩展 -\u0026gt; Run Code Configuration 中找到并勾选 Run In Terminal\nCode Runner 测试 建立新文件 HelloWorld.kt fun main(args: Array\u0026lt;String\u0026gt;) { println(\u0026#34;Hello, World!\u0026#34;) } 通过点击右上角三角形（由 Code Runner 提供的快捷方式）来编译运行，查看输出。\n如果看到终端输出 Hello, World! 的内容，说明开发环境搭建成功。\n参考内容： https://askubuntu.com/questions/917223/installing-kotlin-securely-with-package-signatures-auto-update-etc 当然你也可以直接用 intellj-idea\n","permalink":"https://aimerneige.com/zh/post/linux/kotlin-on-ubuntu-19-10/","summary":"Ubuntu 19.10 配置 Kotlin 开发环境 使用工具 VSCode\n安装 Kotlin 编译器 sudo snap install kotlin --classic 如果出现错误，执行以下命令：\nsudo apt install snap 这条指令执行后，系统安装的内容有：\nkotlinc kotlinc-jvm kotlinc-js kotlin-dce-js 可以通过以下指令查看版本，如果有输出证明安装成功。\n俩条指令都可以，建议使用上面的。\nkotlin -version kotlinc -version 安装插件 这俩个貌似安装一个就可以了，也可以都安装。\nKotlin Kotlin Language 安装下面这个插件后在 文件 -\u0026gt; 首选项 -\u0026gt; 设置 -\u0026gt; 扩展 -\u0026gt; Run Code Configuration 中找到并勾选 Run In Terminal\nCode Runner 测试 建立新文件 HelloWorld.kt fun main(args: Array\u0026lt;String\u0026gt;) { println(\u0026#34;Hello, World!\u0026#34;) } 通过点击右上角三角形（由 Code Runner 提供的快捷方式）来编译运行，查看输出。\n如果看到终端输出 Hello, World!","title":"Ubuntu 19.10 配置 Kotlin 开发环境"},{"content":" 通过网络连接获取图片信息，并将其设为软件的 ImageView 图片属性\n介绍： 与获取 HTML 类似，首先需要建立网络连接并获取数据，只是这次不通过 String 获取保存数据，而是使用 Bitmap 保存。\n与获取 HTML 数据类似，联网操作同样需要新建线程，要注意的是在子线程不能操作 UI，需要通过外部函数设置图片或者在函数返回 Bitmap 对象使用。\n核心代码： 建立网络连接，这里使用 HttpURLConnection URL url = new URL(\u0026#34;https://www.example.com.img\u0026#34;) HttpURLConnection connection = (HttpURLConnection) url.openConnection(); connection.setRequestMethod(\u0026#34;GET\u0026#34;); // ...... // 诸如超时时间等的设置 处理返回数据 InputStream is = connection.getInputStream(); Bitmap bitmap = BitmapFactory.decodeStream(is); 设置控件，注意该操作不能在子线程中进行 imageView.setImageBitmap(bitmap); 完整代码 代码很烂，有很多可以优化的地方\n//设置网络图片 public void setUrlImage(final int ImageViewId, final String address) { //开启一个线程用于联网 new Thread(new Runnable() { @Override public void run() { try { //把传过来的路径转成URL URL url = new URL(address); //获取连接 HttpURLConnection connection = (HttpURLConnection) url.openConnection(); //使用GET方法访问网络 connection.setRequestMethod(\u0026#34;GET\u0026#34;); //超时时间为10秒 connection.setConnectTimeout(10000); //获取返回码 int code = connection.getResponseCode(); if (code == 200) { InputStream inputStream = connection.getInputStream(); //使用工厂把网络的输入流生产Bitmap Bitmap bitmap = BitmapFactory.decodeStream(inputStream); //子线程不能操作UI，通过外部函数设置图片 setImage(ImageViewId, bitmap); inputStream.close(); } else { //服务启发生错误，显示提示信息 Toast.makeText(HttpImage.this, \u0026#34;Can\u0026#39;t get the image from Internet.\u0026#34;, Toast.LENGTH_SHORT).show(); } } catch (Exception e) { e.printStackTrace(); } } }).start(); } public void setImage(int ImageViewId, Bitmap bitmap) { ImageView imageView = findViewById(ImageViewId); imageView.setImageBitmap(bitmap); } 一些废话 实际上和处理 HTML 是类似的，只不过不再使用 String 处理服务器返回的数据。\n","permalink":"https://aimerneige.com/zh/post/android/web-image/","summary":"通过网络连接获取图片信息，并将其设为软件的 ImageView 图片属性\n介绍： 与获取 HTML 类似，首先需要建立网络连接并获取数据，只是这次不通过 String 获取保存数据，而是使用 Bitmap 保存。\n与获取 HTML 数据类似，联网操作同样需要新建线程，要注意的是在子线程不能操作 UI，需要通过外部函数设置图片或者在函数返回 Bitmap 对象使用。\n核心代码： 建立网络连接，这里使用 HttpURLConnection URL url = new URL(\u0026#34;https://www.example.com.img\u0026#34;) HttpURLConnection connection = (HttpURLConnection) url.openConnection(); connection.setRequestMethod(\u0026#34;GET\u0026#34;); // ...... // 诸如超时时间等的设置 处理返回数据 InputStream is = connection.getInputStream(); Bitmap bitmap = BitmapFactory.decodeStream(is); 设置控件，注意该操作不能在子线程中进行 imageView.setImageBitmap(bitmap); 完整代码 代码很烂，有很多可以优化的地方\n//设置网络图片 public void setUrlImage(final int ImageViewId, final String address) { //开启一个线程用于联网 new Thread(new Runnable() { @Override public void run() { try { //把传过来的路径转成URL URL url = new URL(address); //获取连接 HttpURLConnection connection = (HttpURLConnection) url.","title":"设置网络图片"},{"content":"插件安装 File Settings Plugins Marketplace 在搜索框输入 GsonFormat 搜索 安装相应插件 根据提示重启 IDE 使用方法 新建实体类 ALT + Insert 或者 右键-\u0026gt;Generate 选择 GsonFormat 将待解析 Json 字符串输入弹出的对话框 OK ","permalink":"https://aimerneige.com/zh/post/android/gson-format/","summary":"插件安装 File Settings Plugins Marketplace 在搜索框输入 GsonFormat 搜索 安装相应插件 根据提示重启 IDE 使用方法 新建实体类 ALT + Insert 或者 右键-\u0026gt;Generate 选择 GsonFormat 将待解析 Json 字符串输入弹出的对话框 OK ","title":"使用 GsonFormat 插件快速构建 Json 映射对象"},{"content":"GoogleDoc\nGoogleGithub\n声明依赖项 直接复制官方文档，不多解释了（懒\n在应用或模块的 build.gradle 文件中添加所需工件的依赖项：\ndependencies { implementation \u0026#34;androidx.swiperefreshlayout:swiperefreshlayout:1.0.0\u0026#34; } 如需详细了解依赖项，请参阅添加编译依赖项。\n添加布局 在 xml 布局文件中添加 SwipeRefreshLayout，并将 WebView 内嵌在 SwipeRefreshLayout 中。\n布局这里拷贝了别人的代码，结果软件闪退，搞了半天找不到原因，重开了一个项目，根据代码提示写了一份居然可以运行，分明代码一样的，好迷啊。。。。。\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; tools:context=\u0026#34;.MainActivity\u0026#34;\u0026gt; \u0026lt;androidx.swiperefreshlayout.widget.SwipeRefreshLayout android:id=\u0026#34;@+id/swipe_refresh\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;WebView android:id=\u0026#34;@+id/web_view\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; /\u0026gt; \u0026lt;/androidx.swiperefreshlayout.widget.SwipeRefreshLayout\u0026gt; \u0026lt;/LinearLayout\u0026gt; SwipeRefreshLayout 类似 ScrollView，内部只能有一个部件，但是你可以这样玩、（手动滑稽\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;ScrollView xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;test_scroll\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; /\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;test_scroll\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; /\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;test_scroll\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; /\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;test_scroll\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; /\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;test_scroll\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; /\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;test_scroll\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; /\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;test_scroll\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; /\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;test_scroll\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; /\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;test_scroll\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; /\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;test_scroll\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; /\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;test_scroll\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; /\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;test_scroll\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; /\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;test_scroll\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; /\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;test_scroll\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; /\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;test_scroll\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; /\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;test_scroll\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; /\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;test_scroll\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; /\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;test_scroll\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; /\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;test_scroll\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; /\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;test_scroll\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; /\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;test_scroll\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; /\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;test_scroll\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; /\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;test_scroll\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; /\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;test_scroll\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; /\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;test_scroll\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;/ScrollView\u0026gt; 编写代码部分 先放一个完整的源码，看不懂直接跳过，下面介绍关于 Swiperefreshlayout 的核心代码\npackage com.aimerneige.bingsearchlite; import androidx.appcompat.app.AppCompatActivity; import androidx.swiperefreshlayout.widget.SwipeRefreshLayout; import android.annotation.SuppressLint; import android.os.Bundle; import android.view.KeyEvent; import android.webkit.WebView; import android.webkit.WebViewClient; public class MainActivity extends AppCompatActivity { WebView webView; SwipeRefreshLayout swipe_refresh; @SuppressLint(\u0026#34;SetJavaScriptEnabled\u0026#34;) @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); webView = findViewById(R.id.web_view); webView.getSettings().setJavaScriptEnabled(true); // 启用JavaScript脚本支持 webView.loadUrl(\u0026#34;https://www.bing.com/\u0026#34;); webView.setWebViewClient(new MyWebViewClient()); swipe_refresh = findViewById(R.id.swipe_refresh); swipe_refresh.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() { @Override public void onRefresh() { webView.reload(); swipe_refresh.setRefreshing(false); } }); } // 解决点击返回直接退出的问题 @Override public boolean onKeyDown(int keyCode, KeyEvent event) { if(keyCode==KeyEvent.KEYCODE_BACK \u0026amp;\u0026amp; webView.canGoBack()){ // 如果点击了返回建且当前网页可以后退时，调用后退 webView.goBack(); return true; } else { // 否则调用原有功能 return super.onKeyDown(keyCode, event); } } public class MyWebViewClient extends WebViewClient { @Override public void onPageFinished(WebView view, String url) { // 插入JavaScript脚本，去除底部烦人的下载手机必应的提示 String js = \u0026#34;javascript:var m = document.getElementById(\\\u0026#34;BottomAppPro\\\u0026#34;);\u0026#34; + \u0026#34;m.parentNode.removeChild(m);\u0026#34;; view.loadUrl(js); } } } 定义引用变量 SwipeRefreshLayout swipe_refresh; 引用对应控件 swipe_refresh = findViewById(R.id.swipe_refresh); 设置刷新监听器 swipe_refresh.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() { @Override public void onRefresh() { webView.reload(); swipe_refresh.setRefreshing(false); } }); 其中：\nwebView.reload();进行网页的刷新（没有的话是假刷新，只显示刷新动画而不刷新内容）\nswipe_refresh.setRefreshing(false);关闭刷新动画（没有的话网页会一直刷新）\n其他部分 注释里有，就不解释了（懒\n","permalink":"https://aimerneige.com/zh/post/android/swiperefreshlayout/","summary":"GoogleDoc\nGoogleGithub\n声明依赖项 直接复制官方文档，不多解释了（懒\n在应用或模块的 build.gradle 文件中添加所需工件的依赖项：\ndependencies { implementation \u0026#34;androidx.swiperefreshlayout:swiperefreshlayout:1.0.0\u0026#34; } 如需详细了解依赖项，请参阅添加编译依赖项。\n添加布局 在 xml 布局文件中添加 SwipeRefreshLayout，并将 WebView 内嵌在 SwipeRefreshLayout 中。\n布局这里拷贝了别人的代码，结果软件闪退，搞了半天找不到原因，重开了一个项目，根据代码提示写了一份居然可以运行，分明代码一样的，好迷啊。。。。。\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; tools:context=\u0026#34;.MainActivity\u0026#34;\u0026gt; \u0026lt;androidx.swiperefreshlayout.widget.SwipeRefreshLayout android:id=\u0026#34;@+id/swipe_refresh\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;WebView android:id=\u0026#34;@+id/web_view\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; /\u0026gt; \u0026lt;/androidx.swiperefreshlayout.widget.SwipeRefreshLayout\u0026gt; \u0026lt;/LinearLayout\u0026gt; SwipeRefreshLayout 类似 ScrollView，内部只能有一个部件，但是你可以这样玩、（手动滑稽\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;ScrollView xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;test_scroll\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; /\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;test_scroll\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; /\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;test_scroll\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; /\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;test_scroll\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; /\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;test_scroll\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; /\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;test_scroll\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; /\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;test_scroll\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; /\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;test_scroll\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; /\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;test_scroll\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; /\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;test_scroll\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; /\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;test_scroll\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; /\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;test_scroll\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; /\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;test_scroll\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; /\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;test_scroll\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; /\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;test_scroll\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; /\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;test_scroll\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; /\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;test_scroll\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; /\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;test_scroll\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; /\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;test_scroll\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; /\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;test_scroll\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; /\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;test_scroll\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; /\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;test_scroll\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; /\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;test_scroll\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; /\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;test_scroll\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; /\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;test_scroll\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;/ScrollView\u0026gt; 编写代码部分 先放一个完整的源码，看不懂直接跳过，下面介绍关于 Swiperefreshlayout 的核心代码","title":"Swiperefreshlayout"},{"content":"前言 之前由于感兴趣而涉足 Linux 领域，在虚拟机内尝试了 Ubuntu，可惜虚拟机内性能有限，于是以双系统的形式安装了 Ubuntu18.04。\n经过一段时间的使用后，感觉 Ubuntu 完全可以作为日常系统使用，于是放弃了 bug 不断的 Windows 系统，做好备份后直接全盘安装了 Ubuntu 系统，Windows 下的软件找不到替代品就转向虚拟机使用。\n个人感觉 Ubuntu 是完全可以替代 Windows 日常使用的，以下是 Ubuntu 相比于 Windows 的一些优点和不足\n优点 更加稳定 更加安全 不会整天提醒你更新系统 配置开发环境仅需几行终端指令 忘记恼人的弹窗广告和流氓软件吧 不足 很多软件不支持 Linux，只能在 Windows 上运行 几乎 90% 的游戏都不支持 Linux 需要学习命令行 界面丑 对策：\nWindows 下的软件可以直接在虚拟机下运行，不想挂个虚拟机的话也可以考虑使用 Wine 游戏还是不要玩了，装个 Ubuntu 学 Linux 顺带还能帮你戒游戏，实在需要玩游戏的可以使用双系统 命令行也不是特别难，遇到问题谷歌一下就行了 至于界面丑，我指的是 Ubuntu18.04 及 之前的版本，这些问题可以通过安装主题和图标包来解决，而最新的 Ubuntu19.10 界面还是十分惊艳的 Ubuntu 的安装 访问 Ubuntu 官网下载最新的镜像文件\n使用 Etcher 写入 U 盘作为启动盘\n通过 U 盘启动系统\n依照图形化安装程序进行安装\n系统安装好之后就可以开始使用激动人心的 Ubuntu19.10 了！\n（Emmmm，这个之后补图详细介绍吧）\n软件配置 安装好系统之后，还需要进行软件的配置，才能作为日常的使用。\n下面是博主的配置过程，仅供参考。\n换源 俗话说的好，装好 Linux 后第一件事就是换源。\n由于不同地区网络不同，我用起来很快的源你用可能会很慢，所以这里推荐大家自己百度，多试几个，选一个稳定高速的。\n实际上 Ubuntu 官方源在国内也是可以直接用的，博主就没有更换，默认官方源使用。\n可以通过 speedtest 工具检测网络问题是否是由于网卡驱动导致。\n首先安装 python3 sudo apt install python3 -y 安装 pip sudo apt install python-pip -y 安装 speedtest 工具 sudo pip install speedtest-cli 进行测速 speedtest 安装之后随时都可以使用 speedtest 指令测速，有关该 python 小工具的更多功能请自行谷歌\n如果测速结果正常但是安装软件却很慢说明网卡没有问题，可以考虑更换国内镜像源\n更新系统 不管有没有换源，首先更新系统\nsudo apt update \u0026amp;\u0026amp; sudo apt upgrade 安装开发环境 安装 git sudo apt install git 安装 java 运行环境 jre sudo apt install openjdk-8-jre jdk sudo apt install openjdk-8-jdk 安装 gcc 编译器 sudo apt install gcc 安装 g++编译器 sudo apt install g++ 安装 adb 调试工具 sudo apt install adb 安装 chrome 这条终端指令安装的是开源的 chromium\nsudo apt install chromium-browser 如果想要正式版的 chrome 可以去 chrome 官网下载 deb 包安装\n更换 vim 系统自带的 vi 太难用了，安装 vim 替换\nsudo apt install vim 当然你也可以使用gedit或者nano\n安装 typora 装机必备啊，写博客什么的很舒服。\n官网有最新安装命令（以官网为主）\nwget -qO - https://typora.io/linux/public-key.asc | sudo apt-key add - sudo add-apt-repository \u0026#39;deb https://typora.io/linux ./\u0026#39; sudo apt-get update sudo apt-get install typora 网络代理 自行谷歌\n软件 在官网下载 deb 包进行安装\nVSC VirtuaBox\n网易云音乐\n等宽字体 下载 FiraCode 字体文件\n将 otf 字体文件保存到一文件夹内，这里以~/Downloads/FiraCode为例\n在/usr/local/share/fonts/目录下创建自定义文件夹名，这里以FiraCode为例\ncd /usr/local/hare/fonts/ mkdir FiraCode cd 到字体文件目录\ncd ~/Downloads/FiraCode/ 移动字体文件\nsudo mv * /usr/local/share/fonts/FiraCode/ // 或者使用cp命令拷贝 切换到字体目录\ncd /usr/local/share/fonts/FiraCode/ 建立字体缓存\nsudo fc-cache -fv 配置 VSC 调整字体 更改字体为 FiraCode\n更改字体大小，粗度\n下载必备扩展包 主题美化 One Dark Pro Material Icon Theme Material Theme\nC 语言 C/C++ Code Runner\nJava Language support for Java ™ for Visual Studio Code Debugger for Java Java Test Runner Java Extension Pack\n按需下载其他扩展包 配置 AndroidStudio 官网下载安装包\n提取文件到某一目录\n移动文件到/opt\nmv /opt cd 到安装目录\ncd /opt/android-studio/bin 通过指令运行\nrun with ./studio.sh 不嫌烦的话可以使用指令启动软件\n想添加桌面图标的编辑如下文件\ngedit ~/.local/share/applications/androidstudio.desktop 添加以下内容\nand add the lines below [Desktop Entry] Version=1.0 Type=Application Name=Android Studio Exec=\u0026#34;/opt/android-studio/bin/studio.sh\u0026#34; %f Icon=/opt/android-studio/bin/studio.png Categories=Development;IDE; Terminal=false StartupNotify=true StartupWMClass=android-studio JB 全家桶均可按照此方法安装，具体配置文件建议谷歌\n","permalink":"https://aimerneige.com/zh/post/linux/ubuntu-install/","summary":"前言 之前由于感兴趣而涉足 Linux 领域，在虚拟机内尝试了 Ubuntu，可惜虚拟机内性能有限，于是以双系统的形式安装了 Ubuntu18.04。\n经过一段时间的使用后，感觉 Ubuntu 完全可以作为日常系统使用，于是放弃了 bug 不断的 Windows 系统，做好备份后直接全盘安装了 Ubuntu 系统，Windows 下的软件找不到替代品就转向虚拟机使用。\n个人感觉 Ubuntu 是完全可以替代 Windows 日常使用的，以下是 Ubuntu 相比于 Windows 的一些优点和不足\n优点 更加稳定 更加安全 不会整天提醒你更新系统 配置开发环境仅需几行终端指令 忘记恼人的弹窗广告和流氓软件吧 不足 很多软件不支持 Linux，只能在 Windows 上运行 几乎 90% 的游戏都不支持 Linux 需要学习命令行 界面丑 对策：\nWindows 下的软件可以直接在虚拟机下运行，不想挂个虚拟机的话也可以考虑使用 Wine 游戏还是不要玩了，装个 Ubuntu 学 Linux 顺带还能帮你戒游戏，实在需要玩游戏的可以使用双系统 命令行也不是特别难，遇到问题谷歌一下就行了 至于界面丑，我指的是 Ubuntu18.04 及 之前的版本，这些问题可以通过安装主题和图标包来解决，而最新的 Ubuntu19.10 界面还是十分惊艳的 Ubuntu 的安装 访问 Ubuntu 官网下载最新的镜像文件\n使用 Etcher 写入 U 盘作为启动盘\n通过 U 盘启动系统","title":"如何安装 Ubuntu"},{"content":"// 生成一系列0~9之间的随机整数 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;time.h\u0026gt; int main() { srand( time(NULL) ); int ret; for (int i = 0; i \u0026lt; 20; i++) { ret = rand() % 10; // ret是一个0~9之间的随机整数 printf(\u0026#34;%d \u0026#34;, ret); } return 0; } 输出结果\n7 6 6 1 6 9 2 7 1 8 2 0 5 9 2 5 4 0 0 0 这是啥啊？看不懂啊。 不要着急，我来慢慢讲 首先是一个最简单的随机数：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { int ret = rand(); printf(\u0026#34;%d\u0026#34;, ret); return 0; } 输出结果\n41 这里用到了rand()这个函数，使用这个函数需要引入stdlib.h这个头文件，函数返回一个随机数，生成的随机数都是整数，所以我们把它交给一个int的变量。然后使用printf函数输出即可看到结果。当然，由于我们使用了printf函数，我们还需要引入stdio.h 这个头文件。\n但是我们如果多次运行，发现结果始终是 41，这是怎么回事呢？\n这里要了解 C 语言随机数的生成机制：\n在 C 语言中,rand()函数可以用来产生随机数，但是这不是真真意义上的随机数，是一个伪随机数，是根据一个数，我们可以称它为种子，为基准以某个递推公式推算出来的一系数，当这系列数很大的时候，就符合正态公布，从而相当于产生了随机数，但这不是真正的随机数，当计算机正常开机后，这个种子的值是定了的，除非你破坏了系统，为了改变这个种子的值，C 提供了 srand()函数，它的原形是 void srand( int a)。\n这又是啥啊？看不懂啊。 没关系，继续向下看 看这个程序\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { int ret; for (int i = 0; i \u0026lt; 200; i++) { ret = rand(); printf(\u0026#34;%d \u0026#34;, ret); } return 0; } 输出结果\n41 18467 6334 26500 19169 15724 11478 29358 26962 24464 5705 28145 23281 16827 9961 491 2995 11942 4827 5436 32391 14604 3902 153 292 12382 17421 18716 19718 19895 5447 21726 14771 11538 1869 19912 25667 26299 17035 9894 28703 23811 31322 30333 17673 4664 15141 7711 28253 6868 25547 27644 32662 32757 20037 12859 8723 9741 27529 778 12316 3035 22190 1842 288 30106 9040 8942 19264 22648 27446 23805 15890 6729 24370 15350 15006 31101 24393 3548 19629 12623 24084 19954 18756 11840 4966 7376 13931 26308 16944 32439 24626 11323 5537 21538 16118 2082 22929 16541 4833 31115 4639 29658 22704 9930 13977 2306 31673 22386 5021 28745 26924 19072 6270 5829 26777 15573 5097 16512 23986 13290 9161 18636 22355 24767 23655 15574 4031 12052 27350 1150 16941 21724 13966 3430 31107 30191 18007 11337 15457 12287 27753 10383 14945 8909 32209 9758 24221 18588 6422 24946 27506 13030 16413 29168 900 32591 18762 1655 17410 6359 27624 20537 21548 6483 27595 4041 3602 24350 10291 30836 9374 11020 4596 24021 27348 23199 19668 24484 8281 4734 53 1999 26418 27938 6900 3788 18127 467 3728 14893 24648 22483 17807 2421 14310 6617 22813 9514 这一次我们不是输出一次，而是输出 200 次，这时候我们发现，得到的结果有大有小，几乎都不同。rand函数的返回值确实是随机数，但是和上面一样，我们多次运行得到的还是一样的结果。\n为什么一样？问题出在哪了呢？ 随机数种子 如果单纯从结果来看，我们得到的这些数据确实是随机的（符合正态分布），也就是说，系统会使用系统内部预定义的随机数种子来进行某个复杂的计算得到一系列数，这些数符合正态分布，也就实现了随机数，由于算法是一致的，只要不去破坏系统，系统给定的种子不会改变，那么我们得到的结果就是一样的。\n如果你不想考虑太多的话，我们可以直接使用rand()函数生成随机数，比如这样：\n// 生成一系列0~9之间的随机整数 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { int ret; for (int i = 0; i \u0026lt; 20; i++) { ret = rand() % 10; // ret是一个0~9之间的随机整数 printf(\u0026#34;%d \u0026#34;, ret); } return 0; } 输出结果\n1 7 4 0 9 4 8 8 2 4 5 5 1 7 1 1 5 2 7 6 这样确实可以实现随机数的功能，唯一的缺点就是得到的结果在每次运行程序都是是一致的。\n那么如何改变种子呢？ 使用srand()函数 在不破坏系统的情况下，如果我们想要设置自己的种子的话，可以使用srand()函数。\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { srand( 20191218 ); // 在这里设置种子，你可以填写任何你喜欢的数字 int ret; for (int i = 0; i \u0026lt; 20; i++) { ret = rand() % 10; // ret是一个0~9之间的随机整数 printf(\u0026#34;%d \u0026#34;, ret); } return 0; } 输出结果\n4 6 1 6 2 3 6 8 2 3 0 6 4 4 7 0 8 7 4 4 我们得到了和上面不一样的结果，但是，如果我们继续运行的话，结果依然是不变的。\n这时你可能会气急败坏：\n从一个圈里跳到另一个圈里？有什么用啊？还不是一样的？难道要我每次运行之前都去手动更改随机数种子吗？\n不要生气嘛，至少你学会了如何改变随机数的种子。\n我不想要这样的结果啊，我想要每次运行都能得到不同的结果。 不要着急，这里有完美的解决方案 首先我们要先认识一下time()函数\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;time.h\u0026gt; int main() { printf(\u0026#34;%d\u0026#34;, time(NULL)); return 0; } 输出结果\n1576683441 调用time()后，我们得到了一个非常大的数字。\n这是什么啊？ 当前日历时间 函数原型: time_t time(time_t *timer)\n参数说明: timer=NULL 时得到当前日历时间（从 1970-01-01 00:00:00 到现在的秒数），timer=时间数值时，用于设置日历时间，time_t 是一个 unsigned long 类型。如果 timer 不为空，则返回值也存储在变量 timer 中。\n函数功能: 得到当前日历时间或者设置日历时间\n函数返回: 当前日历时间\n也就是说，调用time(NULL)会得到当前时间，回到之前的问题，每次运行程序的时间一般是不同的，如果我们使用time(NULL)作为种子的话，每次运行程序计算机都会生成一个不同的数字给我们，那么我们就可以得到不同的随机数了。\n原来如此，但是如果我想得到固定范围内的随机数改怎么做呢？ 取余 我们得到的数都是比较大的整数，如果我们需要特定范围内的数，直接进行取余操作就可以了。\n例如：\nrand() % 100 // 0~99 rand() % 20 // 0~19 rand() % 40 + 1 // 1~40 rand() % 41 - 10 // -10~30 其他依次类推。\n好了，我学会了！ 不要急，还有呢。 到这里基本的操作应该都结束了，但是如果你觉得这样就结束的话，那真是：\nToo young too simple.\n（狗头保命）\n为了便于使用，当然是要封装成函数来调用啊！\nint randNum(int start, int end) { end++; int ret; int det; det = end - start; ret = rand() % (det) + start; return ret; } 这样用起来是不是舒服很多了呢？\n好了，本教程到此结束。\n","permalink":"https://aimerneige.com/zh/post/c/c-random-number/","summary":"// 生成一系列0~9之间的随机整数 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;time.h\u0026gt; int main() { srand( time(NULL) ); int ret; for (int i = 0; i \u0026lt; 20; i++) { ret = rand() % 10; // ret是一个0~9之间的随机整数 printf(\u0026#34;%d \u0026#34;, ret); } return 0; } 输出结果\n7 6 6 1 6 9 2 7 1 8 2 0 5 9 2 5 4 0 0 0 这是啥啊？看不懂啊。 不要着急，我来慢慢讲 首先是一个最简单的随机数：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { int ret = rand(); printf(\u0026#34;%d\u0026#34;, ret); return 0; } 输出结果","title":"面向小白的 C 语言随机数详解"},{"content":"排名不分先后，按照添加时间排序。\n伞 一只咸鱼的学习记录 HelloWorld的小博客 这里是一个小白的博客 Kenvix 党明学姐 HeoLis We need to go faster and deeper. 🔨 🔨のBlog 异国迷宫的十字路口 一位弱鸡带学生的个人博客 Gaein nidb Gaein nidb的网站 fzf404 fzf的网站 凛凛酱 傻逼凛凛 iNetech Blog 凡心所向，素履所往 vritser 半斤八两 Anduin Xue Software engineer at 𝙈𝙞𝙘𝙧𝙤𝙨𝙤𝙛𝙩. Holk AI researcher 喵雨の小屋 努力学习中… MoreYu 来这里摸鱼吧 fissssssh Chinese software engineer xuthus5 Write code and love life. SeerSu 花有重开日，人无再少年 JimMoen Erlang Developer. Sehnsucht transient ","permalink":"https://aimerneige.com/zh/friends/","summary":"friends","title":"Friends 🧑‍🤝‍🧑"},{"content":" 中北大学学生，学习物联网专业。Linux 用户，热爱开源和分享。\n技能 使用的编程语言，软件和服务\ngolang python JavaScript Linux git mysql 工具 neovim VSCode VirtualBox Dbeaver Inkdrop Spotify 语言 中文 英语 教育 中北大学 宁武县高级中学 宁武一中 联系我 GitHub: https://github.com/AimerNeige/\n邮件: aimer.neige@aimerneige.com\n电报: @AimerNeige\n域名: aimerneige.com\n我的故乡 ","permalink":"https://aimerneige.com/zh/about/","summary":"about","title":"关于我 👨‍💻"},{"content":"捐赠 如果你喜欢我的工作，欢迎给我买一杯咖啡。\n微信 支付宝 ","permalink":"https://aimerneige.com/zh/donate/","summary":"donate","title":"捐赠 ☕"},{"content":"这里罗列了一些自己之前开发或参与的开源项目。\nDDLC-Plus-Asset-Decrypter 「心跳文学部 Plus」资源文件解密器。\nMiraiChess 使用 MiraiGo-Template 实现的国际象棋机器人。可以在群内下棋，同时支持 elo 等级分计算。\nyukichan-bot-module 一系列 MiraiGo-Template 插件。\nblog 技术博客，就是你现在正在访问的站点。\nGoWebHooks Golang 实现的 WebHooks 部署脚本。简单且轻量化地实现自动化部署。贡献了部分代码。\nCourseEvaluation 大学评课系统，JavaEE/数据库 课程设计。\nCourseEvaluationClient 大学评课系统客户端，JavaEE/数据库 课程设计。\nRFIDAndroid rfid 课程设计移动端代码。蓝牙串口通讯经典例程。\nboxes 推箱子，程序设计基础课程设计。大一写的，用的 EasyX 做图形库。\nrecords-of-Jing 这个好像不能解释太多（逃\njiwang 计网复习资料，祝大家都不挂科。\nmayuan 马原复习小工具，祝大家都不挂科。\nweb-paste-archive web paste 服务，因为前端不太会写咕了。有一个完整的后端和残缺的前端。\nFuckHomework 手写作业生成器，这个项目应该有很多人写了。\ni3status i3status 配置文件。\nmarkdowntutorial.com 一个学习 markdown 的网站。贡献了部分中文翻译。\nMusic-Player-GO 一个音乐播放器。贡献了部分中文翻译。\nhugo-theme-heimu 在 hugo 内使用黑幕。\nmuzei_coolapk 酷安酷图的 muzei 壁纸源插件。图片质量还是可以的。\nSurfingTutorial 给中国新大学生的网上冲浪和计算机使用教程。\nGlowSans-Ubuntu-Magisk 自己用的 Magisk 字体模块。\nauto-mail 一个自动发送邮件的小工具。\nyou-get-helper 用 you-get 下载某 up 的全部视频。\nDuiTang 堆糖爬虫，已经不能用了。为什么这种东西可以有 star？\ncomic2pdf 漫画图片转 pdf。\nScript 自用的一些脚本。\nHeicWallpapers kde 下的 Heic 动态壁纸。\nHelloVala 不会吧，不会吧，不会有人学这门语言吧。\n","permalink":"https://aimerneige.com/zh/projects/","summary":"projects","title":"项目 💻"}]