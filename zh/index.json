[{"content":"前言 距离上一次写博客文章已经很长时间了，因为经常重装系统，而每次在电脑上安装和配置 hexo 的博客都是一件比较麻烦的事情，于是就一直咕了。但是最近我发现了 hugo 这一简洁好用的博客系统，可以让我远离配置安装都又慢又麻烦的 hexo，使用下来体验很棒，而我恰好又打算换一个博客主题，于是决定使用 hugo 来搭建我的新博客。本文简要介绍如何安装和使用 hugo。\n安装 你可能需要  go 的开发环境 git 一个顺手的编辑器  你一定不需要  nodejs npm  安装 hugo 要安装 hugo 非常简单，以 fedora 系统为例，只需要执行如下指令：\nsudo dnf install hugo 创建站点文件夹 使用以下指令创建你的站点文件夹：\nhugo new site blog 切换到工作目录进行后续操作：\ncd blog 使用 git 进行版本控制：\ngit init 安装主题 挑选好合适的主题后，将其直接 clone 在 ./themes 文件夹下即可。\ngit clone https://github.com/adityatelange/hugo-PaperMod themes/PaperMod --depth=1  使用 --depth=1 参数会忽略历史 commit 记录。\n 当然，下载解压压缩包的方式也是可以的。\n如果想要方便版本控制和更新，使用如下指令添加 submodule：\ngit submodule add https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod --depth=1 当重新 clone 仓库后，执行如下指令 clone 主题子仓库：\ngit submodule update --init --recursive 更新主题：\ngit submodule update --remote --merge 配置 hugo 支持多种配置文件格式，由于 yaml 格式的配置文件更易读，下文将默认使用 yaml 配置。\n与 hexo 不同，hugo 的配置文件只有一个，按照你所使用的主题提供的文档来修改你的配置文件即可。\n应用主题 theme: \u0026#34;PaperMod\u0026#34; 修改主题配置 不同的主题会有不同的配置方法，具体查看主题提供的文档。\n请参考如下配置：\nbaseURL: \u0026#34;https://aimerneige.com/\u0026#34; languageCode: \u0026#34;en-us\u0026#34; title: \u0026#34;AimerNeige\u0026#39;s Blog\u0026#34; theme: \u0026#34;PaperMod\u0026#34; enableRobotsTXT: true buildDrafts: false buildFuture: false buildExpired: false defaultContentLanguage: en defaultContentLanguageInSubdir: true languages: en: languageName: \u0026#34;English\u0026#34; weight: 1 menu: main: - name: About url: about/ weight: 5 - name: Friends url: friends/ weight: 6 - name: Post url: post/ weight: 7 - name: Archive url: archives/ weight: 8 - name: Tags url: tags/ weight: 9 - name: Categories url: categories/ weight: 10 - name: Search url: search/ weight: 11 zh: languageName: \u0026#34;中文\u0026#34; weight: 2 menu: main: - name: 关于 url: about/ weight: 5 - name: 朋友 url: friends/ weight: 6 - name: 文章 url: post/ weight: 7 - name: 归档 url: archives/ weight: 8 - name: 标签 url: tags/ weight: 9 - name: 分类 url: categories/ weight: 10 - name: 搜索 url: search/ weight: 11 params: profileMode: enabled: true title: \u0026#34;Aimer Neige\u0026#34; subtitle: \u0026#34;技术宅拯救世界\u0026#34; imageUrl: \u0026#34;https://avatars.githubusercontent.com/u/51701792?v=4\u0026#34; imageTitle: \u0026#34;avatar.jpeg\u0026#34; imageWidth: 140 imageHeight: 140 params: env: production keywords: [Blog, OpenSource, Coding, Golang, Programming] author: \u0026#34;Aimer Neige\u0026#34; defaultTheme: auto disableThemeToggle: false ShowToc: true TocOpen: false ShowBreadCrumbs: true ShowReadingTime: false ShowPostNavLinks: true ShowShareButtons: false ShowCodeCopyButtons: true displayFullLangName: true editPost: URL: \u0026#34;https://github.com/aimerneige/blog/content\u0026#34; Text: \u0026#34;Suggest Changes\u0026#34; appendFilePath: true homeInfoParams: Title: \u0026#34;Aimer Neige\u0026#34; Content: \u0026#34;Tech Otakus Save The World\u0026#34; profileMode: enabled: true title: \u0026#34;Aimer Neige\u0026#34; subtitle: \u0026#34;Tech Otakus Save The World\u0026#34; imageUrl: \u0026#34;https://avatars.githubusercontent.com/u/51701792?v=4\u0026#34; imageTitle: \u0026#34;avatar.jpeg\u0026#34; imageWidth: 140 imageHeight: 140 socialIcons: - name: github url: \u0026#34;https://github.com/AimerNeige\u0026#34; - name: twitter url: \u0026#34;https://twitter.com/NeigeAimer\u0026#34; - name: steam url: \u0026#34;https://steamcommunity.com/id/AimerNeige\u0026#34; - name: Telegram url: \u0026#34;https://t.me/AimerNeige\u0026#34; - name: KoFi url: \u0026#34;https://ko-fi.com/aimerneige\u0026#34; - name: RsS url: \u0026#34;index.xml\u0026#34; taxonomies: category: categories tag: tags series: series outputs: home: - HTML - RSS - JSON 迁移 将原有文章复制到站点文件夹下，修改配置。\n测试 使用如下指令启动本地测试服务。\nhugo serve -D 部署 使用如下指令生成静态文件：\nhugo 之后上传到 github 即可：\ncd public git add -A git commit -m \u0026#34;commit message\u0026#34; git push ","permalink":"https://aimerneige.com/zh/post/hello-hugo/","summary":"前言 距离上一次写博客文章已经很长时间了，因为经常重装系统，而每次在电脑上安装和配置 hexo 的博客都是一件比较麻烦的事情，于是就一直咕了。但是最近我发现了 hugo 这一简洁好用的博客系统，可以让我远离配置安装都又慢又麻烦的 hexo，使用下来体验很棒，而我恰好又打算换一个博客主题，于是决定使用 hugo 来搭建我的新博客。本文简要介绍如何安装和使用 hugo。\n安装 你可能需要  go 的开发环境 git 一个顺手的编辑器  你一定不需要  nodejs npm  安装 hugo 要安装 hugo 非常简单，以 fedora 系统为例，只需要执行如下指令：\nsudo dnf install hugo 创建站点文件夹 使用以下指令创建你的站点文件夹：\nhugo new site blog 切换到工作目录进行后续操作：\ncd blog 使用 git 进行版本控制：\ngit init 安装主题 挑选好合适的主题后，将其直接 clone 在 ./themes 文件夹下即可。\ngit clone https://github.com/adityatelange/hugo-PaperMod themes/PaperMod --depth=1  使用 --depth=1 参数会忽略历史 commit 记录。\n 当然，下载解压压缩包的方式也是可以的。\n如果想要方便版本控制和更新，使用如下指令添加 submodule：\ngit submodule add https://github.","title":"Hello Hugo"},{"content":"前言 之前在学习安卓的时候，很想要给自己的软件增加一个云服务功能，但是苦于没有学过后端，于是开始在互联网上查找资料。但是遗憾的是，后端是一个很大的范围，我查找了很多后端的资料也几乎都是在讲解如何写网页，并没有专门用来给安卓写后端的教程，在广泛地学习了大量后端内容后，成功的为自己的程序开发了一个简单的 API。希望这篇文章能够帮到那些没有系统地学习过后端，但是却想要快速开发一款能用的 API 的安卓开发者。\n前期准备  你要了解互联网通讯原理 你要会一些基础的 JavaScript 你要有一台服务器 你会数据库操作 最好有一个域名（非必须） 掌握基础的终端操作  环境配置 本文章中后端开发使用的开发语言为 JavaScript 配合 nodejs。数据库采用常用的 mysql。\n 注： nodejs 开发常用的数据库是 mongodb，但是由于 mysql 比较常用这里就用 mysql 了，当然其他数据库也是可以的，你可以查找一下 nodejs 如何链接这些数据库，并将本文中 mysql 操作的部分替换掉就可以了。\n 本地测试客户端安装 你需要在自己用来开发的电脑上安装配置如下环境：\n nodejs npm  安装 nodejs Linux 下直接使用包管理安装即可。如果包管理安装的 node 很旧，可以自行谷歌一下安装方法，这里不再赘述。\n以 Ubuntu 为例，直接在终端执行如下指令：\nsudo apt install nodejs 安装完成后使用 node -v 查看 node 版本来确认安装是否成功。\n如果是 windows 用户就更加简单了，直接在 nodejs 官网 下载安装包运行即可。推荐使用长周期稳定版本。如果你想体验新特性，也可以考虑使用最新的版本。\n安装 npm 通常情况下，安装 nodejs 时会附带安装 npm，你可以直接使用 npm -v 来查看当前系统安装的 npm 版本来检测安装情况。\n如果没有安装，以 Ubuntu 系统为例，可以在终端执行下面的指令：\nsudo apt install npm windows 用户在执行完 node 的安装程序后 npm  会自动安装完成。\n服务器安装 你需要在服务器上安装配置如下环境：\n nodejs npm mysql nginx  安装 nodejs 与 npm 其中 nodejs 和 npm 的安装同客户端完全相同，这里不再赘述。\n安装 mysql mysql 可以一并安装在运行 node 项目的服务器上，也可以使用独立的数据库提供服务器。\n本文章主要讨论如何构建 API ，这里不再赘述如何安装配置 mysql。可以查看我的其他文章。\n安装 nginx nginx 用于将服务反向代理到 80 端口，以 Ubuntu 系统为例，直接在终端执行如下指令：\nsudo apt install nginx Windows 用户自行查阅相关资料。不会吧，不会吧，不会有人服务器用 windows 吧？？项目构建 使用模版 为了方便快速构建一个项目，我写了一个模版，你可以在 GitHub 上找到它。\n使用这个模版快速构建一个新的仓库，将它 clone 到本地，并进行下面的修改：\n 修改 package.json 修改 LICENSE 修改 README 在 src/config 下新建 db.js 写入数据库服务器的配置。  安装依赖 在项目路径下启动终端，执行如下指令：\nnpm i 这个指令是 npm install 的缩写，npm 会安装需要的依赖，本模版项目只依赖了俩个包：\n express mysql  依赖安装完成后，你会在项目路径下看到 node_modules 这个文件夹，它已经被写在 .gitignore 中，这个文件夹下是项目所需要的依赖，即使你意外地删掉了这个文件夹，再次执行 npm i 就可以将这些文件下载回来，所以你不应该在意这个文件夹中有什么内容，npm 会帮我们处理它。\n启动项目 使用 cd 命令切换到 src 目录下，执行下面的指令：\nnode app.js 之后你会在终端看到如下输出：\nServer start in development mode on http://localhost:4000; press Ctrl + C to terminated. 打开你的浏览器访问 http://localhost:4000/\n如果你看到下面的内容，说明项目成功启动了：\n{ \u0026#34;status\u0026#34;: 200, \u0026#34;info\u0026#34;: \u0026#34;If you see this, the server deploy success!\u0026#34; } 如果你在服务器启动项目，假设你的服务器 ip 为 43.192.82.215 并且配置了域名 api.aimerneige.com ，你可以通过在浏览器内访问下面的地址测试服务器：\n http://43.192.82.215:4000/ http://api.aimerneige.com:4000/  注意：\n 在本地测试启动的服务器只能通过 本地/内网 访问 在有公网 ip 的服务器上部署的服务可以在 任意浏览器内 打开  如果你在服务器测试，请注意以这样的方式运行仅能用来测试，不可以用作生产环境，后文会介绍如何在服务器部署项目。\n程序入口 项目可以启动后，说明环境配置无误，接下来可以开始写代码了。\n我们简单看一下程序的入口 app.js\n本项目依赖 express 构建，首先导入 express 的模块：\n// require const express = require(\u0026#34;express\u0026#34;); 接下来导入路由目录下的路由模块：\n// user require const indexRouter = require(\u0026#34;./routes/index\u0026#34;); 创建 express 对象：\n// express app var app = express(); 设置监听端口：\n// set port app.set(\u0026#34;port\u0026#34;, process.env.PORT || 4000); 添加可以支持 json 解析的中间件：\n// json parse app.use(express.json()); app.use(express.urlencoded({ extended: false })); 添加路由中间件：\n// routes app.use(\u0026#34;/\u0026#34;, indexRouter); 路由匹配失败后返回 404 错误：\n// catch 404 and forward to error handler app.use(function (req, res, next) { var err = new Error(\u0026#34;Not Found\u0026#34;); err.status = 404; next(err); }); 处理错误信息：\n// error handler app.use(function (err, req, res, next) { res.type(\u0026#34;application/json\u0026#34;); res.status(err.status || 500); res.send({ status: err.status || 500, message: err.message, }); }); 检测当前模块是否被直接执行，如果是则启动服务器，否者导出模块：\n// check if run app.js directly if (require.main === module) { app.listen(app.get(\u0026#34;port\u0026#34;), function () { console.log( \u0026#34;Server start in \u0026#34; + app.get(\u0026#34;env\u0026#34;) + \u0026#34; mode on http://localhost:\u0026#34; + app.get(\u0026#34;port\u0026#34;) + \u0026#34;; press Ctrl + C to terminated.\u0026#34; ); }); } else { module.exports = app; } 其他的代码可以暂时不去理会，最重要的是路由这一部分：\n// 导入路由模块 const indexRouter = require(\u0026#34;./routes/index\u0026#34;); // 添加路由中间件 app.use(\u0026#34;/\u0026#34;, indexRouter); 在编写 api 时，只需要在 /src/routes 目录下新建路由模块，并在 app.js 下引用即可。\n添加路由 接下来我们看一下默认的路由模块 index.js ：\n导入 express 模块：\nconst express = require(\u0026#34;express\u0026#34;); const router = express.Router(); 配置路由规则：\nrouter.get(\u0026#34;/\u0026#34;, function (req, res, next) { res.type(\u0026#34;application/json\u0026#34;); res.status(200); res.send({ status: 200, info: \u0026#34;If you see this, the server deploy success!\u0026#34;, }); }); 导出模块：\nmodule.exports = router; 其中重点即配置路由规则这一部分。\n我相信这几行代码还是很易懂的，相对地，如果我们想要使用 post 方法，访问路径为 /about 需要这样写：\nrouter.post(\u0026#34;/about\u0026#34;, fuction(){ /* function */ } ); 设置好请求方法和请求路径后，回调函数用来向客户端返回数据。\n设置返回数据类型，这里使用 json 进行数据传输：\nres.type(\u0026#34;application/json\u0026#34;); 设置返回状态码：\nres.status(200); 返回指定数据：\nres.send(return_data); 由于开发语言为 js ，而且本项目添加了解析 json 的中间件，如果想要返回 json，不需像其他语言那样要将对象解析为 json 字符串，直接返回一个对象即可，客户端会成功接收到正确的 json 字符串。\n// 服务器返回的对象 { status: 200, info: \u0026#34;If you see this, the server deploy success!\u0026#34;, } // 客户端拿到的字符串 { \u0026#34;status\u0026#34;: 200, \u0026#34;info\u0026#34;: \u0026#34;If you see this, the server deploy success!\u0026#34; } 书写好路由模块后在 app.js 中引用即可：\n// 导入模块 const indexRouter = require(\u0026#34;./routes/index\u0026#34;); // ... 中间的其他代码  // 在 app 中应用路由模块 app.use(\u0026#34;/\u0026#34;, indexRouter); 要注意模块导入的位置，不能乱放。和模版保持一致即可。\n添加更多的路由信息 就像上面的例子中所写的，我们可以继续添加新的路由模块，也可以在同一个路由模块下添加更多的访问路径。\n src/app.js  // ...  const indexRouter = require(\u0026#34;./routes/index\u0026#34;); const userRouter = require(\u0026#34;./routes/user\u0026#34;); // ...  app.use(\u0026#34;/\u0026#34;, indexRouter); app.use(\u0026#34;/user\u0026#34;, userRouter);  src/routes/index.js  // ...  // 访问路径 / router.get(\u0026#34;/\u0026#34;, fuction(){ /* function */ } ); // 访问路径 /about router.get(\u0026#34;/about\u0026#34;, function() { /* function */ }); // ...  src/routes/user.js  // ...  // 访问路径 /user/cat router.get(\u0026#34;/cat\u0026#34;, fuction(){ /* function */ } ); // 访问路径 /user/edit router.post(\u0026#34;/edit\u0026#34;, fuction(){ /* function */ } ); // 访问路径 /user/new router.psot(\u0026#34;/new\u0026#34;, fuction(){ /* function */ } ); // ... 获取客户端数据 获取请求参数信息 req.query 对象是由客户端请求参数构成的，在回调函数内，可以直接调用它来获取客户端请求参数，如果客户端传递了参数，我们就可以拿到对应的数据，否者我们只能得到 undefined。由此可以通过判空来确定客户端请求参数是否正确。\n例如我们的请求路径为 /data 所需请求参数为 id 和 class 可以这样写：\n 注： 对应的示例请求地址为 https://api.example.com/data?id=1930201\u0026amp;class=302\n router.get(\u0026#34;/data\u0026#34;, function (req, res) { res.type(\u0026#34;application/json\u0026#34;); if (req.query.class === undefined || req.query.id === undefined) { res.status(400); // 向客户端返回错误信息，提示客户端返回正确的参数  res.send({ status: 400, info: \u0026#34;Wrong arguments!\u0026#34;, }); } else { // 向用户返回数据（通常会用客户端参数来调用数据库，为了简便这里返回一个类做简单示范）  res.status(200); res.send({ status: 200, info: { class: req.query.class, id: req.query.id, }, }); } }); 我们可以通过判空来确定客户端请求参数是否正确，之后可以使用参数来进行其他操作，比如构建类，调取数据库等等。\n获取请求体信息 与请求参数类似，请求体信息也保存在一个类中，就是 req.body。使用方法和之前请求参数完全一致，这里只写一个示例，不多赘述。\nrouter.post(\u0026#34;/new\u0026#34;, function (req, res) { res.type(\u0026#34;application/json\u0026#34;); if (req.body.class === undefined || req.body.id === undefined) { res.status(400); // 向客户端返回错误信息，提示客户端返回正确的参数  res.send({ status: 400, info: \u0026#34;Wrong arguments!\u0026#34;, }); } else { var new_student = { class: req.body.class, id: req.body.id, }; // 向数据库内添加新的学生  res.status(200); res.send({ status: 200, info: \u0026#34;Student create successful!\u0026#34;, }); } }); 获取更多信息 在回调函数中，req 对象中保存了所有来自客户请求的数据，前面介绍的只是比较常用的，其他内容可以查找文档。\n获取数据库信息 配置数据库信息 参考 db.js.example 创建 db.js 写入服务器的配置\nvar mysql = require(\u0026#34;mysql\u0026#34;); var pool = mysql.createPool({ host: \u0026#34;host_ip\u0026#34;, user: \u0026#34;user_name\u0026#34;, password: \u0026#34;password\u0026#34;, database: \u0026#34;data\u0026#34;, port: 3306, }); function query(sql, callback) { pool.getConnection(function (err, connection) { connection.query(sql, function (err, rows) { callback(err, rows); connection.release(); }); }); } exports.query = query; 配置好数据库服务器后，就可以通过下面的方法访问数据库的数据了：\nsql_command = \u0026#34;DROP DATABASE *;\u0026#34;; // ⚠️ 注意修改 db.query(sql_command, function (err, result, fields) { if (err) { // 如果数据库指令执行出现了错误，返回错误信息  requestSQLFailedLog(sql_command, err); res.status(400); res.send({ status: 400, info: err }); } else { // 如果数据库指令执行成功，返回数据  requestSQLSuccessLog(sql_command, result); res.status(200); res.send(result); } }); 服务部署  待完善，咕咕咕\n  将项目上传到服务器 修改 db.js 的配置 cd src node cluster.js 如果你想要后台运行，执行 nohup node cluster.js \u0026amp;  ","permalink":"https://aimerneige.com/zh/post/build-api-with-nodejs-quickly/","summary":"前言 之前在学习安卓的时候，很想要给自己的软件增加一个云服务功能，但是苦于没有学过后端，于是开始在互联网上查找资料。但是遗憾的是，后端是一个很大的范围，我查找了很多后端的资料也几乎都是在讲解如何写网页，并没有专门用来给安卓写后端的教程，在广泛地学习了大量后端内容后，成功的为自己的程序开发了一个简单的 API。希望这篇文章能够帮到那些没有系统地学习过后端，但是却想要快速开发一款能用的 API 的安卓开发者。\n前期准备  你要了解互联网通讯原理 你要会一些基础的 JavaScript 你要有一台服务器 你会数据库操作 最好有一个域名（非必须） 掌握基础的终端操作  环境配置 本文章中后端开发使用的开发语言为 JavaScript 配合 nodejs。数据库采用常用的 mysql。\n 注： nodejs 开发常用的数据库是 mongodb，但是由于 mysql 比较常用这里就用 mysql 了，当然其他数据库也是可以的，你可以查找一下 nodejs 如何链接这些数据库，并将本文中 mysql 操作的部分替换掉就可以了。\n 本地测试客户端安装 你需要在自己用来开发的电脑上安装配置如下环境：\n nodejs npm  安装 nodejs Linux 下直接使用包管理安装即可。如果包管理安装的 node 很旧，可以自行谷歌一下安装方法，这里不再赘述。\n以 Ubuntu 为例，直接在终端执行如下指令：\nsudo apt install nodejs 安装完成后使用 node -v 查看 node 版本来确认安装是否成功。\n如果是 windows 用户就更加简单了，直接在 nodejs 官网 下载安装包运行即可。推荐使用长周期稳定版本。如果你想体验新特性，也可以考虑使用最新的版本。\n安装 npm 通常情况下，安装 nodejs 时会附带安装 npm，你可以直接使用 npm -v 来查看当前系统安装的 npm 版本来检测安装情况。","title":"使用 nodejs 快速为 Android 程序构建 API"},{"content":"在多人协作的项目中，为了同一代码格式，可以使用 editorconfig 来定义，这样不仅可以帮助协作者快速了解当前项目要求的代码风格，也可以方便使用一些格式化工具保证代码风格按照预期格式化。\n快速了解  What is EditorConfig? EditorConfig helps maintain consistent coding styles for multiple developers working on the same project across various editors and IDEs. The EditorConfig project consists of a file format for defining coding styles and a collection of text editor plugins that enable editors to read the file format and adhere to defined styles. EditorConfig files are easily readable and they work nicely with version control systems. Source: https://editorconfig.org/\n 简单示例  示例来自 https://editorconfig.org/\n # EditorConfig is awesome: https://EditorConfig.org # top-most EditorConfig file root = true # Unix-style newlines with a newline ending every file [*] end_of_line = lf insert_final_newline = true # Matches multiple files with brace expansion notation # Set default charset [*.{js,py}] charset = utf-8 # 4 space indentation [*.py] indent_style = space indent_size = 4 # Tab indentation (no size specified) [Makefile] indent_style = tab # Indentation override for all JS under lib directory [lib/**.js] indent_style = space indent_size = 2 # Matches the exact files either package.json or .travis.yml [{package.json,.travis.yml}] indent_style = space indent_size = 2 使用方法 直接在项目目录下新建文件 .editorconfig 写入配置，安装对应插件后即可，保存文件时会按照配置文件自动格式化。\n额外地，如果你在 Windows 下如果使用 Windows Explorer 新建 .editorconfig 文件，需要将文件名写为 .editorconfig.，Windows 会自动重命名为 .editorconfig。\n特殊符号的含义    符号 含义     * 匹配任何字符串，除了路径分割符 (/)   ** 匹配任何字符串   ? 匹配任何单字符   [name] 匹配 name 中所包含的任一字符   [!name] 匹配不包含在 name 中的任一字符   {s1,s2,s3} 匹配任何给定单字符串 (用逗号分割) (在 EditorConfig Core 0.11.0 后受支持)   {num1..num2} 匹配任何在 num1 和 num2 之间的数字，num1 和 num2 可以是正数也可以是负数    支持的配置属性  indent_style 缩进样式 {tab, space} indent_size 每次缩进相当于多少列 {2,4,8\u0026hellip;} (当 indent_style 设置为 space 时使用) tab_width 每次缩进相当于多少列 {2,4,8\u0026hellip;} (当 indent_style 设置为 tab 时使用) end_of_line 换行 {lf, cr, crlf} charset 编码 {latin1, utf-16be, utf-16le, utf-8, utf-8-bom, unset} trim_trailing_whitespace {true, false} 是否删掉结尾的空白字符 insert_final_newline {true, false} 是否在结尾插入新行 root {true, false} 是否顶级配置文件  ","permalink":"https://aimerneige.com/zh/post/editorconfig/","summary":"在多人协作的项目中，为了同一代码格式，可以使用 editorconfig 来定义，这样不仅可以帮助协作者快速了解当前项目要求的代码风格，也可以方便使用一些格式化工具保证代码风格按照预期格式化。\n快速了解  What is EditorConfig? EditorConfig helps maintain consistent coding styles for multiple developers working on the same project across various editors and IDEs. The EditorConfig project consists of a file format for defining coding styles and a collection of text editor plugins that enable editors to read the file format and adhere to defined styles. EditorConfig files are easily readable and they work nicely with version control systems.","title":"利用 EditorConfig 定义代码格式，统一代码风格"},{"content":"前言 Linux 下中文输入法一直是硬伤，各种方面都没有 windows 或 mac 下好用，最近在逛 github 的时候偶然翻到一个仓库 四叶草拼音输入方案，这个仓库提供的输入方案用起来十分舒服，但是在安装的时候也遇到一些坑，于是写了这篇文章来记录。\n 测试环境：\n.............. aimerneige@an ..,;:ccc,. ------------- ......\u0026#39;\u0026#39;\u0026#39;;lxO. OS: Kali GNU/Linux Rolling x86_64 .....\u0026#39;\u0026#39;\u0026#39;\u0026#39;..........,:ld; Host: TM1701 .\u0026#39;;;;:::;,,.x, Kernel: 5.9.0-kali4-amd64 ..\u0026#39;\u0026#39;\u0026#39;. 0Xxoc:,. ... Uptime: 2 hours, 11 mins .... ,ONkc;,;cokOdc\u0026#39;,. Packages: 3537 (dpkg) . OMo \u0026#39;:ddo. Shell: zsh 5.8 dMc :OO; Resolution: 1920x1080, 1440x2560 0M. .:o. DE: GNOME 3.38.2 ;Wd WM: Mutter ;XO, WM Theme: Kali-Dark ,d0Odlc;,.. Theme: Kali-Dark [GTK2/3] ..\u0026#39;,;:cdOOd::,. Icons: Flat-Remix-Blue-Dark [GTK2/\u0026gt; 3] .:d;.\u0026#39;:;. Terminal: gnome-terminal \u0026#39;d, .\u0026#39; CPU: Intel i7-8550U (8) @ 4.000GHz ;l .. GPU: NVIDIA GeForce MX250 .o GPU: Intel UHD Graphics 620 c Memory: 3698MiB / 15899MiB .\u0026#39; .  安装 fcitx5 sudo apt install fcitx5 启用 fcitx5 im-config 在开启的图形化界面中启用 fcitx5\n配置 fcitx5 编辑文件 ~/.xprofile 写入如下内容：\nexport GTK_IM_MODULE=fcitx5 export QT_IM_MODULE=fcitx5 export XMODIFIERS=\u0026#34;@im=fcitx5\u0026#34; export LANG=\u0026#34;zh_CN.UTF-8\u0026#34; export LC_CTYPE=\u0026#34;zh_CN.UTF-8\u0026#34; 编辑完成后注销账户，重新启动桌面\n安装 rime sudo apt install fcitx5-rime 启用 rime 在托盘处点击配置，并添加 rime。\n如果你的系统和我一样是英文，取消勾选“Only Show Current Language”即可查看中文选项\n更快地，你可以直接在上面的搜索框搜索 Rime\n安装输入方案 安装 四叶草拼音输入方案 提供的输入方案\n具体安装方法查看 项目 wiki\n更换简体中文 按下 Ctrl + ` 将输入模式切换为简体中文\n你也可以按照自己的喜好更改全角/半角的设置\n后记 如果你在安装中遇到任何问题，请查阅 fcitx rime 四叶草拼音输入方案 提供的文档。\n或是在 Arch Wiki 上查阅相关内容。\n","permalink":"https://aimerneige.com/zh/post/install-fcitx5-with-rime-on-linux/","summary":"前言 Linux 下中文输入法一直是硬伤，各种方面都没有 windows 或 mac 下好用，最近在逛 github 的时候偶然翻到一个仓库 四叶草拼音输入方案，这个仓库提供的输入方案用起来十分舒服，但是在安装的时候也遇到一些坑，于是写了这篇文章来记录。\n 测试环境：\n.............. aimerneige@an ..,;:ccc,. ------------- ......\u0026#39;\u0026#39;\u0026#39;;lxO. OS: Kali GNU/Linux Rolling x86_64 .....\u0026#39;\u0026#39;\u0026#39;\u0026#39;..........,:ld; Host: TM1701 .\u0026#39;;;;:::;,,.x, Kernel: 5.9.0-kali4-amd64 ..\u0026#39;\u0026#39;\u0026#39;. 0Xxoc:,. ... Uptime: 2 hours, 11 mins .... ,ONkc;,;cokOdc\u0026#39;,. Packages: 3537 (dpkg) . OMo \u0026#39;:ddo. Shell: zsh 5.8 dMc :OO; Resolution: 1920x1080, 1440x2560 0M. .:o. DE: GNOME 3.38.2 ;Wd WM: Mutter ;XO, WM Theme: Kali-Dark ,d0Odlc;,.. Theme: Kali-Dark [GTK2/3] ..\u0026#39;,;:cdOOd::,. Icons: Flat-Remix-Blue-Dark [GTK2/\u0026gt; 3] .","title":"Linux 下安装 fcitx5 与 Rime"},{"content":"ifconfig ➜ ~ ifconfig enx2c16dba37d18: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1500 inet 10.0.117.154 netmask 255.255.255.0 broadcast 10.0.117.255 inet6 2001:250:c00:218:5bd6:795c:5b92:e787 prefixlen 64 scopeid 0x0\u0026lt;global\u0026gt; inet6 fe80::2224:6ee:2527:f54d prefixlen 64 scopeid 0x20\u0026lt;link\u0026gt; inet6 2001:250:c00:218:44fc:ad73:aeb8:b07d prefixlen 64 scopeid 0x0\u0026lt;global\u0026gt; ether 2c:16:db:a3:7d:18 txqueuelen 1000 (Ethernet) RX packets 110382 bytes 150904005 (150.9 MB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 30811 bytes 3569027 (3.5 MB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 lo: flags=73\u0026lt;UP,LOOPBACK,RUNNING\u0026gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10\u0026lt;host\u0026gt; loop txqueuelen 1000 (Local Loopback) RX packets 26251 bytes 4892192 (4.8 MB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 26251 bytes 4892192 (4.8 MB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 wlp2s0: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1500 inet 192.168.7.243 netmask 255.255.255.0 broadcast 192.168.7.255 inet6 fe80::1dea:1bcb:ae17:fa3b prefixlen 64 scopeid 0x20\u0026lt;link\u0026gt; ether d0:c6:37:dd:91:95 txqueuelen 1000 (Ethernet) RX packets 17759 bytes 19498138 (19.4 MB) RX errors 0 dropped 7 overruns 0 frame 0 TX packets 6341 bytes 911629 (911.6 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 ping Linux 服务器无法上网\n ping localhost\n侦测网卡安装或配置有问题 ping 网关\nip route show 查看网关\n侦测局域网中的网关或路由器是否正常 ping dns server\n在 /etc/resolv.conf 查看 dns 配置\ndns 解析是否可以解析 ping 远程地址\n与外部的连接是否正常  mtr 网络侦测工具\n My traceroute [v0.93] an-xiaomi-book-pro (10.0.117.154) 2020-11-10T10:08:42+0800 Keys: Help Display mode Restart statistics Order of fields quit Packets Pings Host Loss% Snt Last Avg Best Wrst StDev 1. _gateway 0.0% 156 1.2 1.8 0.8 16.4 2.6 2. 10.125.255.2 0.0% 156 0.6 0.5 0.4 0.8 0.1 3. 172.16.1.254 96.8% 156 2.5 5.7 1.7 18.3 7.1 4. 129.210.99.202.internet. 0.0% 156 2.1 3.4 1.7 12.4 2.2 5. 57.53.26.218.internet.sx 0.0% 156 2.7 4.1 2.1 12.9 1.9 6. 165.151.26.218.internet. 0.0% 156 25.9 25.6 24.0 32.0 0.9 7. 219.158.101.109 0.0% 155 17.2 14.0 10.1 18.5 2.3 8. 219.158.5.158 0.0% 155 17.7 15.5 10.9 33.9 3.2 9. 219.158.16.70 0.0% 155 13.1 15.7 11.7 20.8 2.4 10. 219.158.32.30 18.7% 155 121.5 165.3 108.3 226.9 34.2 11. ae-1.r31.tokyjp05.jp.bb. 0.0% 155 56.5 109.5 55.6 173.8 34.5 12. ae-3.r01.tokyjp08.jp.bb. 18.1% 155 109.4 161.9 108.5 222.7 35.2 13. ae-3.fastly.tokyjp08.jp. 20.6% 155 106.5 161.5 105.9 219.5 33.7 14. 185.199.109.153 0.6% 155 159.2 210.4 157.4 271.3 33.6  Loss 丢包率 Snt 发送的次数 Last 最近一次的返回时延 Avg 平均值 Best 最短的一次时间 Wrst 最长的一次时间 StDev 标准偏差  traceroute / tracepath ➜ ~ traceroute aimerneige.com traceroute to aimerneige.com (185.199.109.153), 30 hops max, 60 byte packets 1 10.0.117.1 (10.0.117.1) 11.848 ms 11.768 ms 11.719 ms 2 10.125.255.2 (10.125.255.2) 0.605 ms 0.578 ms 0.544 ms 3 * * * 4 129.210.99.202.internet.sx.cn (202.99.210.129) 2.015 ms 1.965 ms 1.920 ms 5 233.124.26.218.internet.sx.cn (218.26.124.233) 1.874 ms 2.345 ms 237.124.26.218.internet.sx.cn (218.26.124.237) 2.304 ms 6 245.131.26.218.router-switch.sx.cn (218.26.131.245) 2.902 ms 209.151.26.218.internet.sx.cn (218.26.151.209) 40.287 ms 245.131.26.218.router-switch.sx.cn (218.26.131.245) 2.713 ms 7 219.158.105.93 (219.158.105.93) 10.882 ms 219.158.102.249 (219.158.102.249) 9.079 ms 219.158.101.109 (219.158.101.109) 13.673 ms 8 219.158.5.158 (219.158.5.158) 11.302 ms 11.258 ms 219.158.4.174 (219.158.4.174) 20.035 ms 9 219.158.16.70 (219.158.16.70) 11.866 ms 19.391 ms 19.316 ms 10 219.158.32.30 (219.158.32.30) 216.576 ms 220.853 ms 215.579 ms 11 ae-0.r30.tokyjp05.jp.bb.gin.ntt.net (129.250.2.11) 162.897 ms 162.880 ms ae-1.r31.tokyjp05.jp.bb.gin.ntt.net (129.250.2.153) 163.532 ms 12 ae-3.r01.tokyjp08.jp.bb.gin.ntt.net (129.250.6.133) 215.634 ms ae-3.r00.tokyjp08.jp.bb.gin.ntt.net (129.250.6.129) 213.725 ms ae-2.r00.tokyjp08.jp.bb.gin.ntt.net (129.250.6.127) 169.350 ms 13 * * * 14 * * * 15 * * * 16 * * * 17 * * * 18 * * * 19 * * * 20 * * * 21 * * * 22 * * * 23 * * * 24 * * * 25 * * * 26 * * * 27 * * * 28 * * * 29 * * * 30 * * * ➜ ~ tracepath aimerneige.com 1?: [LOCALHOST] pmtu 1500 1: _gateway 1.048ms 1: _gateway 1.195ms 2: 10.125.255.2 0.588ms 3: 172.16.1.254 5.206ms 4: 129.210.99.202.internet.sx.cn 2.954ms 5: 145.53.26.218.internet.sx.cn 2.496ms 6: 245.131.26.218.router-switch.sx.cn 4.198ms 7: 219.158.11.113 13.225ms 8: 219.158.5.158 19.169ms 9: 219.158.16.70 11.860ms 10: 219.158.32.30 226.589ms 11: ae-1.r31.tokyjp05.jp.bb.gin.ntt.net 165.652ms 12: ae-3.r00.tokyjp08.jp.bb.gin.ntt.net 200.616ms 13: no reply 14: no reply 15: no reply 16: no reply 17: no reply 18: no reply 19: no reply 20: no reply 21: no reply 22: no reply 23: no reply 24: no reply 25: no reply 26: no reply 27: no reply 28: no reply 29: no reply 30: no reply Too many hops: pmtu 1500 Resume: pmtu 1500 ip 查看网卡信息 ip addr show ➜ ~ ip addr show 1: lo: \u0026lt;LOOPBACK,UP,LOWER_UP\u0026gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever 2: wlp2s0: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc noqueue state UP group default qlen 1000 link/ether d0:c6:37:dd:91:95 brd ff:ff:ff:ff:ff:ff inet 192.168.7.243/24 brd 192.168.7.255 scope global dynamic noprefixroute wlp2s0 valid_lft 169205sec preferred_lft 169205sec inet6 fe80::1dea:1bcb:ae17:fa3b/64 scope link noprefixroute valid_lft forever preferred_lft forever 3: enx2c16dba37d18: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000 link/ether 2c:16:db:a3:7d:18 brd ff:ff:ff:ff:ff:ff inet 10.0.117.154/24 brd 10.0.117.255 scope global dynamic noprefixroute enx2c16dba37d18 valid_lft 3601sec preferred_lft 3601sec inet6 2001:250:c00:218:44fc:ad73:aeb8:b07d/64 scope global temporary dynamic valid_lft 601397sec preferred_lft 82623sec inet6 2001:250:c00:218:5bd6:795c:5b92:e787/64 scope global dynamic mngtmpaddr noprefixroute valid_lft 2591976sec preferred_lft 604776sec inet6 fe80::2224:6ee:2527:f54d/64 scope link noprefixroute valid_lft forever preferred_lft forever 启用/禁用网卡 sudo ip link set enp0s3 up / dowm 为网卡分配地址 sudo ip addr add 192.168.0.50/255.255.255.0 dev enp0s3 sudo ip addr del 192.168.0.10/24 dev enp0s3 ip route 查看路由\nip route\n➜ ~ ip route default via 10.0.117.1 dev enx2c16dba37d18 proto dhcp metric 100 default via 192.168.7.1 dev wlp2s0 proto dhcp metric 600 10.0.117.0/24 dev enx2c16dba37d18 proto kernel scope link src 10.0.117.154 metric 100 169.254.0.0/16 dev enx2c16dba37d18 scope link metric 1000 192.168.7.0/24 dev wlp2s0 proto kernel scope link src 192.168.7.243 metric 600 添加静态路由\nsudo ip route add 172.16.32.32 via 192.168.0.150/24 dev enp0s3\n删除路由\nsudo ip route del 192.168.0.150/24\narp 查看 arp 记录\nip neigh\n➜ ~ ip neigh 192.168.7.2 dev wlp2s0 lladdr e8:39:35:1f:13:b1 STALE 192.168.7.1 dev wlp2s0 lladdr 28:d1:27:85:38:d7 REACHABLE 10.0.117.177 dev enx2c16dba37d18 lladdr e8:39:35:1f:14:fc STALE 192.168.7.38 dev wlp2s0 lladdr 2c:ff:ee:66:e2:01 STALE 10.0.117.1 dev enx2c16dba37d18 lladdr 58:69:6c:07:71:4b REACHABLE 192.168.7.160 dev wlp2s0 lladdr 3e:22:9c:ef:b8:d2 STALE fe80::5a69:6cff:fe07:714b dev enx2c16dba37d18 lladdr 58:69:6c:07:71:4b router STALE  PERM 永久有效并且只能被管理员删除 NOARP 记录有效，过期后可被删除 STALE 记录有效，但可能已经过期 REACHABLE 记录有效，但超时后就失效了  增加 arp 记录\nsudo ip neigh add 192.168.0.150 lladdr 33:1g:75:37:r3:84 dev enp0s3 nud perm\n删除 arp\nsudo ip neigh del 192.168.0.106 dev enp0s3\ncurl / wget curl aimerneige.com\nwget aimerneige.com\nnetstat 网络连接状态以及其相关信息的程序\n告诉用户哪些网络连接正在运作\n 列出所有端口 netstat -a 列出所有 tcp 端口 netstat -at 列出所有 udp 端口 netstat -au 显示进程 id 和名称 netstat -p 显示路由信息 netstat -r 显示所有监听的端口 netstat -tnl  ","permalink":"https://aimerneige.com/zh/post/daily-linux-command/","summary":"ifconfig ➜ ~ ifconfig enx2c16dba37d18: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1500 inet 10.0.117.154 netmask 255.255.255.0 broadcast 10.0.117.255 inet6 2001:250:c00:218:5bd6:795c:5b92:e787 prefixlen 64 scopeid 0x0\u0026lt;global\u0026gt; inet6 fe80::2224:6ee:2527:f54d prefixlen 64 scopeid 0x20\u0026lt;link\u0026gt; inet6 2001:250:c00:218:44fc:ad73:aeb8:b07d prefixlen 64 scopeid 0x0\u0026lt;global\u0026gt; ether 2c:16:db:a3:7d:18 txqueuelen 1000 (Ethernet) RX packets 110382 bytes 150904005 (150.9 MB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 30811 bytes 3569027 (3.5 MB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 lo: flags=73\u0026lt;UP,LOOPBACK,RUNNING\u0026gt; mtu 65536 inet 127.","title":"每天一个 Linux 指令"},{"content":"今天遇到一个奇怪的问题：\n一个 C 语言初学者写了这样的错误代码：\nswitch (a) { case1: // do something  break; case2: // do something  break; case3: // do something  break; default: break; } 错误很容易解决，但是，在编译这样的程序时，编译器居然没有报错？？！！\n那么 case1 case2 这些东西是哪里来的？\n几番求证无果，最后在翻阅《C 专家编程》这本书的时候突然发现了原因：\n首先像下面这样写是可以的：\nswitch (i) { case 5 + 3: do_again: case 2: printf(\u0026#34;I loop unremittingly\\n\u0026#34;); goto do_again; default: i++; case 3: ; } 这里定义了一个标签 do_again，并且通过 goto 跳转。\n原错误代码中 case1 case2 等被编译器理解为了标签。\n由于 goto 不被建议使用，博主居然已经忘记了标签和 goto 的用法。\n不管怎么说，问题解决了。\n这不是 Bug，而是 C 语言的特性。 #(滑稽)\n类似地，有如下代码：\n#include \u0026lt;stdio.h\u0026gt; int main() { https://aimerneige.com  printf(\u0026#34;Hello World!\\n\u0026#34;); return 0; } 这里的代码直接贴上了一个 url，但是编译器也没有报错，是因为 https 被识别为标签，而后面的内容被识别为注释。\n","permalink":"https://aimerneige.com/zh/post/this-is-not-bug/","summary":"今天遇到一个奇怪的问题：\n一个 C 语言初学者写了这样的错误代码：\nswitch (a) { case1: // do something  break; case2: // do something  break; case3: // do something  break; default: break; } 错误很容易解决，但是，在编译这样的程序时，编译器居然没有报错？？！！\n那么 case1 case2 这些东西是哪里来的？\n几番求证无果，最后在翻阅《C 专家编程》这本书的时候突然发现了原因：\n首先像下面这样写是可以的：\nswitch (i) { case 5 + 3: do_again: case 2: printf(\u0026#34;I loop unremittingly\\n\u0026#34;); goto do_again; default: i++; case 3: ; } 这里定义了一个标签 do_again，并且通过 goto 跳转。\n原错误代码中 case1 case2 等被编译器理解为了标签。\n由于 goto 不被建议使用，博主居然已经忘记了标签和 goto 的用法。","title":"这不是 Bug，而是语言特性"},{"content":"函数指针在大型的 C 语言项目中十分重要，但是学校对它的介绍一带而过，国内一些介绍函数指针的文章十分粗浅甚至存在错误（这里就不点名了），因此博主写了这篇文章介绍函数指针，希望能够帮助一些 C 语言学习者。\n文章部分内容翻译引用于 https://www.geeksforgeeks.org/function-pointer-in-c/\n函数指针的概念 类似变量，函数也会被分配一段存储空间，这段存储空间的首地址即被称做这个函数的地址。而且函数名表示的就是这个地址。既然是地址，我们就可以定义一个指针变量来存放，这个指针变量就叫做函数指针变量，简称函数指针。\n函数指针的定义 下面的语句定义了一个指向函数的指针变量 p。其中 void *表示返回值，(*p) 表示 p 是一个指针变量， (int, float) 是函数的参数列表。\nvoid *(*p) (int, float); 这样我们就得到了一个指针变量 p，它的类型为 void * (*)(int, float)\n所以函数指针的定义方法为：\n函数返回类型 (*指针变量名) (函数参数列表); 这里的函数参数列表类似函数声明，只需写出变量类型即可，并不需要定义变量。\n即下面的俩种写法等价并且第二种写法中定义的变量并没有任何意义，建议使用第一种写法，不要使用第二种写法。\nvoid *(*p) (int, float); void *(*p) (int a, float b); 如何对函数指针赋值 int Func(int x); // 函数的声明  int (*p) (int x); // 函数指针的定义  p = \u0026amp;Func; // 函数指针的赋值 p = Func; // 另一种可行的写法 注：对于俩种赋值写法的详细说明见对函数赋值和调用的一些说明\n函数指针的调用 #include \u0026lt;stdio.h\u0026gt; int max(int a, int b); // 函数声明  int main(int argc, char const *argv[]) { int a = 12; int b = 32; int (*p)(int, int); // 函数指针定义  p = \u0026amp;max; // 函数指针赋值  int c = (*p)(a, b); // 函数指针的调用  printf(\u0026#34;%d\\n\u0026#34;, c); // 输出 `32`  return 0; } // 函数定义 int max(int a, int b) { return a \u0026gt; b ? a : b; } 另一种可行的写法\n#include \u0026lt;stdio.h\u0026gt; int max(int a, int b); // 函数声明  int main(int argc, char const *argv[]) { int a = 12; int b = 32; int (*p)(int, int); // 函数指针定义  p = max; // 函数指针赋值  int c = *p(a, b); // 函数指针的调用  printf(\u0026#34;%d\\n\u0026#34;, c); // 输出 `32`  return 0; } // 函数定义 int max(int a, int b) { return a \u0026gt; b ? a : b; } 注：对于这俩种调用的写法的详细说明见对函数赋值和调用的一些说明\n函数指针中要注意的一些内容  与一般的指针不同，函数指针指向代码而不是数据。通常，一个函数指针存储了可执行代码的起始位置。 与普通指针不同，我们使用函数指针时不需要分配和释放内存。 函数名也可以用来获取函数的地址。（详见对函数赋值和调用的一些说明） 类似普通的指针，我们也有函数指针数组。（详见函数指针数组示例） 函数指针可被用于 switch case 结构中，例如函数指针数组示例中的示例程序中，用户可以通过输入 0 ～ 2 来选择不同的操作。 就像普通数据的指针一样，一个函数指针同样可以被用作函数的参数和返回值，例如函数指针作为参数的示例中的程序中 wrapper() 函数接受 void (*fun)() 作为参数并且执行这个函数。这个特性有很多的应用，你可以在函数指针作为参数的应用中查看更多内容。 C++ 中的许多面向对象特性都是使用 C 中的函数指针实现的，例如虚函数，类方法是使用函数指针实现的另一个示例。  对函数赋值和调用的一些说明 通常，既然是指针赋值，我们会使用取地址操作来获取地址，然后使用 * 运算符调用，但是，对于函数来说，直接使用函数名也可以获得地址。即如下俩种写法等价：\np = \u0026amp;Func; (*p)(2, 3); p = Func; p(2, 3); 编译执行以下程序：\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; int max(int a, int b); int main(int argc, char const *argv[]) { printf(\u0026#34;%p\\n\u0026#34;, (max) ); printf(\u0026#34;%p\\n\u0026#34;, (\u0026amp;max) ); return 0; } int max(int a, int b) { return a \u0026gt; b ? a : b; } 你会发现 (max) (\u0026amp;max) 拥有相同的值，即直接使用函数名也可以获得地址。\n因此，我更推荐第二种没有 \u0026amp; 和 * 的写法，更加直观易用。\n函数指针数组示例 #include \u0026lt;stdio.h\u0026gt; void add(int a, int b) { printf(\u0026#34;Addition is %d\\n\u0026#34;, a + b); } void subtract(int a, int b) { printf(\u0026#34;Subtraction is %d\\n\u0026#34;, a - b); } void multiply(int a, int b) { printf(\u0026#34;Multiplication is %d\\n\u0026#34;, a * b); } int main() { // fun_ptr_arr 是一个函数指针的数组  void (*fun_ptr_arr[])(int, int) = {add, subtract, multiply}; unsigned int ch, a = 15, b = 10; printf(\u0026#34;Enter Choice: 0 for add, 1 for subtract and 2 for multiply\\n\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;ch); if (ch \u0026gt; 2) { return 0; } (*fun_ptr_arr[ch])(a, b); return 0; } 函数指针作为参数的示例 // 一个简单的 C 语言程序来演示使用函数指针作为参数 #include \u0026lt;stdio.h\u0026gt; // 俩个简单的函数 void fun1() { printf(\u0026#34;Fun1\\n\u0026#34;); } void fun2() { printf(\u0026#34;Fun2\\n\u0026#34;); } // 一个接受函数作为参数并在内部执行这个函数的函数 void wrapper(void (*fun)()) { fun(); } int main() { wrapper(fun1); wrapper(fun2); return 0; } 函数指针作为参数的应用 我们可以使用将函数指针作为参数来避免书写重复的代码，例如较为简单的函数 qsort() 可以被用来排序数组或其他任何的自定义结构体。不仅这些，有了函数指针和空指针，使用 qsort() 函数可以对任何数据类型进行排序。\n// 一个关于 qsort 和比较器的定义 #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; // 一个比较器示例函数 // 它被用对一个整数数组进行排序 // 为了对任何其他数据类型或条件的任何数组进行排序 // 我们需要编写更多的比较函数 // 这样我们就可以使用相同的 qsort() int compare(const void *a, const void *b) { return (*(int *)a - *(int *)b); } int main() { int arr[] = {10, 5, 15, 12, 90, 80}; int n = sizeof(arr) / sizeof(arr[0]); qsort(arr, n, sizeof(int), compare); for (int i = 0; i \u0026lt; n; i++) { printf(\u0026#34;%d \u0026#34;, arr[i]); } return 0; } 类似 qsort() 函数，我们可以定义自己的可以用于任何数据类型的函数来处理不同的任务。下面是一个搜索函数的示例，它可以被用于任何数据类型。事实上，我们可以通过写一个专门的比较函数使用这个搜索函数来找到相近的元素（低于某阈值）。\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdbool.h\u0026gt; // 一个被用来对整数数组进行搜索的比较函数 bool compare(const void *a, const void *b) { return (*(int *)a == *(int *)b); } // 可以被用来在一个长度为 arr_size 的数组 arr[] 中 // 搜索元素 *x 的通用 search() 函数。 // 注意这里使用 void 指针，这样函数就可以在调用 // 的时候传入任何类型的参数 // ele_size 是数组元素的大小 int search(void *arr, int arr_size, int ele_size, void *x, bool compare(const void *, const void *)) { // 因为 char 占用一个字节，因此我们使用 char 指针  // 来可以保证用于任何类型的指针运算都正确，我们  // 需要将 index 与元素的大小 ele_size 相乘  char *ptr = (char *)arr; int i; for (i = 0; i \u0026lt; arr_size; i++) if (compare(ptr + i * ele_size, x)) return i; // 如果没有找到元素  return -1; } int main() { int arr[] = {2, 5, 7, 90, 70}; int n = sizeof(arr) / sizeof(arr[0]); int x = 7; printf(\u0026#34;Returned index is %d \u0026#34;, search(arr, n, sizeof(int), \u0026amp;x, compare)); return 0; } 这个函数可以被用于任何类型的数据，只要定义一个比较函数。\n如何使用 typedef 定义函数指针类型 与一般的定义不同，函数指针在使用 typedef 重命名时，新的变量名不是在末尾而是类似函数指针变量定义的写法。\n下面是一个简单的例子：\ntypedef int (*type_name) (const void *, double); 其中 int 为函数返回值类型， const void *, double 是函数接受的参数列表，(*type_name) 表明定义的是一个函数指针，它的类型为 int (*)(const void *, double)，新的类型名为 type_name，你可以使用 type_name 来定义一个类型为 int (*)(const void *, double) 的函数指针。\n也就是说，使用定义函数指针类型的格式如下：\ntypedef 函数返回值类型 (*类型名) (函数参数列表) 接下来看一下 qsort() 函数的源代码：\n首先是函数 qsort() 的声明：\nextern void qsort (void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar) __nonnull ((1, 4)); 这里有一个新的数据类型 __compar_fn_t，我们知道它是一个函数指针，我们找一下它的定义：\ntypedef int (*__compar_fn_t) (const void *, const void *); 上例中 search() 函数可以这样定义：\n// 类型定义 typedef bool (*compare_fun)(const void *, const void *); // 函数声明 int search(void *arr, int arr_size, int ele_size, void *x, compare_fun compare);  建议阅读： https://www.geeksforgeeks.org/function-pointer-in-c/\n","permalink":"https://aimerneige.com/zh/post/c-function-point/","summary":"函数指针在大型的 C 语言项目中十分重要，但是学校对它的介绍一带而过，国内一些介绍函数指针的文章十分粗浅甚至存在错误（这里就不点名了），因此博主写了这篇文章介绍函数指针，希望能够帮助一些 C 语言学习者。\n文章部分内容翻译引用于 https://www.geeksforgeeks.org/function-pointer-in-c/\n函数指针的概念 类似变量，函数也会被分配一段存储空间，这段存储空间的首地址即被称做这个函数的地址。而且函数名表示的就是这个地址。既然是地址，我们就可以定义一个指针变量来存放，这个指针变量就叫做函数指针变量，简称函数指针。\n函数指针的定义 下面的语句定义了一个指向函数的指针变量 p。其中 void *表示返回值，(*p) 表示 p 是一个指针变量， (int, float) 是函数的参数列表。\nvoid *(*p) (int, float); 这样我们就得到了一个指针变量 p，它的类型为 void * (*)(int, float)\n所以函数指针的定义方法为：\n函数返回类型 (*指针变量名) (函数参数列表); 这里的函数参数列表类似函数声明，只需写出变量类型即可，并不需要定义变量。\n即下面的俩种写法等价并且第二种写法中定义的变量并没有任何意义，建议使用第一种写法，不要使用第二种写法。\nvoid *(*p) (int, float); void *(*p) (int a, float b); 如何对函数指针赋值 int Func(int x); // 函数的声明  int (*p) (int x); // 函数指针的定义  p = \u0026amp;Func; // 函数指针的赋值 p = Func; // 另一种可行的写法 注：对于俩种赋值写法的详细说明见对函数赋值和调用的一些说明","title":"C 函数指针"},{"content":"          thread 线程 有共享内存   process 进程 没有共享内存    gcc file.c -lpthread 创建线程\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;pthread.h\u0026gt; void *myfunc(void *args) { for (int i = 0; i \u0026lt; 50; i++) { printf(\u0026#34;%d\\n\u0026#34;, i); } return NULL; } int main() { pthread_t th1; pthread_t th2; pthread_create(\u0026amp;th1, NULL, myfunc, NULL); pthread_create(\u0026amp;th2, NULL, myfunc, NULL); pthread_join(th1, NULL); pthread_join(th2, NULL); return 0; } 传入参数\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;pthread.h\u0026gt; void *myfunc(void *args) { char *name = (char *)args; for (int i = 0; i \u0026lt; 50; i++) { printf(\u0026#34;%s %d\\n\u0026#34;, name, i); } return NULL; } int main() { pthread_t th1; pthread_t th2; pthread_create(\u0026amp;th1, NULL, myfunc, \u0026#34;th1\u0026#34;); pthread_create(\u0026amp;th2, NULL, myfunc, \u0026#34;th2\u0026#34;); pthread_join(th1, NULL); pthread_join(th2, NULL); return 0; } 分部计算\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;pthread.h\u0026gt; int arr[5000]; int s1 = 0; int s2 = 0; void *myfunc1(void *args) { for (int i = 0; i \u0026lt; 2500; i++) { s1 += arr[i]; } return NULL; } void *myfunc2(void *args) { for (int i = 2500; i \u0026lt; 5000; i++) { s2 += arr[i]; } return NULL; } int main() { for (int i = 0; i \u0026lt; 5000; i++) { arr[i] = rand() % 50; } pthread_t th1; pthread_t th2; pthread_create(\u0026amp;th1, NULL, myfunc1, NULL); pthread_create(\u0026amp;th2, NULL, myfunc2, NULL); pthread_join(th1, NULL); pthread_join(th2, NULL); int S = s1 + s2; printf(\u0026#34;Result: %d\\n\u0026#34;, S); return 0; } 单参数的写法\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;pthread.h\u0026gt; int arr[5000]; int s1 = 0; int s2 = 0; void *myfunc(void *args) { int a = 0 [(int *)args]; if (a == 1) { for (int i = 0; i \u0026lt; 2500; i++) { s1 += arr[i]; } } else { for (int i = 2500; i \u0026lt; 5000; i++) { s2 += arr[i]; } } return NULL; } int main() { for (int i = 0; i \u0026lt; 5000; i++) { arr[i] = rand() % 50; } pthread_t th1; pthread_t th2; pthread_create(\u0026amp;th1, NULL, myfunc, (int []){1}); pthread_create(\u0026amp;th2, NULL, myfunc, (int []){2}); pthread_join(th1, NULL); pthread_join(th2, NULL); int S = s1 + s2; printf(\u0026#34;Result: %d\\n\u0026#34;, S); return 0; } 传入结构体\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;pthread.h\u0026gt; typedef struct { int first; int last; } MY_ARGS; int arr[5000]; int s1 = 0; int s2 = 0; void *myfunc(void *args) { MY_ARGS *arg = (MY_ARGS *)args; for (int i = arg-\u0026gt;first; i \u0026lt; arg-\u0026gt;last; i++) { s1 += arr[i]; } return NULL; } int main() { for (int i = 0; i \u0026lt; 5000; i++) { arr[i] = rand() % 50; } pthread_t th1; pthread_t th2; MY_ARGS args_1 = {0, 2500}; MY_ARGS args_2 = {2500, 5000}; pthread_create(\u0026amp;th1, NULL, myfunc, \u0026amp;args_1); pthread_create(\u0026amp;th2, NULL, myfunc, \u0026amp;args_2); pthread_join(th1, NULL); pthread_join(th2, NULL); int S = s1 + s2; printf(\u0026#34;Result: %d\\n\u0026#34;, S); return 0; } 结构体的更多参数\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;pthread.h\u0026gt; typedef struct { int first; int last; int result; } MY_ARGS; int arr[5000]; void *myfunc(void *args) { MY_ARGS *arg = (MY_ARGS *)args; for (int i = arg-\u0026gt;first; i \u0026lt; arg-\u0026gt;last; i++) { arg-\u0026gt;result += arr[i]; } return NULL; } int main() { for (int i = 0; i \u0026lt; 5000; i++) { arr[i] = rand() % 50; } pthread_t th1; pthread_t th2; MY_ARGS args_1 = {0, 2500, 0}; MY_ARGS args_2 = {2500, 5000, 1}; pthread_create(\u0026amp;th1, NULL, myfunc, \u0026amp;args_1); pthread_create(\u0026amp;th2, NULL, myfunc, \u0026amp;args_2); pthread_join(th1, NULL); pthread_join(th2, NULL); int S = args_1.result + args_2.result; printf(\u0026#34;Result: %d\\n\u0026#34;, S); return 0; } 一些错误的写法\n它会造成 race condition\n// dangerous operation #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;pthread.h\u0026gt; int a = 0; void *myfunc(void *args) { for (int i = 0; i \u0026lt; 1000000; i++) { a++; } return NULL; } int main() { pthread_t pt1; pthread_t pt2; pthread_create(\u0026amp;pt1, NULL, myfunc, NULL); pthread_create(\u0026amp;pt2, NULL, myfunc, NULL); pthread_join(pt1, NULL); pthread_join(pt2, NULL); printf(\u0026#34;%d\\n\u0026#34;, a); return 0; } 加锁\n// in this way, it is slow #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;pthread.h\u0026gt; #define MAX_SIZE 5000000  pthread_mutex_t lock; int a = 0; void *myfunc(void *args) { for (int i = 0; i \u0026lt; 100000; i++) { pthread_mutex_lock(\u0026amp;lock); a++; pthread_mutex_unlock(\u0026amp;lock); } return NULL; } int main() { pthread_t pt1; pthread_t pt2; pthread_mutex_init(\u0026amp;lock, NULL); pthread_create(\u0026amp;pt1, NULL, myfunc, NULL); pthread_create(\u0026amp;pt2, NULL, myfunc, NULL); pthread_join(pt1, NULL); pthread_join(pt2, NULL); printf(\u0026#34;%d\\n\u0026#34;, a); return 0; } 较为完整的写法\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;pthread.h\u0026gt; #define ZERO 0 #define HALF 2500000 #define MAX_SIZE 5000000  typedef struct { int first; int last; int id; } MY_ARGS; int *arr; int result[2]; void *myfunc(void *args) { MY_ARGS *arg = (MY_ARGS *)args; for (int i = arg-\u0026gt;first; i \u0026lt; arg-\u0026gt;last; i++) { result[arg-\u0026gt;id] += arr[i]; } return NULL; } int main() { arr = (int *)malloc(sizeof(int) * MAX_SIZE); for (int i = 0; i \u0026lt; MAX_SIZE; i++) { arr[i] = rand() % 5; } result[0] = 0; result[1] = 0; pthread_t th1; pthread_t th2; MY_ARGS args_1 = {ZERO, HALF, 0}; MY_ARGS args_2 = {HALF, MAX_SIZE, 1}; pthread_create(\u0026amp;th1, NULL, myfunc, \u0026amp;args_1); pthread_create(\u0026amp;th2, NULL, myfunc, \u0026amp;args_2); pthread_join(th1, NULL); pthread_join(th2, NULL); int S = result[0] + result[1]; printf(\u0026#34;Result: %d\\n\u0026#34;, S); return 0; } ","permalink":"https://aimerneige.com/zh/post/c-thread-basic/","summary":"thread 线程 有共享内存   process 进程 没有共享内存    gcc file.c -lpthread 创建线程\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;pthread.h\u0026gt; void *myfunc(void *args) { for (int i = 0; i \u0026lt; 50; i++) { printf(\u0026#34;%d\\n\u0026#34;, i); } return NULL; } int main() { pthread_t th1; pthread_t th2; pthread_create(\u0026amp;th1, NULL, myfunc, NULL); pthread_create(\u0026amp;th2, NULL, myfunc, NULL); pthread_join(th1, NULL); pthread_join(th2, NULL); return 0; } 传入参数","title":"C 语言多线程基础"},{"content":"在 C 语言中，函数默认是全局的。在函数前加“static”关键字可以使一个函数变成静态函数。例如，下面的函数 fun() 是静态的：\nstatic int fun(void) { printf(\u0026#34;I am a static funciton.\\n\u0026#34;); } 与 C 语言中的全局函数不同，对静态函数的访问仅限于声明它们的文件。因此，当我们想要限制函数的访问时，我们可以将函数定义为静态的。另外，如果我们想要在其他文件中使用相同的函数名，我们也可以将函数定义为静态的。\n例如，我们在文件 file.c 中存储了下面的程序：\n// in file `file1.c` #include \u0026lt;stdio.h\u0026gt; static void fun1() { printf(\u0026#34;fun1 called.\\n\u0026#34;); } 然后，我们在文件 file2.c 中存储了这样的程序：\n// in file `file2.c` #include \u0026lt;stdio.h\u0026gt; int main(void) { fun1(); return 0; } 接下来，如果我们按照如下的命令编译：\ngcc file2.c file1.c 你会得到这样的链接错误：\nundefined reference to `fun1\u0026#39; 这是因为 fun1() 函数在 file1.c 中被定义为静态，因而不能在 file2.c 中引用。\n","permalink":"https://aimerneige.com/zh/post/c-static-function/","summary":"在 C 语言中，函数默认是全局的。在函数前加“static”关键字可以使一个函数变成静态函数。例如，下面的函数 fun() 是静态的：\nstatic int fun(void) { printf(\u0026#34;I am a static funciton.\\n\u0026#34;); } 与 C 语言中的全局函数不同，对静态函数的访问仅限于声明它们的文件。因此，当我们想要限制函数的访问时，我们可以将函数定义为静态的。另外，如果我们想要在其他文件中使用相同的函数名，我们也可以将函数定义为静态的。\n例如，我们在文件 file.c 中存储了下面的程序：\n// in file `file1.c` #include \u0026lt;stdio.h\u0026gt; static void fun1() { printf(\u0026#34;fun1 called.\\n\u0026#34;); } 然后，我们在文件 file2.c 中存储了这样的程序：\n// in file `file2.c` #include \u0026lt;stdio.h\u0026gt; int main(void) { fun1(); return 0; } 接下来，如果我们按照如下的命令编译：\ngcc file2.c file1.c 你会得到这样的链接错误：\nundefined reference to `fun1\u0026#39; 这是因为 fun1() 函数在 file1.c 中被定义为静态，因而不能在 file2.c 中引用。","title":"C 语言静态函数"},{"content":" 注意将本文章提到的路径中 AimerNeige 修改为自己的用户名，之后不再赘述。\n 安装 alacritty 按照自己的喜好 在 GitHub 下载最新版 release 或自己编译。\n本次演示中可执行文件存储目录：\n‪C:\\Tools\\Alacritty\\alacritty.exe\n配置 alacritty 将配置文件放置在如下目录：\nC:\\Users\\AimerNeige\\AppData\\Roaming\\alacritty\\alacritty.yml\n配置方法和 Linux 下类似。\n我的配置文件\n将 alacrity 注册为右键菜单启动 新建文本文件，填入如下内容，修改后缀为 .reg 运行，将配置写入注册表。\nWindows Registry Editor Version 5.00 [HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\alacritty] @=\u0026quot;Alacritty terminal here\u0026quot; \u0026quot;Icon\u0026quot;=\u0026quot;C:\\\\Tools\\\\Alacritty\\\\alacritty.ico\u0026quot; [HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\alacritty\\command] @=\u0026quot;C:\\\\Tools\\\\Alacritty\\\\alacritty.exe\u0026quot; 当然，你也可以按照自己的喜好手动编辑注册表。\n其中 Icon 这一行中使用的的图标文件可以在 GitHub 官方仓库 下载，或者也可以使用自己喜欢的内容。\n你也可以将 @=\u0026quot;Alacritty terminal here\u0026quot; 修改为自己喜欢的内容。\n","permalink":"https://aimerneige.com/zh/post/alacritty-on-windows/","summary":"注意将本文章提到的路径中 AimerNeige 修改为自己的用户名，之后不再赘述。\n 安装 alacritty 按照自己的喜好 在 GitHub 下载最新版 release 或自己编译。\n本次演示中可执行文件存储目录：\n‪C:\\Tools\\Alacritty\\alacritty.exe\n配置 alacritty 将配置文件放置在如下目录：\nC:\\Users\\AimerNeige\\AppData\\Roaming\\alacritty\\alacritty.yml\n配置方法和 Linux 下类似。\n我的配置文件\n将 alacrity 注册为右键菜单启动 新建文本文件，填入如下内容，修改后缀为 .reg 运行，将配置写入注册表。\nWindows Registry Editor Version 5.00 [HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\alacritty] @=\u0026quot;Alacritty terminal here\u0026quot; \u0026quot;Icon\u0026quot;=\u0026quot;C:\\\\Tools\\\\Alacritty\\\\alacritty.ico\u0026quot; [HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\alacritty\\command] @=\u0026quot;C:\\\\Tools\\\\Alacritty\\\\alacritty.exe\u0026quot; 当然，你也可以按照自己的喜好手动编辑注册表。\n其中 Icon 这一行中使用的的图标文件可以在 GitHub 官方仓库 下载，或者也可以使用自己喜欢的内容。\n你也可以将 @=\u0026quot;Alacritty terminal here\u0026quot; 修改为自己喜欢的内容。","title":"在 Windows10 安装和配置 alacritty"},{"content":"GCC 简介 GCC 是 Linux 下的编译工具集，是 GNU Compiler Collection 的缩写,包含 gcc 、 g++ 等编译器。这个工具集不仅包含编译器，还包含其他工具集，例如 ar 、 nm 等。\nGCC 工具集不仅能编译 C/C++ 语言，其他例如 Objective-C 、 Pascal 、 Fortran 、 Java 、 Ada 等语言均能进行编译。\nGCC 在可以根据不同的硬件平台进行编译，即能进行交叉编译，在 A 平台上编译 B 平台的程序，支持常见的 X86 、 ARM 、 PowerPC 、 mips 等，以及 Linux 、 Windows 等软件平台。\nGCC 的 C 编译器 是 gcc，其命令格式为 :\nUsage: gcc [options] file... GCC 下默认文扩展名的含义：\n   文件扩展名 GCC 所理解的含义     *.c 该类文件为 C 语言的源文件   *.h 该类文件为 C 语言的头文件   *.i 该类文件为预处理后的 C 文件   *.C 该类文件为 C++ 语言的源文件   *.cc 该类文件为 C++ 语言的源文件   *.cxx 该类文件为 C++ 语言的源文件   *.m 该类文件为 Objective-C 语言的源文件   *.s 该类文件为汇编语言的源文件   *.o 该类文件为汇编后的目标文件   *.a 该类文件为静态库   *.so 该类文件为共享库   a.out 该类文件为链接后的输出文件    GCC 下有很多编译器，可以支持 C 语言，C++语言等多种语言\n   GCC 编译器命令 含义     cc 指的是 C 语言编译器   cpp 指的是预处理编译器   gcc 指的是 C 语言编译器   g++ 指的是 C++语言编译器    编译程序的基本知识 GCC 编译器对程序的编译分为 4 个阶段：\n 预编译 编译和优化 汇编 链接  GCC 的编译器可以将这 4 个步骤合并成一个。\n源文件指存放可编辑代码的文件，如存放 C/C++ 和汇编语言的文件。\n目标文件是指经过编译器的编译生成的 CPU 可识别的二进制代码，但是目标文件一般不能执行，因为其中的一些函数过程没有相关的指示和说明。\n可执行文件就是目标文件与相关的库链接后的文件，它是可以执行的。\n预编译过程将程序中引用的头文件包含进源代码中，并对一些宏进行替换。\n编译过程将用户可识别的语言翻译成一组处理器可识别的操作码，生成目标文件，通常翻译成汇编语言，而汇编语言通常和机器操作码之间是一种一对一的关系。 GNU 中有 C/C++ 编译器 GCC 和汇编器 as。\n所有的目标文件必须用某种方式组合起来才能运行，这就是链接的作用。目标文件中通常仅解析了文件内部的变量和函数，对于引用的函数和变量还没有解析，这需要将其他已经编写好的目标文件引用进来，将没有解析的变量和函数进行解析，通常引用的目标是库。链接完成后会生成可执行文件。\n单个文件编译成执行文件 下面是一个示例程序的源代码：\n// hello.c #include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;Hello World!\\n\u0026#34;); return 0; } 将其保存在 hello.c 文件中，运行如下命令将代码直接编译成可执行文件：\n$ gcc hello.c 上述命令没有指定生成执行文件的名称， GCC 将生成默认的文件名 a.out。 运行结果如下：\n$ ./a.out Hello World! 如果希望生成指定的可执行文件名，选项 -o 可以使编译程序生成指定文件名，例如将上述程序编译输出一个名称为 test 的执行程序：\n$ gcc -o test hello.c 上述命令把 hello.c 源文件编译成可执行文件 test。 运行可执行文件 test，向终端输出 \u0026quot;Hello World!\u0026quot; 字符串。运行结果如下：\n$ ./test Hello World! 编译生成目标文件 GCC 的 -c 选项可以用于生成目标文件，这一选项将源文件生成目标文件，而不是生成可执行文件。默认情况下生成的目标文件的文件名和源文件的名称一样，只是扩展名为 .o。例如，下面的命令会生成一个名字为 Hello.o 的目标文件：\n$ gcc -c hello.c 如果需要生成指定的文件名，可以使用 -o 选项。下面的命令将源文件 hello.c 编译成目标文件，文件名为 test.o：\n$ gcc -c -o test.o hello.c 可以用一条命令编译多个源文件，生成目标文件，这通常用于编写库文件或者一个项目中包含多个源文件。例如一个项目包含 filel.c 、 file2.c 和 file3.c, 下面的命令可以将源文件生成 3 个目标文件 : filel.o 、 file2.o 和 file3.o：\n$ gcc -c file1.c file2.c file3.c 多文件编译 GCC 可以自动链接多个文件，不管是目标文件还是源文件，都可以使用同一个命令编译到一个可执行文件中。例如一个项目包含俩个文件，文件 string.c 中有一个函数 StrLen 用于计算字符串的长度，而在 main.c 中调用这个函数将计算结果显示出来。\n源文件 string.c // string.c #define ENDSTRING \u0026#39;\\0\u0026#39; int StrLen(char *string) { int len = 0; while (*string++ != ENDSTRING) { len++; } return len; } 源文件 main.c // main.c #include \u0026lt;stdio.h\u0026gt;extern int StrLen(char *str); int main() { char src[] = \u0026#34;Hello AimerNeige!\\n\u0026#34;; printf(\u0026#34;String length is: %d\\n\u0026#34;, StrLen(src)); return 0; } 编译运行 下面的命令将俩个源文件中的程序编译成一个执行文件，文件名为 test。\n$ gcc -o test strung.c main.c 执行编译出来的可执行文件 test，程序的运行结果如下：\n$ ./test String length is: 18 当然也可以先将源文件编成目标文件，然后进行链接。例如，下面的过程将 string.c 和 main.c 源文件编译成目标文件 string.o 和 main.o，然后将 string.o 和 main.o 链接生成 test ：\n$ gcc -c string.c main.c $ gcc -o test string.o main.o 预处理 在 C 语言程序中，通常需要包含头文件并会定义一些宏。 预处理过程将源文件中的头文件包含进源文件中，并且将文件中定义的宏进行扩展。\n编译程序时选项 -E 告诉编译器进行预编译操作。例如如下命令将文件 string.c 的预处理结果显示在计算机屏幕上 :\n$ gcc -E string.c 如果需要指定源文件编译后生成的中间结果文件名，需要使用选项 -o。例如，下面的代码将文件 string.c 进行预编译，生成文件 string.i。\n$ gcc -o string.i -E string.c 编译成汇编语言 生成汇编语言的 GCC 选项 是 -S，默认情况下生成的文件名和源文件一致，扩展名为 .s。例如，下面的命令将 C 语言源文件 string.c 编译成汇编语言，文件名为 string.s。\n$ gcc -S string.c 生成和使用静态链接库 静态库是 obj 文件的一个集合，通常静态库以 .a 为后缀。静态库由程序 ar 生成，现在静态库已经不像之前那么普遍了，这主要是由于程序都在使用动态库。\n静态库的优点是可以在不用重新编译程序库代码的情况下，进行程序的重新链接，这种方法节省了编译过程的时间（在编译大型程序的时候，需要花费很长时间）。但是由于现在系统的强大，编译的时间已经不是问题。静态库的另一个优势是开发者可以提供库文件给使用的人员，不用开放源代码，这是库函数提供者经常采用的手段。当然这也是程序模块化开发的一种手段，使每个软件开发人员的精力集中在自己的部分。在理论上，静态库的执行速度比共享库和动态库要快（1% ～ 5% ）。\n生成静态链接库 生成静态库，或者将一个 obj 文件加到已经存在的静态库的命令为 ar 库文件 obj文件1 obj文件2。创建静态库的最基本步骤是生成目标文件，这点前面已经介绍过。然后使用工具 ar 对目标文件进行归档。工具 ar 的 -r 选项，可以创建库，并把目标文件插入到指定库中。例如，将 string.o 打包为库文件 libstr.a 的命令为：\n$ ar -rcs libstr.a string.o 使用静态链接库 在编译程序的时候经常需要使用函数库，例如经常使用的 C 标准库等。GCC 链接时使用库函数和一般的 obj 文件的形式是一致的，例如对 main.c 进行链接的时候，需要使用之前已经编译好的静态链接库 libstr.a, 命令格式如下：\n$ gcc -o test main.c libstr.a 也可以使用命令 -l 库名 进行，库名是不包含函数库和扩展名的字符串。例如编译 main.c 链接静态库 libstr.a 的命令可以修改为：\n$ gcc -o test main.c -lstr 上面的命令将在系统默认的路径下查找 str 函数库，并把它链接到要生成的目标程序上。可能系统会提示无法找到库文件 str , 这是由于 str 库函数没有在系统默认的查找路径下，需要显示指定库函数的路径，例如库文件和当前编译文件在同一目录下：\n$ gcc -o test main.c -L./ -lstr 生成动态链接库 动态链接库是程序运行时加载的库，当动态链接库正确安装后，所有的程序都可以使用动态库来运行程序。动态链接库是目标文件的集合，目标文件在动态链接库中的组织方式是按照特殊方式形成的。库中函数和变量的地址是相对地址，不是绝对地址，其真实地址在调用动态库的程序加载时形成。\n动态链接库的名称有别名(soname)、真名(realname)和链接名(linker name)。别名由一个前缀 lib，然后是库的名字，再加上一个后缀 .so 构成。真名是动态链接库的真实名称，一般总是在别名的基础上加上一个小版本号、发布版本等构成。除此之外，还有一个链接名，即程序链接时使用的库的名字。在动态链接库安装的时候，总是复制库文件到某个目录下，然后用一个软链接生成别名，在库文件进行更新的时候，仅仅更新软链接即可。\n生成动态链接库 生成动态链接库的命令很简单，使用 -fPIC 选项或者 -fpic。 -fPIC 和 -fpic 选项的作用是使得 gcc 生成的代码是位置无关的，例如下面的命令将 string.c 编译生成动态链接库：\n$ gcc -shared -Wl,-soname,libstr.so -o libstr.so.1 string.c 其中，选项 -soname,libstr.so 表示生成动态库时的别名是 libstr.so； -o libstr.so.l 选项则表示是生成名字为 libstr.so.1 的实际动态链接库文件； -shared 告诉编译器生成一个动态链接库。\n生成动态链接库之后一个很重要的问题就是安装，一般情况下将生成的动态链接库复制到系统默认的动态链接库的搜索路径下，通常有/lib 、 /usr/lib 、 /usr/local/lib，放到以上任何一个目录下都可以。\n动态链接库的配置 动态链接库不能随意使用，要在运行的程序中使用动态链接库，需要指定系统的动态链接库搜索的路径，让系统找到运行所需的动态链接库才可以。系统中的配置文件 /etc/ld.so.conf 是动态链接库的搜索路径配置文件。在这个文件内，存放着可被 Linux 共享的动态链接库所在目录的名字（系统目录/lib 、/usr/lib 除外），多个目录名间以空白字符（空格、换行等）或冒号或逗号分隔。查看系统中的动态链接库配置文件的内容：\n$ cat /etc/ld.so.conf include /etc/ld.so.conf.d/*.conf 查看这个文件夹\n$ ls /etc/ld.so.conf.d fakeroot-x86_64-linux-gnu.conf x86_64-linux-gnu.conf i386-linux-gnu.conf zz_i386-biarch-compat.conf libc.conf 从上面的配置文件可以看出， 在系统的动态链接库配置中，包含了该动态库 /lib/i386-linux-gnu 、 /usr/lib/i386-linux-gnu 和 /lib/i686- linux-gnu 、 /usr/lib/i686-linux-gnu 四个目录。\n动态链接库管理命令 为了让新增加的动态链接库能够被系统共享，需要运行动态链接库的管理命令 ldconfig。 ldconfig 命令的作用是在系统的默认搜索路径，和动态链接库配置文件中所列出的目录里搜索动态链接库，创建动态链接装入程序需要的链接和缓存文件。搜索完毕后，将结果写入缓存文件 /etc/ld.so.cache 中，文件中保存的是已经排好序的动态链接库名字列表。ldconfig 命令行的用法如下：\nldconfig [-v|--verbose] [-n] [-N] [-X] [-f CONF] [-C CACHE] [-r ROOT] [-l] [-p|--print-cache] [-c FORMAT] [--format=FORMAT] [-V] [-?|--help|--usage] path... ldconfig 的选项含义：\n   选项 含义     -v 此选项打印 ldconfig 的当前版本号，显示所扫描的每一个目录和动态链接库   -n 此选项处理命令行指定的目录，不对系统的默认目录 /lib 、 /usr/lib 进行扫描，也不对配置文件 /etc/ld.so.conf 中所指定的目录进行扫描   -N 此选项 ldconfig 不会重建缓存文件   -X 此选项 ldconfig 不更新链接   -f CONF 此选项使用用户指定的配置文件代替默认文件 /etc/ld.so.conf   -C CACHE 此选项使用用户指定的缓存文件代替系统默认的缓存文件 /etc/ld.so.cache   -r ROOT 此选项改变当前应用程序的根目录   -l 此选项用于手动链接单个动态链接库   -p \u0026ndash;print-cache 此选项用于打印出缓存文件中共享库的名字    如果想知道系统中有哪些动态链接库，可以使用 ldconfig 的 -p 选项来列出缓存文件中的动态链接库列表。\n使用 ldconfig 命令，默认情况下并不将扫描的结果输出。使用 -v 选项会将 ldconfig 在运行过程中扫描到的目录和共享库信息输出到终端，用户可以看到运行的结果和中间的信息。在执行 ldconfig 后，将刷新缓存文件 /etc/ld.so.cache 。\n当用户的目录并不在系统动态链接库配置文件 etc/ld.so.conf 中指定的时候，可以使用 ldconfig 命令显示指定要扫描的目录，将用户指定目录中的动态链接库放入系统中进行共享。命令格式的形式为：\n$ ldconfig 目录名 这个命令将 ldconfig 指定的目录名中的动态链接库放入系统的缓存 /etc/ld.so.cache 中，从而可以被系统共享使用。\n下面的代码将扫描当前用户的 lib 目录，将其中的动态链接库加入系统：\n$ ldconfig ~/lib  如果在运行上还命令后，再次运行 ldconfig 而没有加参数，系统会将 /lib 、 /usr/lib 及 etc/ld.so.conf 中指定目录中的动态库加入缓存，这时候上述代码中的动态链接库可能不被系统共享了。\n 使用动态链接库 在编译程序时，使用动态链接库和静态链接库是一致的，使用 -l 库名 的方式，在生成可执行文件的时候会链接库文件。例如下面的命令将源文件 main.c 编译成可执行文件 test ，并链接库文件 libstr.a 或者 libstr.so：\n$ gcc -o test main.c -L./ -lstr -L 指定链接动态链接库的路径， -lstr 链接库函数 str 。但是运行 test 一般会出现如下问题：\n./test: error while loading shared libraries: libstr.so: cannot open shared object file: No such file or directory 这是由于程序运行时没有找到动态链接库造成的。程序编译时链接动态链接库和运行时使用动态链接库的概念是不同的，在运行时，程序链接的动态链接库需要在系统目录下才行。有以下几种办法可以解决此问题。\n 将动态链接库的目录放到程序搜索路径中，可以将库的路径加到环境变量 LD_LIBRARY_PATH 中实现，例如：  $ export LD_LIBRARY_PATH=/example/ex02: $LD_LIBRARY_PATH 将存放库文件 libstr.so 的路径 /example/ex02 加入到搜索路径中，再运行程序就没有之前的警告了。\n 另一种方法是使用 ld-Linux.so.2 来加载程序，命令格式为：  /lib/ld-Linux.so.2 --library-path 路径 程序名 加载 test 程序的命令为：\n/lib/ld-Linux.so.2 --library-path /example/ex02 test  如果系统的搜索路径下同时存在静态链接库和动态链接库，默认情况下会链接动态链接库。如果需要强制链接静态链接库， 需要加上 -static 选项，即上述的编译方法改为如下的方式：\n $ gcc -o test main.c -static -lstr 动态加载库 动态加载库和一般的动态链接库所不同的是，一般动态链接库在程序启动的时候就要寻找动态库，找到库函数；而动态加载库可以用程序的方法来控制什么时候加载。\n动态加载库主要有函数 dlopen() dlerror() dlsym() dlclose() 。\n打开动态库 dlopen() 函数 函数 dlopen() 按照用户指定的方式打开动态链接库，其中参数 filename 为动态链接库的文件名，flag为打开方式，一般为 RTLD_LASY， 函数的返回值为库的指针。其函数原型如下：\nvoid *dlopen(const char *filename, int flag); 例如，下面的代码使用 dlopen 打开当前目录下的动态库 libstr.so 。\nvoid *phandle = dlopen(\u0026#34;./libstr.so\u0026#34;, RTLD_LAZY); 获得函数指针 dlsym() 使用动态链接库的目的是调用其中的函数，完成特定的功能。函数 dlsym() 可以获得动态链接库中指定函数的指针，然后可以使用这个函数指针进行操作。函数 dlsym() 的原型如下：\nvoid *dlsym(void *handle, char *symbol); 其中参数 handle 为 dlopen() 打开动态库后返回的句柄，参数 symbol 为函数的名称，返回值为函数指针。\n使用动态加载库的一个例子 下面是一个动态加载库使用的例子。首先使用函数 dlopen() 来打开动态链接库，判断是否正常打开，可以使用函数 dlerror() 判断错误。如果上面的过程正常，使用函数 dlsym() 来获得动态链接库中的某个函数，可以使用这个函数来完成某些功能。其代码如下：\n#include \u0026lt;dlfcn.h\u0026gt; int main(void) { char src[] = \u0026#34;Hello AimerNeige!\u0026#34;; int (*pStrLenFun) (char *str); void *phandle = NULL; char *perr = NULL; phandle = dlopen(\u0026#34;./libstr.so\u0026#34;, RTLD_LAZY); if (!phandle) { printf(\u0026#34;Failed Load library!\\n\u0026#34;); } perr = dlerror(); if (perr != NULL) { printf(\u0026#34;%s\\n\u0026#34;, perr); return 0; } pStrLenFun = dlsym(phandle, \u0026#34;StrLen\u0026#34;); perr = dlerror(); if (perr != NULL) { printf(\u0026#34;%s\\n\u0026#34;, perr); return 0; } printf(\u0026#34;The string length is: %d\\n\u0026#34;, pStrLenFun(src)); dlclose(phandle); return 0; } 编译上述文件的时候需要链接动态库 libdl.so，使用如下的命令将上述代码编译成可执行文件 testdl。命令将 main.c 编译成可执行文件 testdl，并链接动态链接库 libdl.so。\n$ gcc -o testdl main.c libstr.so -ldl 执行文件 testdl 的结果为：\n$ ./testdl string length is: 18 GCC 常用选项 -DMACRO 选项 定义一个宏，在多种预定义的程序中会经常使用。如下代码根据系统是否定义 Linux 宏来执行不同代码。使用 -D 选项可以选择不同的代码段，例如 -DOS_LINUX 选项将执行代码段（1）。\n#ifdef OS_LINUX ...代码段（1） #else ...代码段（2） #endif  -Idir 将头文件的搜索路径扩大，包含 dir 目录。 -Ldir 将链接时使用的链接库搜索路径扩大，包含 dir 目录。gcc 都会优先使用共享程序库。 -static 仅选用静态程序库进行链接，如果一个目录中静态库和动态库都存在，则仅选用静态库。 -g 包括调试信息。 -On 优化程序，程序优化后执行速度会更快，程序的占用空间会更小。通常 gcc 会进行很小的优化，优化的级别可以选择，即 n。最常用的优化级别是 2。 -Wall 打开所有的 gcc 能够提供的、常用的警告信息。  GCC 常用选项及含义 -Wall 选项集合    GCC 的警告选项 含义     -Wchar-subscripts 这个选项针对数组的下标值，如果下标值是 char 类型的则给出警告。因为在一些平台上， char 类型的变量可能定义为 signed char, 是一个符号类型的整数，所以 char 类型的变量做下标时，当下标的值为负数时可能造成内存溢出。   -Wcomment 这个选项针对代码中的注释，如果出现不合适的注释格式的时候会出现警告。例如在 /*...*/ 中间出现 /*，或者在 //... 类型的注释末尾出现符号 \\ 的时候， GCC 给出警告   -Wformat 这个选项针对输入输出的格式，检查 printf 和 scanf 等格式化输入输出函数的格式字符串与参数类型的匹配情况，如果发现不匹配则发出警告   -Wimplicit 这个选项针对函数的声明，这个选项是选项 -Wimplicit-int 和选项 -Wimplicit-function-declaration 两个选项的集合。第一个选项在声明函数时如果没有指定返回值会给出警告；第二个参数如果在声明前调用函数会给出警告   -Wmissing-braces 这个选项针对结构类型或者数组初始化时的不合适格式。例如， int array[2][2] = {0, 0, 1, 1}; -Wm1ssmg-braces 由于初始化的表达式没有充分用 {} 括起来， GCC 会给出警告，应该采用下面的定义方法：int array[2][2] = { {0, 0}, {1, 1} };   -Wparentheses 这个选项针对多种优先级的操作符在一起或者代码结构难以看明白的操作，如果没有将操作进行明晰地分离， GCC 会给出警告。例如，`if (a \u0026amp;\u0026amp; b   -Wsequenve-point 这个选项针对顺序点，如果在代码中使用了有可能造成顺序点变化的语句， GCC 会给出警告。例如，代码 i = i++ 在不同的平台上 i 值的结果是不同的，如果使用了这样的代码，GCC 会给出警告   -Wswitch 这个选项针对 switch 语句，如果一个 switch 语句中没有 default 条件，GCC 会给出警告信息   -Wunused 这个选项针对代码中没有用到的变量、函数、值、转跳点等， 它是 -Wunused-function 、 -Wunused-label 、 -Wunused-variable 、 -Wunosed-value 选项的集合。 -Wunused-function 选项警告代码中存在没有使用的静态函数，或者只定义却没有实现的静态函数； -Wunused-label 选项警告代码中存在定义了却没有使用，或者使用了却没有定义的标签； -Wunused-variable 选项警告代码中存在定义了却没有使用的局部变量； -Wunused-value 选项警告代码中计算表达式的结果没有使用   -Wunused-parameter 这个选项针对函数参数，如果一个函数的参数在函数实现中没有用到， GCC 会给出警告信息   -Wuninitialized 这个选项针对没有初始化变量的使用，如果一个局部变量在使用之前没有初始化， GCC 会给出警告信息    非 -Wall 警告选项    GCC 的警告选项 含义     -Wflot-equal 这个选项针对浮点值相等的判定，由千浮点值的确切值难以得知，所以如果浮点值出现在相等判定的表达式中， GCC 会给出警告。浮点值的相等判定可以用浮点值的差与某个小值比较判定是否相等   -Wshadow 这个选项用千局部变量作用域内的同名变量，如果局部变量的作用域-Wshadow 范围内有其他同名变量时，局部变量会遮蔽全局变量，这时 GCC 会给出警告信息   -Wbad-functuin-cast 这个选项针对函数的返回值，当函数的返回值赋给不匹配的类型时，GCC 会给出警告信息   -Wsign-compare 这个选项针对有符号数和无符号数的比较，由于无符号数的优先级比有符号数的优先级高，二者进行比较运算的时候，会先将有符号数转换为无符号数。在负的有符号数和无符号数进行比较的时候，容易出现错误   -Waggregate-return 这个选项针对结构类型的函数返回值，如果函数的返回值为结构、联合等类型时， GCC 会给出警告信息   -Wmultichar 这个选项针对字符类型变量的错误赋值，当使用类似 char c = 'test' 这样的代码时， GCC 会给出警告   -Wunreachable-code 这个选项针对冗余代码，如果代码中有不能到达的代码时， GCC 会给出警告信息    其他    GCC 的警告选项 含义     -Wtraditional 选项 traditional 试图支待传统 C 编译器的某些方面    ANSI 兼容    GCC 的警告选项 含义     -ansi 与 ansi 的 C 语言兼容   -pedantic 允许发出 ANSI/ISO C 标准所列出的所有警告   -pedantic-errors 允许发出 ANSI/ISO C 标准所列出的所有错误    编译检查    GCC 的警告选项 含义     -fsynatax-only 仅进行编译检查而不实际编译程序     在编写代码的时候，不好的习惯会造成程序执行过程中发生错误。在一个比较大的项目中， 当程序运行起未后再查找这些错误是很困难的。因此一种好的习惯是使用编译选项将代码的警告信息显示出来，并对代码进行改正。例如，打开编译选项 -Wall 和 -W 来显示所有的警告信息，甚至更严格一些，打开 -Werror 将编译时的警告信息作为错误信息未处理，中断编译。\n ","permalink":"https://aimerneige.com/zh/post/gcc-basic/","summary":"GCC 简介 GCC 是 Linux 下的编译工具集，是 GNU Compiler Collection 的缩写,包含 gcc 、 g++ 等编译器。这个工具集不仅包含编译器，还包含其他工具集，例如 ar 、 nm 等。\nGCC 工具集不仅能编译 C/C++ 语言，其他例如 Objective-C 、 Pascal 、 Fortran 、 Java 、 Ada 等语言均能进行编译。\nGCC 在可以根据不同的硬件平台进行编译，即能进行交叉编译，在 A 平台上编译 B 平台的程序，支持常见的 X86 、 ARM 、 PowerPC 、 mips 等，以及 Linux 、 Windows 等软件平台。\nGCC 的 C 编译器 是 gcc，其命令格式为 :\nUsage: gcc [options] file... GCC 下默认文扩展名的含义：\n   文件扩展名 GCC 所理解的含义     *.","title":"GCC 基础"},{"content":"装修中\u0026hellip;\n各位大佬一定看了 yaml 就可以自动脑补一份完美的 html 吧。。。\n- { title: \u0026#39;伞\u0026#39;, intro: \u0026#39;一只咸鱼的学习记录\u0026#39;, link: \u0026#39;https://farewell12345.github.io/\u0026#39;, github: \u0026#39;https://github.com/farewell12345\u0026#39;, image: \u0026#39;https://avatars.githubusercontent.com/u/53655863?v=4\u0026#39; } - { title: \u0026#39;HelloWorld的小博客\u0026#39;, intro: \u0026#39;这里是一个小白的博客\u0026#39;, link: \u0026#39;https://mzdluo123.github.io/\u0026#39;, github: \u0026#39;https://github.com/mzdluo123\u0026#39;, image: \u0026#39;https://avatars.githubusercontent.com/u/23146087?v=4\u0026#39; } - { title: \u0026#39;TangZ\u0026#39;, intro: \u0026#39;TangZ 的个人页面\u0026#39;, link: \u0026#39;https://wstzj.github.io/\u0026#39;, github: \u0026#39;https://github.com/wstzj\u0026#39;, image: \u0026#39;https://avatars.githubusercontent.com/u/55931768?v=4\u0026#39; } - { title: \u0026#39;Kenvix\u0026#39;, intro: \u0026#39;党明学姐\u0026#39;, link: \u0026#39;https://kenvix.com/\u0026#39;, github: \u0026#39;https://github.com/kenvix\u0026#39;, image: \u0026#39;https://avatars.githubusercontent.com/u/4546175?v=4\u0026#39; } - { title: \u0026#39;HeoLis\u0026#39;, intro: \u0026#39;We need to go faster and deeper.\u0026#39;, link: \u0026#39;http://ishero.net/\u0026#39;, github: \u0026#39;https://github.com/wmpscc\u0026#39;, image: \u0026#39;https://avatars.githubusercontent.com/u/29891793?v=4\u0026#39; } - { title: \u0026#39;🔨\u0026#39;, intro: \u0026#39;🔨のBlog\u0026#39;, link: \u0026#39;https://geekhe-p.github.io/\u0026#39;, github: \u0026#39;https://github.com/geekhe-p\u0026#39;, image: \u0026#39;https://avatars.githubusercontent.com/u/55914926?v=4\u0026#39; } - { title: \u0026#39;异国迷宫的十字路口\u0026#39;, intro: \u0026#39;一位弱鸡带学生的个人博客\u0026#39;, link: \u0026#39;https://blog.fivezha.cn/\u0026#39;, github: \u0026#39;https://github.com/xmmmmmovo\u0026#39;, image: \u0026#39;https://avatars.githubusercontent.com/u/32405482?v=4\u0026#39; } - { title: \u0026#39;Gaein nidb\u0026#39;, intro: \u0026#39;Gaein nidb的网站\u0026#39;, link: \u0026#39;https://www.gaein.cn/\u0026#39;, github: \u0026#39;https://github.com/nidbCN\u0026#39;, image: \u0026#39;https://avatars.githubusercontent.com/u/36162655?v=4\u0026#39; } - { title: \u0026#39;fzf404\u0026#39;, intro: \u0026#39;fzf的网站\u0026#39;, link: \u0026#39;https://fzf404.top/\u0026#39;, github: \u0026#39;https://github.com/fzf404\u0026#39;, image: \u0026#39;https://avatars.githubusercontent.com/u/40832831?v=4\u0026#39; } - { title: \u0026#39;凛凛酱\u0026#39;, intro: \u0026#39;傻逼凛凛\u0026#39;, link: \u0026#39;https://baolong24.github.io/\u0026#39;, github: \u0026#39;https://github.com/baolong24\u0026#39;, image: \u0026#39;https://avatars.githubusercontent.com/u/30337499?v=4\u0026#39; } - { title: \u0026#39;Web-Worker\u0026#39;, intro: \u0026#39;道阻且长,行则将至。\u0026#39;, link: \u0026#39;https://web-worker.cn/\u0026#39;, github: \u0026#39;https://github.com/Star-caorui\u0026#39;, image: \u0026#39;https://avatars.githubusercontent.com/u/51264180?v=4\u0026#39; } - { title: \u0026#39;vritser\u0026#39;, intro: \u0026#39;半斤八两\u0026#39;, link: \u0026#39;https://vritser.github.io/\u0026#39;, github: \u0026#39;https://github.com/vritser\u0026#39;, image: \u0026#39;https://avatars.githubusercontent.com/u/16340478?v=4\u0026#39; } ","permalink":"https://aimerneige.com/zh/friends/","summary":"装修中\u0026hellip;\n各位大佬一定看了 yaml 就可以自动脑补一份完美的 html 吧。。。\n- { title: \u0026#39;伞\u0026#39;, intro: \u0026#39;一只咸鱼的学习记录\u0026#39;, link: \u0026#39;https://farewell12345.github.io/\u0026#39;, github: \u0026#39;https://github.com/farewell12345\u0026#39;, image: \u0026#39;https://avatars.githubusercontent.com/u/53655863?v=4\u0026#39; } - { title: \u0026#39;HelloWorld的小博客\u0026#39;, intro: \u0026#39;这里是一个小白的博客\u0026#39;, link: \u0026#39;https://mzdluo123.github.io/\u0026#39;, github: \u0026#39;https://github.com/mzdluo123\u0026#39;, image: \u0026#39;https://avatars.githubusercontent.com/u/23146087?v=4\u0026#39; } - { title: \u0026#39;TangZ\u0026#39;, intro: \u0026#39;TangZ 的个人页面\u0026#39;, link: \u0026#39;https://wstzj.github.io/\u0026#39;, github: \u0026#39;https://github.com/wstzj\u0026#39;, image: \u0026#39;https://avatars.githubusercontent.com/u/55931768?v=4\u0026#39; } - { title: \u0026#39;Kenvix\u0026#39;, intro: \u0026#39;党明学姐\u0026#39;, link: \u0026#39;https://kenvix.com/\u0026#39;, github: \u0026#39;https://github.com/kenvix\u0026#39;, image: \u0026#39;https://avatars.githubusercontent.com/u/4546175?v=4\u0026#39; } - { title: \u0026#39;HeoLis\u0026#39;, intro: \u0026#39;We need to go faster and deeper.","title":"Friends"},{"content":" 中北大学学生，学习物联网专业。Linux 用户，热爱开源和分享。\n 技能  使用的编程语言，软件和服务\n  golang python JavaScript vala Linux git mysql  工具  neovim VSCode VirtualBox Dbeaver Joplin Spotify  语言  中文 英语  教育  中北大学 宁武县高级中学 宁武一中  联系我 GitHub: https://github.com/AimerNeige/\n邮件: aimer.neige@aimerneige.com\n电报: @AimerNeige\n域名: aimerneige.com neige.icu\n","permalink":"https://aimerneige.com/zh/about/","summary":"中北大学学生，学习物联网专业。Linux 用户，热爱开源和分享。\n 技能  使用的编程语言，软件和服务\n  golang python JavaScript vala Linux git mysql  工具  neovim VSCode VirtualBox Dbeaver Joplin Spotify  语言  中文 英语  教育  中北大学 宁武县高级中学 宁武一中  联系我 GitHub: https://github.com/AimerNeige/\n邮件: aimer.neige@aimerneige.com\n电报: @AimerNeige\n域名: aimerneige.com neige.icu","title":"关于我 👨‍💻"}]