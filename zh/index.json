[{"content":"前言 距离上一次写博客文章已经很长时间了，因为经常重装系统，而每次在电脑上安装和配置 hexo 的博客都是一件比较麻烦的事情，于是就一直咕了。但是最近我发现了 hugo 这一简洁好用的博客系统，可以让我远离配置安装都又慢又麻烦的 hexo，使用下来体验很棒，而我恰好又打算换一个博客主题，于是决定使用 hugo 来搭建我的新博客。本文简要介绍如何安装和使用 hugo。\n安装 你可能需要  go 的开发环境 git 一个顺手的编辑器  你一定不需要  nodejs npm  安装 hugo 要安装 hugo 非常简单，以 fedora 系统为例，只需要执行如下指令：\nsudo dnf install hugo 创建站点文件夹 使用以下指令创建你的站点文件夹：\nhugo new site blog 切换到工作目录进行后续操作：\ncd blog 使用 git 进行版本控制：\ngit init 安装主题 挑选好合适的主题后，将其直接 clone 在 ./themes 文件夹下即可。\ngit clone https://github.com/adityatelange/hugo-PaperMod themes/PaperMod --depth=1  使用 --depth=1 参数会忽略历史 commit 记录。\n 当然，下载解压压缩包的方式也是可以的。\n如果想要方便版本控制和更新，使用如下指令添加 submodule：\ngit submodule add https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod --depth=1 当重新 clone 仓库后，执行如下指令 clone 主题子仓库：\ngit submodule update --init --recursive 更新主题：\ngit submodule update --remote --merge 配置 hugo 支持多种配置文件格式，由于 yaml 格式的配置文件更易读，下文将默认使用 yaml 配置。\n与 hexo 不同，hugo 的配置文件只有一个，按照你所使用的主题提供的文档来修改你的配置文件即可。\n应用主题 theme: \u0026#34;PaperMod\u0026#34; 修改主题配置 不同的主题会有不同的配置方法，具体查看主题提供的文档。\n请参考如下配置：\nbaseURL: \u0026#34;https://aimerneige.com/\u0026#34; languageCode: \u0026#34;en-us\u0026#34; title: \u0026#34;AimerNeige\u0026#39;s Blog\u0026#34; theme: \u0026#34;PaperMod\u0026#34; enableRobotsTXT: true buildDrafts: false buildFuture: false buildExpired: false defaultContentLanguage: en defaultContentLanguageInSubdir: true languages: en: languageName: \u0026#34;English\u0026#34; weight: 1 menu: main: - name: About url: about/ weight: 5 - name: Friends url: friends/ weight: 6 - name: Post url: post/ weight: 7 - name: Archive url: archives/ weight: 8 - name: Tags url: tags/ weight: 9 - name: Categories url: categories/ weight: 10 - name: Search url: search/ weight: 11 zh: languageName: \u0026#34;中文\u0026#34; weight: 2 menu: main: - name: 关于 url: about/ weight: 5 - name: 朋友 url: friends/ weight: 6 - name: 文章 url: post/ weight: 7 - name: 归档 url: archives/ weight: 8 - name: 标签 url: tags/ weight: 9 - name: 分类 url: categories/ weight: 10 - name: 搜索 url: search/ weight: 11 params: profileMode: enabled: true title: \u0026#34;Aimer Neige\u0026#34; subtitle: \u0026#34;技术宅拯救世界\u0026#34; imageUrl: \u0026#34;https://avatars.githubusercontent.com/u/51701792?v=4\u0026#34; imageTitle: \u0026#34;avatar.jpeg\u0026#34; imageWidth: 140 imageHeight: 140 params: env: production keywords: [Blog, OpenSource, Coding, Golang, Programming] author: \u0026#34;Aimer Neige\u0026#34; defaultTheme: auto disableThemeToggle: false ShowToc: true TocOpen: false ShowBreadCrumbs: true ShowReadingTime: false ShowPostNavLinks: true ShowShareButtons: false ShowCodeCopyButtons: true displayFullLangName: true editPost: URL: \u0026#34;https://github.com/aimerneige/blog/content\u0026#34; Text: \u0026#34;Suggest Changes\u0026#34; appendFilePath: true homeInfoParams: Title: \u0026#34;Aimer Neige\u0026#34; Content: \u0026#34;Tech Otakus Save The World\u0026#34; profileMode: enabled: true title: \u0026#34;Aimer Neige\u0026#34; subtitle: \u0026#34;Tech Otakus Save The World\u0026#34; imageUrl: \u0026#34;https://avatars.githubusercontent.com/u/51701792?v=4\u0026#34; imageTitle: \u0026#34;avatar.jpeg\u0026#34; imageWidth: 140 imageHeight: 140 socialIcons: - name: github url: \u0026#34;https://github.com/AimerNeige\u0026#34; - name: twitter url: \u0026#34;https://twitter.com/NeigeAimer\u0026#34; - name: steam url: \u0026#34;https://steamcommunity.com/id/AimerNeige\u0026#34; - name: Telegram url: \u0026#34;https://t.me/AimerNeige\u0026#34; - name: KoFi url: \u0026#34;https://ko-fi.com/aimerneige\u0026#34; - name: RsS url: \u0026#34;index.xml\u0026#34; taxonomies: category: categories tag: tags series: series outputs: home: - HTML - RSS - JSON 迁移 将原有文章复制到站点文件夹下，修改配置。\n测试 使用如下指令启动本地测试服务。\nhugo serve -D 部署 使用如下指令生成静态文件：\nhugo 之后上传到 github 即可：\ncd public git add -A git commit -m \u0026#34;commit message\u0026#34; git push ","permalink":"https://aimerneige.com/zh/post/hello-hugo/","summary":"前言 距离上一次写博客文章已经很长时间了，因为经常重装系统，而每次在电脑上安装和配置 hexo 的博客都是一件比较麻烦的事情，于是就一直咕了。但是最近我发现了 hugo 这一简洁好用的博客系统，可以让我远离配置安装都又慢又麻烦的 hexo，使用下来体验很棒，而我恰好又打算换一个博客主题，于是决定使用 hugo 来搭建我的新博客。本文简要介绍如何安装和使用 hugo。\n安装 你可能需要  go 的开发环境 git 一个顺手的编辑器  你一定不需要  nodejs npm  安装 hugo 要安装 hugo 非常简单，以 fedora 系统为例，只需要执行如下指令：\nsudo dnf install hugo 创建站点文件夹 使用以下指令创建你的站点文件夹：\nhugo new site blog 切换到工作目录进行后续操作：\ncd blog 使用 git 进行版本控制：\ngit init 安装主题 挑选好合适的主题后，将其直接 clone 在 ./themes 文件夹下即可。\ngit clone https://github.com/adityatelange/hugo-PaperMod themes/PaperMod --depth=1  使用 --depth=1 参数会忽略历史 commit 记录。\n 当然，下载解压压缩包的方式也是可以的。\n如果想要方便版本控制和更新，使用如下指令添加 submodule：\ngit submodule add https://github.","title":"Hello Hugo"},{"content":"前言 之前在学习安卓的时候，很想要给自己的软件增加一个云服务功能，但是苦于没有学过后端，于是开始在互联网上查找资料。但是遗憾的是，后端是一个很大的范围，我查找了很多后端的资料也几乎都是在讲解如何写网页，并没有专门用来给安卓写后端的教程，在广泛地学习了大量后端内容后，成功的为自己的程序开发了一个简单的 API。希望这篇文章能够帮到那些没有系统地学习过后端，但是却想要快速开发一款能用的 API 的安卓开发者。\n前期准备  你要了解互联网通讯原理 你要会一些基础的 JavaScript 你要有一台服务器 你会数据库操作 最好有一个域名（非必须） 掌握基础的终端操作  环境配置 本文章中后端开发使用的开发语言为 JavaScript 配合 nodejs。数据库采用常用的 mysql。\n 注： nodejs 开发常用的数据库是 mongodb，但是由于 mysql 比较常用这里就用 mysql 了，当然其他数据库也是可以的，你可以查找一下 nodejs 如何链接这些数据库，并将本文中 mysql 操作的部分替换掉就可以了。\n 本地测试客户端安装 你需要在自己用来开发的电脑上安装配置如下环境：\n nodejs npm  安装 nodejs Linux 下直接使用包管理安装即可。如果包管理安装的 node 很旧，可以自行谷歌一下安装方法，这里不再赘述。\n以 Ubuntu 为例，直接在终端执行如下指令：\nsudo apt install nodejs 安装完成后使用 node -v 查看 node 版本来确认安装是否成功。\n如果是 windows 用户就更加简单了，直接在 nodejs 官网 下载安装包运行即可。推荐使用长周期稳定版本。如果你想体验新特性，也可以考虑使用最新的版本。\n安装 npm 通常情况下，安装 nodejs 时会附带安装 npm，你可以直接使用 npm -v 来查看当前系统安装的 npm 版本来检测安装情况。\n如果没有安装，以 Ubuntu 系统为例，可以在终端执行下面的指令：\nsudo apt install npm windows 用户在执行完 node 的安装程序后 npm  会自动安装完成。\n服务器安装 你需要在服务器上安装配置如下环境：\n nodejs npm mysql nginx  安装 nodejs 与 npm 其中 nodejs 和 npm 的安装同客户端完全相同，这里不再赘述。\n安装 mysql mysql 可以一并安装在运行 node 项目的服务器上，也可以使用独立的数据库提供服务器。\n本文章主要讨论如何构建 API ，这里不再赘述如何安装配置 mysql。可以查看我的其他文章。\n安装 nginx nginx 用于将服务反向代理到 80 端口，以 Ubuntu 系统为例，直接在终端执行如下指令：\nsudo apt install nginx Windows 用户自行查阅相关资料。不会吧，不会吧，不会有人服务器用 windows 吧？？项目构建 使用模版 为了方便快速构建一个项目，我写了一个模版，你可以在 GitHub 上找到它。\n使用这个模版快速构建一个新的仓库，将它 clone 到本地，并进行下面的修改：\n 修改 package.json 修改 LICENSE 修改 README 在 src/config 下新建 db.js 写入数据库服务器的配置。  安装依赖 在项目路径下启动终端，执行如下指令：\nnpm i 这个指令是 npm install 的缩写，npm 会安装需要的依赖，本模版项目只依赖了俩个包：\n express mysql  依赖安装完成后，你会在项目路径下看到 node_modules 这个文件夹，它已经被写在 .gitignore 中，这个文件夹下是项目所需要的依赖，即使你意外地删掉了这个文件夹，再次执行 npm i 就可以将这些文件下载回来，所以你不应该在意这个文件夹中有什么内容，npm 会帮我们处理它。\n启动项目 使用 cd 命令切换到 src 目录下，执行下面的指令：\nnode app.js 之后你会在终端看到如下输出：\nServer start in development mode on http://localhost:4000; press Ctrl + C to terminated. 打开你的浏览器访问 http://localhost:4000/\n如果你看到下面的内容，说明项目成功启动了：\n{ \u0026#34;status\u0026#34;: 200, \u0026#34;info\u0026#34;: \u0026#34;If you see this, the server deploy success!\u0026#34; } 如果你在服务器启动项目，假设你的服务器 ip 为 43.192.82.215 并且配置了域名 api.aimerneige.com ，你可以通过在浏览器内访问下面的地址测试服务器：\n http://43.192.82.215:4000/ http://api.aimerneige.com:4000/  注意：\n 在本地测试启动的服务器只能通过 本地/内网 访问 在有公网 ip 的服务器上部署的服务可以在 任意浏览器内 打开  如果你在服务器测试，请注意以这样的方式运行仅能用来测试，不可以用作生产环境，后文会介绍如何在服务器部署项目。\n程序入口 项目可以启动后，说明环境配置无误，接下来可以开始写代码了。\n我们简单看一下程序的入口 app.js\n本项目依赖 express 构建，首先导入 express 的模块：\n// require const express = require(\u0026#34;express\u0026#34;); 接下来导入路由目录下的路由模块：\n// user require const indexRouter = require(\u0026#34;./routes/index\u0026#34;); 创建 express 对象：\n// express app var app = express(); 设置监听端口：\n// set port app.set(\u0026#34;port\u0026#34;, process.env.PORT || 4000); 添加可以支持 json 解析的中间件：\n// json parse app.use(express.json()); app.use(express.urlencoded({ extended: false })); 添加路由中间件：\n// routes app.use(\u0026#34;/\u0026#34;, indexRouter); 路由匹配失败后返回 404 错误：\n// catch 404 and forward to error handler app.use(function (req, res, next) { var err = new Error(\u0026#34;Not Found\u0026#34;); err.status = 404; next(err); }); 处理错误信息：\n// error handler app.use(function (err, req, res, next) { res.type(\u0026#34;application/json\u0026#34;); res.status(err.status || 500); res.send({ status: err.status || 500, message: err.message, }); }); 检测当前模块是否被直接执行，如果是则启动服务器，否者导出模块：\n// check if run app.js directly if (require.main === module) { app.listen(app.get(\u0026#34;port\u0026#34;), function () { console.log( \u0026#34;Server start in \u0026#34; + app.get(\u0026#34;env\u0026#34;) + \u0026#34; mode on http://localhost:\u0026#34; + app.get(\u0026#34;port\u0026#34;) + \u0026#34;; press Ctrl + C to terminated.\u0026#34; ); }); } else { module.exports = app; } 其他的代码可以暂时不去理会，最重要的是路由这一部分：\n// 导入路由模块 const indexRouter = require(\u0026#34;./routes/index\u0026#34;); // 添加路由中间件 app.use(\u0026#34;/\u0026#34;, indexRouter); 在编写 api 时，只需要在 /src/routes 目录下新建路由模块，并在 app.js 下引用即可。\n添加路由 接下来我们看一下默认的路由模块 index.js ：\n导入 express 模块：\nconst express = require(\u0026#34;express\u0026#34;); const router = express.Router(); 配置路由规则：\nrouter.get(\u0026#34;/\u0026#34;, function (req, res, next) { res.type(\u0026#34;application/json\u0026#34;); res.status(200); res.send({ status: 200, info: \u0026#34;If you see this, the server deploy success!\u0026#34;, }); }); 导出模块：\nmodule.exports = router; 其中重点即配置路由规则这一部分。\n我相信这几行代码还是很易懂的，相对地，如果我们想要使用 post 方法，访问路径为 /about 需要这样写：\nrouter.post(\u0026#34;/about\u0026#34;, fuction(){ /* function */ } ); 设置好请求方法和请求路径后，回调函数用来向客户端返回数据。\n设置返回数据类型，这里使用 json 进行数据传输：\nres.type(\u0026#34;application/json\u0026#34;); 设置返回状态码：\nres.status(200); 返回指定数据：\nres.send(return_data); 由于开发语言为 js ，而且本项目添加了解析 json 的中间件，如果想要返回 json，不需像其他语言那样要将对象解析为 json 字符串，直接返回一个对象即可，客户端会成功接收到正确的 json 字符串。\n// 服务器返回的对象 { status: 200, info: \u0026#34;If you see this, the server deploy success!\u0026#34;, } // 客户端拿到的字符串 { \u0026#34;status\u0026#34;: 200, \u0026#34;info\u0026#34;: \u0026#34;If you see this, the server deploy success!\u0026#34; } 书写好路由模块后在 app.js 中引用即可：\n// 导入模块 const indexRouter = require(\u0026#34;./routes/index\u0026#34;); // ... 中间的其他代码  // 在 app 中应用路由模块 app.use(\u0026#34;/\u0026#34;, indexRouter); 要注意模块导入的位置，不能乱放。和模版保持一致即可。\n添加更多的路由信息 就像上面的例子中所写的，我们可以继续添加新的路由模块，也可以在同一个路由模块下添加更多的访问路径。\n src/app.js  // ...  const indexRouter = require(\u0026#34;./routes/index\u0026#34;); const userRouter = require(\u0026#34;./routes/user\u0026#34;); // ...  app.use(\u0026#34;/\u0026#34;, indexRouter); app.use(\u0026#34;/user\u0026#34;, userRouter);  src/routes/index.js  // ...  // 访问路径 / router.get(\u0026#34;/\u0026#34;, fuction(){ /* function */ } ); // 访问路径 /about router.get(\u0026#34;/about\u0026#34;, function() { /* function */ }); // ...  src/routes/user.js  // ...  // 访问路径 /user/cat router.get(\u0026#34;/cat\u0026#34;, fuction(){ /* function */ } ); // 访问路径 /user/edit router.post(\u0026#34;/edit\u0026#34;, fuction(){ /* function */ } ); // 访问路径 /user/new router.psot(\u0026#34;/new\u0026#34;, fuction(){ /* function */ } ); // ... 获取客户端数据 获取请求参数信息 req.query 对象是由客户端请求参数构成的，在回调函数内，可以直接调用它来获取客户端请求参数，如果客户端传递了参数，我们就可以拿到对应的数据，否者我们只能得到 undefined。由此可以通过判空来确定客户端请求参数是否正确。\n例如我们的请求路径为 /data 所需请求参数为 id 和 class 可以这样写：\n 注： 对应的示例请求地址为 https://api.example.com/data?id=1930201\u0026amp;class=302\n router.get(\u0026#34;/data\u0026#34;, function (req, res) { res.type(\u0026#34;application/json\u0026#34;); if (req.query.class === undefined || req.query.id === undefined) { res.status(400); // 向客户端返回错误信息，提示客户端返回正确的参数  res.send({ status: 400, info: \u0026#34;Wrong arguments!\u0026#34;, }); } else { // 向用户返回数据（通常会用客户端参数来调用数据库，为了简便这里返回一个类做简单示范）  res.status(200); res.send({ status: 200, info: { class: req.query.class, id: req.query.id, }, }); } }); 我们可以通过判空来确定客户端请求参数是否正确，之后可以使用参数来进行其他操作，比如构建类，调取数据库等等。\n获取请求体信息 与请求参数类似，请求体信息也保存在一个类中，就是 req.body。使用方法和之前请求参数完全一致，这里只写一个示例，不多赘述。\nrouter.post(\u0026#34;/new\u0026#34;, function (req, res) { res.type(\u0026#34;application/json\u0026#34;); if (req.body.class === undefined || req.body.id === undefined) { res.status(400); // 向客户端返回错误信息，提示客户端返回正确的参数  res.send({ status: 400, info: \u0026#34;Wrong arguments!\u0026#34;, }); } else { var new_student = { class: req.body.class, id: req.body.id, }; // 向数据库内添加新的学生  res.status(200); res.send({ status: 200, info: \u0026#34;Student create successful!\u0026#34;, }); } }); 获取更多信息 在回调函数中，req 对象中保存了所有来自客户请求的数据，前面介绍的只是比较常用的，其他内容可以查找文档。\n获取数据库信息 配置数据库信息 参考 db.js.example 创建 db.js 写入服务器的配置\nvar mysql = require(\u0026#34;mysql\u0026#34;); var pool = mysql.createPool({ host: \u0026#34;host_ip\u0026#34;, user: \u0026#34;user_name\u0026#34;, password: \u0026#34;password\u0026#34;, database: \u0026#34;data\u0026#34;, port: 3306, }); function query(sql, callback) { pool.getConnection(function (err, connection) { connection.query(sql, function (err, rows) { callback(err, rows); connection.release(); }); }); } exports.query = query; 配置好数据库服务器后，就可以通过下面的方法访问数据库的数据了：\nsql_command = \u0026#34;DROP DATABASE *;\u0026#34;; // ⚠️ 注意修改 db.query(sql_command, function (err, result, fields) { if (err) { // 如果数据库指令执行出现了错误，返回错误信息  requestSQLFailedLog(sql_command, err); res.status(400); res.send({ status: 400, info: err }); } else { // 如果数据库指令执行成功，返回数据  requestSQLSuccessLog(sql_command, result); res.status(200); res.send(result); } }); 服务部署  待完善，咕咕咕\n  将项目上传到服务器 修改 db.js 的配置 cd src node cluster.js 如果你想要后台运行，执行 nohup node cluster.js \u0026amp;  ","permalink":"https://aimerneige.com/zh/post/build-api-with-nodejs-quickly/","summary":"前言 之前在学习安卓的时候，很想要给自己的软件增加一个云服务功能，但是苦于没有学过后端，于是开始在互联网上查找资料。但是遗憾的是，后端是一个很大的范围，我查找了很多后端的资料也几乎都是在讲解如何写网页，并没有专门用来给安卓写后端的教程，在广泛地学习了大量后端内容后，成功的为自己的程序开发了一个简单的 API。希望这篇文章能够帮到那些没有系统地学习过后端，但是却想要快速开发一款能用的 API 的安卓开发者。\n前期准备  你要了解互联网通讯原理 你要会一些基础的 JavaScript 你要有一台服务器 你会数据库操作 最好有一个域名（非必须） 掌握基础的终端操作  环境配置 本文章中后端开发使用的开发语言为 JavaScript 配合 nodejs。数据库采用常用的 mysql。\n 注： nodejs 开发常用的数据库是 mongodb，但是由于 mysql 比较常用这里就用 mysql 了，当然其他数据库也是可以的，你可以查找一下 nodejs 如何链接这些数据库，并将本文中 mysql 操作的部分替换掉就可以了。\n 本地测试客户端安装 你需要在自己用来开发的电脑上安装配置如下环境：\n nodejs npm  安装 nodejs Linux 下直接使用包管理安装即可。如果包管理安装的 node 很旧，可以自行谷歌一下安装方法，这里不再赘述。\n以 Ubuntu 为例，直接在终端执行如下指令：\nsudo apt install nodejs 安装完成后使用 node -v 查看 node 版本来确认安装是否成功。\n如果是 windows 用户就更加简单了，直接在 nodejs 官网 下载安装包运行即可。推荐使用长周期稳定版本。如果你想体验新特性，也可以考虑使用最新的版本。\n安装 npm 通常情况下，安装 nodejs 时会附带安装 npm，你可以直接使用 npm -v 来查看当前系统安装的 npm 版本来检测安装情况。","title":"使用 nodejs 快速为 Android 程序构建 API"},{"content":"在多人协作的项目中，为了同一代码格式，可以使用 editorconfig 来定义，这样不仅可以帮助协作者快速了解当前项目要求的代码风格，也可以方便使用一些格式化工具保证代码风格按照预期格式化。\n快速了解  What is EditorConfig? EditorConfig helps maintain consistent coding styles for multiple developers working on the same project across various editors and IDEs. The EditorConfig project consists of a file format for defining coding styles and a collection of text editor plugins that enable editors to read the file format and adhere to defined styles. EditorConfig files are easily readable and they work nicely with version control systems. Source: https://editorconfig.org/\n 简单示例  示例来自 https://editorconfig.org/\n # EditorConfig is awesome: https://EditorConfig.org # top-most EditorConfig file root = true # Unix-style newlines with a newline ending every file [*] end_of_line = lf insert_final_newline = true # Matches multiple files with brace expansion notation # Set default charset [*.{js,py}] charset = utf-8 # 4 space indentation [*.py] indent_style = space indent_size = 4 # Tab indentation (no size specified) [Makefile] indent_style = tab # Indentation override for all JS under lib directory [lib/**.js] indent_style = space indent_size = 2 # Matches the exact files either package.json or .travis.yml [{package.json,.travis.yml}] indent_style = space indent_size = 2 使用方法 直接在项目目录下新建文件 .editorconfig 写入配置，安装对应插件后即可，保存文件时会按照配置文件自动格式化。\n额外地，如果你在 Windows 下如果使用 Windows Explorer 新建 .editorconfig 文件，需要将文件名写为 .editorconfig.，Windows 会自动重命名为 .editorconfig。\n特殊符号的含义    符号 含义     * 匹配任何字符串，除了路径分割符 (/)   ** 匹配任何字符串   ? 匹配任何单字符   [name] 匹配 name 中所包含的任一字符   [!name] 匹配不包含在 name 中的任一字符   {s1,s2,s3} 匹配任何给定单字符串 (用逗号分割) (在 EditorConfig Core 0.11.0 后受支持)   {num1..num2} 匹配任何在 num1 和 num2 之间的数字，num1 和 num2 可以是正数也可以是负数    支持的配置属性  indent_style 缩进样式 {tab, space} indent_size 每次缩进相当于多少列 {2,4,8\u0026hellip;} (当 indent_style 设置为 space 时使用) tab_width 每次缩进相当于多少列 {2,4,8\u0026hellip;} (当 indent_style 设置为 tab 时使用) end_of_line 换行 {lf, cr, crlf} charset 编码 {latin1, utf-16be, utf-16le, utf-8, utf-8-bom, unset} trim_trailing_whitespace {true, false} 是否删掉结尾的空白字符 insert_final_newline {true, false} 是否在结尾插入新行 root {true, false} 是否顶级配置文件  ","permalink":"https://aimerneige.com/zh/post/editorconfig/","summary":"在多人协作的项目中，为了同一代码格式，可以使用 editorconfig 来定义，这样不仅可以帮助协作者快速了解当前项目要求的代码风格，也可以方便使用一些格式化工具保证代码风格按照预期格式化。\n快速了解  What is EditorConfig? EditorConfig helps maintain consistent coding styles for multiple developers working on the same project across various editors and IDEs. The EditorConfig project consists of a file format for defining coding styles and a collection of text editor plugins that enable editors to read the file format and adhere to defined styles. EditorConfig files are easily readable and they work nicely with version control systems.","title":"利用 EditorConfig 定义代码格式，统一代码风格"},{"content":"前言 Linux 下中文输入法一直是硬伤，各种方面都没有 windows 或 mac 下好用，最近在逛 github 的时候偶然翻到一个仓库 四叶草拼音输入方案，这个仓库提供的输入方案用起来十分舒服，但是在安装的时候也遇到一些坑，于是写了这篇文章来记录。\n 测试环境：\n.............. aimerneige@an ..,;:ccc,. ------------- ......\u0026#39;\u0026#39;\u0026#39;;lxO. OS: Kali GNU/Linux Rolling x86_64 .....\u0026#39;\u0026#39;\u0026#39;\u0026#39;..........,:ld; Host: TM1701 .\u0026#39;;;;:::;,,.x, Kernel: 5.9.0-kali4-amd64 ..\u0026#39;\u0026#39;\u0026#39;. 0Xxoc:,. ... Uptime: 2 hours, 11 mins .... ,ONkc;,;cokOdc\u0026#39;,. Packages: 3537 (dpkg) . OMo \u0026#39;:ddo. Shell: zsh 5.8 dMc :OO; Resolution: 1920x1080, 1440x2560 0M. .:o. DE: GNOME 3.38.2 ;Wd WM: Mutter ;XO, WM Theme: Kali-Dark ,d0Odlc;,.. Theme: Kali-Dark [GTK2/3] ..\u0026#39;,;:cdOOd::,. Icons: Flat-Remix-Blue-Dark [GTK2/\u0026gt; 3] .:d;.\u0026#39;:;. Terminal: gnome-terminal \u0026#39;d, .\u0026#39; CPU: Intel i7-8550U (8) @ 4.000GHz ;l .. GPU: NVIDIA GeForce MX250 .o GPU: Intel UHD Graphics 620 c Memory: 3698MiB / 15899MiB .\u0026#39; .  安装 fcitx5 sudo apt install fcitx5 启用 fcitx5 im-config 在开启的图形化界面中启用 fcitx5\n配置 fcitx5 编辑文件 ~/.xprofile 写入如下内容：\nexport GTK_IM_MODULE=fcitx5 export QT_IM_MODULE=fcitx5 export XMODIFIERS=\u0026#34;@im=fcitx5\u0026#34; export LANG=\u0026#34;zh_CN.UTF-8\u0026#34; export LC_CTYPE=\u0026#34;zh_CN.UTF-8\u0026#34; 编辑完成后注销账户，重新启动桌面\n安装 rime sudo apt install fcitx5-rime 启用 rime 在托盘处点击配置，并添加 rime。\n如果你的系统和我一样是英文，取消勾选“Only Show Current Language”即可查看中文选项\n更快地，你可以直接在上面的搜索框搜索 Rime\n安装输入方案 安装 四叶草拼音输入方案 提供的输入方案\n具体安装方法查看 项目 wiki\n更换简体中文 按下 Ctrl + ` 将输入模式切换为简体中文\n你也可以按照自己的喜好更改全角/半角的设置\n后记 如果你在安装中遇到任何问题，请查阅 fcitx rime 四叶草拼音输入方案 提供的文档。\n或是在 Arch Wiki 上查阅相关内容。\n","permalink":"https://aimerneige.com/zh/post/install-fcitx5-with-rime-on-linux/","summary":"前言 Linux 下中文输入法一直是硬伤，各种方面都没有 windows 或 mac 下好用，最近在逛 github 的时候偶然翻到一个仓库 四叶草拼音输入方案，这个仓库提供的输入方案用起来十分舒服，但是在安装的时候也遇到一些坑，于是写了这篇文章来记录。\n 测试环境：\n.............. aimerneige@an ..,;:ccc,. ------------- ......\u0026#39;\u0026#39;\u0026#39;;lxO. OS: Kali GNU/Linux Rolling x86_64 .....\u0026#39;\u0026#39;\u0026#39;\u0026#39;..........,:ld; Host: TM1701 .\u0026#39;;;;:::;,,.x, Kernel: 5.9.0-kali4-amd64 ..\u0026#39;\u0026#39;\u0026#39;. 0Xxoc:,. ... Uptime: 2 hours, 11 mins .... ,ONkc;,;cokOdc\u0026#39;,. Packages: 3537 (dpkg) . OMo \u0026#39;:ddo. Shell: zsh 5.8 dMc :OO; Resolution: 1920x1080, 1440x2560 0M. .:o. DE: GNOME 3.38.2 ;Wd WM: Mutter ;XO, WM Theme: Kali-Dark ,d0Odlc;,.. Theme: Kali-Dark [GTK2/3] ..\u0026#39;,;:cdOOd::,. Icons: Flat-Remix-Blue-Dark [GTK2/\u0026gt; 3] .","title":"Linux 下安装 fcitx5 与 Rime"},{"content":"ifconfig ➜ ~ ifconfig enx2c16dba37d18: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1500 inet 10.0.117.154 netmask 255.255.255.0 broadcast 10.0.117.255 inet6 2001:250:c00:218:5bd6:795c:5b92:e787 prefixlen 64 scopeid 0x0\u0026lt;global\u0026gt; inet6 fe80::2224:6ee:2527:f54d prefixlen 64 scopeid 0x20\u0026lt;link\u0026gt; inet6 2001:250:c00:218:44fc:ad73:aeb8:b07d prefixlen 64 scopeid 0x0\u0026lt;global\u0026gt; ether 2c:16:db:a3:7d:18 txqueuelen 1000 (Ethernet) RX packets 110382 bytes 150904005 (150.9 MB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 30811 bytes 3569027 (3.5 MB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 lo: flags=73\u0026lt;UP,LOOPBACK,RUNNING\u0026gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10\u0026lt;host\u0026gt; loop txqueuelen 1000 (Local Loopback) RX packets 26251 bytes 4892192 (4.8 MB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 26251 bytes 4892192 (4.8 MB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 wlp2s0: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1500 inet 192.168.7.243 netmask 255.255.255.0 broadcast 192.168.7.255 inet6 fe80::1dea:1bcb:ae17:fa3b prefixlen 64 scopeid 0x20\u0026lt;link\u0026gt; ether d0:c6:37:dd:91:95 txqueuelen 1000 (Ethernet) RX packets 17759 bytes 19498138 (19.4 MB) RX errors 0 dropped 7 overruns 0 frame 0 TX packets 6341 bytes 911629 (911.6 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 ping Linux 服务器无法上网\n ping localhost\n侦测网卡安装或配置有问题 ping 网关\nip route show 查看网关\n侦测局域网中的网关或路由器是否正常 ping dns server\n在 /etc/resolv.conf 查看 dns 配置\ndns 解析是否可以解析 ping 远程地址\n与外部的连接是否正常  mtr 网络侦测工具\n My traceroute [v0.93] an-xiaomi-book-pro (10.0.117.154) 2020-11-10T10:08:42+0800 Keys: Help Display mode Restart statistics Order of fields quit Packets Pings Host Loss% Snt Last Avg Best Wrst StDev 1. _gateway 0.0% 156 1.2 1.8 0.8 16.4 2.6 2. 10.125.255.2 0.0% 156 0.6 0.5 0.4 0.8 0.1 3. 172.16.1.254 96.8% 156 2.5 5.7 1.7 18.3 7.1 4. 129.210.99.202.internet. 0.0% 156 2.1 3.4 1.7 12.4 2.2 5. 57.53.26.218.internet.sx 0.0% 156 2.7 4.1 2.1 12.9 1.9 6. 165.151.26.218.internet. 0.0% 156 25.9 25.6 24.0 32.0 0.9 7. 219.158.101.109 0.0% 155 17.2 14.0 10.1 18.5 2.3 8. 219.158.5.158 0.0% 155 17.7 15.5 10.9 33.9 3.2 9. 219.158.16.70 0.0% 155 13.1 15.7 11.7 20.8 2.4 10. 219.158.32.30 18.7% 155 121.5 165.3 108.3 226.9 34.2 11. ae-1.r31.tokyjp05.jp.bb. 0.0% 155 56.5 109.5 55.6 173.8 34.5 12. ae-3.r01.tokyjp08.jp.bb. 18.1% 155 109.4 161.9 108.5 222.7 35.2 13. ae-3.fastly.tokyjp08.jp. 20.6% 155 106.5 161.5 105.9 219.5 33.7 14. 185.199.109.153 0.6% 155 159.2 210.4 157.4 271.3 33.6  Loss 丢包率 Snt 发送的次数 Last 最近一次的返回时延 Avg 平均值 Best 最短的一次时间 Wrst 最长的一次时间 StDev 标准偏差  traceroute / tracepath ➜ ~ traceroute aimerneige.com traceroute to aimerneige.com (185.199.109.153), 30 hops max, 60 byte packets 1 10.0.117.1 (10.0.117.1) 11.848 ms 11.768 ms 11.719 ms 2 10.125.255.2 (10.125.255.2) 0.605 ms 0.578 ms 0.544 ms 3 * * * 4 129.210.99.202.internet.sx.cn (202.99.210.129) 2.015 ms 1.965 ms 1.920 ms 5 233.124.26.218.internet.sx.cn (218.26.124.233) 1.874 ms 2.345 ms 237.124.26.218.internet.sx.cn (218.26.124.237) 2.304 ms 6 245.131.26.218.router-switch.sx.cn (218.26.131.245) 2.902 ms 209.151.26.218.internet.sx.cn (218.26.151.209) 40.287 ms 245.131.26.218.router-switch.sx.cn (218.26.131.245) 2.713 ms 7 219.158.105.93 (219.158.105.93) 10.882 ms 219.158.102.249 (219.158.102.249) 9.079 ms 219.158.101.109 (219.158.101.109) 13.673 ms 8 219.158.5.158 (219.158.5.158) 11.302 ms 11.258 ms 219.158.4.174 (219.158.4.174) 20.035 ms 9 219.158.16.70 (219.158.16.70) 11.866 ms 19.391 ms 19.316 ms 10 219.158.32.30 (219.158.32.30) 216.576 ms 220.853 ms 215.579 ms 11 ae-0.r30.tokyjp05.jp.bb.gin.ntt.net (129.250.2.11) 162.897 ms 162.880 ms ae-1.r31.tokyjp05.jp.bb.gin.ntt.net (129.250.2.153) 163.532 ms 12 ae-3.r01.tokyjp08.jp.bb.gin.ntt.net (129.250.6.133) 215.634 ms ae-3.r00.tokyjp08.jp.bb.gin.ntt.net (129.250.6.129) 213.725 ms ae-2.r00.tokyjp08.jp.bb.gin.ntt.net (129.250.6.127) 169.350 ms 13 * * * 14 * * * 15 * * * 16 * * * 17 * * * 18 * * * 19 * * * 20 * * * 21 * * * 22 * * * 23 * * * 24 * * * 25 * * * 26 * * * 27 * * * 28 * * * 29 * * * 30 * * * ➜ ~ tracepath aimerneige.com 1?: [LOCALHOST] pmtu 1500 1: _gateway 1.048ms 1: _gateway 1.195ms 2: 10.125.255.2 0.588ms 3: 172.16.1.254 5.206ms 4: 129.210.99.202.internet.sx.cn 2.954ms 5: 145.53.26.218.internet.sx.cn 2.496ms 6: 245.131.26.218.router-switch.sx.cn 4.198ms 7: 219.158.11.113 13.225ms 8: 219.158.5.158 19.169ms 9: 219.158.16.70 11.860ms 10: 219.158.32.30 226.589ms 11: ae-1.r31.tokyjp05.jp.bb.gin.ntt.net 165.652ms 12: ae-3.r00.tokyjp08.jp.bb.gin.ntt.net 200.616ms 13: no reply 14: no reply 15: no reply 16: no reply 17: no reply 18: no reply 19: no reply 20: no reply 21: no reply 22: no reply 23: no reply 24: no reply 25: no reply 26: no reply 27: no reply 28: no reply 29: no reply 30: no reply Too many hops: pmtu 1500 Resume: pmtu 1500 ip 查看网卡信息 ip addr show ➜ ~ ip addr show 1: lo: \u0026lt;LOOPBACK,UP,LOWER_UP\u0026gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever 2: wlp2s0: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc noqueue state UP group default qlen 1000 link/ether d0:c6:37:dd:91:95 brd ff:ff:ff:ff:ff:ff inet 192.168.7.243/24 brd 192.168.7.255 scope global dynamic noprefixroute wlp2s0 valid_lft 169205sec preferred_lft 169205sec inet6 fe80::1dea:1bcb:ae17:fa3b/64 scope link noprefixroute valid_lft forever preferred_lft forever 3: enx2c16dba37d18: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000 link/ether 2c:16:db:a3:7d:18 brd ff:ff:ff:ff:ff:ff inet 10.0.117.154/24 brd 10.0.117.255 scope global dynamic noprefixroute enx2c16dba37d18 valid_lft 3601sec preferred_lft 3601sec inet6 2001:250:c00:218:44fc:ad73:aeb8:b07d/64 scope global temporary dynamic valid_lft 601397sec preferred_lft 82623sec inet6 2001:250:c00:218:5bd6:795c:5b92:e787/64 scope global dynamic mngtmpaddr noprefixroute valid_lft 2591976sec preferred_lft 604776sec inet6 fe80::2224:6ee:2527:f54d/64 scope link noprefixroute valid_lft forever preferred_lft forever 启用/禁用网卡 sudo ip link set enp0s3 up / dowm 为网卡分配地址 sudo ip addr add 192.168.0.50/255.255.255.0 dev enp0s3 sudo ip addr del 192.168.0.10/24 dev enp0s3 ip route 查看路由\nip route\n➜ ~ ip route default via 10.0.117.1 dev enx2c16dba37d18 proto dhcp metric 100 default via 192.168.7.1 dev wlp2s0 proto dhcp metric 600 10.0.117.0/24 dev enx2c16dba37d18 proto kernel scope link src 10.0.117.154 metric 100 169.254.0.0/16 dev enx2c16dba37d18 scope link metric 1000 192.168.7.0/24 dev wlp2s0 proto kernel scope link src 192.168.7.243 metric 600 添加静态路由\nsudo ip route add 172.16.32.32 via 192.168.0.150/24 dev enp0s3\n删除路由\nsudo ip route del 192.168.0.150/24\narp 查看 arp 记录\nip neigh\n➜ ~ ip neigh 192.168.7.2 dev wlp2s0 lladdr e8:39:35:1f:13:b1 STALE 192.168.7.1 dev wlp2s0 lladdr 28:d1:27:85:38:d7 REACHABLE 10.0.117.177 dev enx2c16dba37d18 lladdr e8:39:35:1f:14:fc STALE 192.168.7.38 dev wlp2s0 lladdr 2c:ff:ee:66:e2:01 STALE 10.0.117.1 dev enx2c16dba37d18 lladdr 58:69:6c:07:71:4b REACHABLE 192.168.7.160 dev wlp2s0 lladdr 3e:22:9c:ef:b8:d2 STALE fe80::5a69:6cff:fe07:714b dev enx2c16dba37d18 lladdr 58:69:6c:07:71:4b router STALE  PERM 永久有效并且只能被管理员删除 NOARP 记录有效，过期后可被删除 STALE 记录有效，但可能已经过期 REACHABLE 记录有效，但超时后就失效了  增加 arp 记录\nsudo ip neigh add 192.168.0.150 lladdr 33:1g:75:37:r3:84 dev enp0s3 nud perm\n删除 arp\nsudo ip neigh del 192.168.0.106 dev enp0s3\ncurl / wget curl aimerneige.com\nwget aimerneige.com\nnetstat 网络连接状态以及其相关信息的程序\n告诉用户哪些网络连接正在运作\n 列出所有端口 netstat -a 列出所有 tcp 端口 netstat -at 列出所有 udp 端口 netstat -au 显示进程 id 和名称 netstat -p 显示路由信息 netstat -r 显示所有监听的端口 netstat -tnl  ","permalink":"https://aimerneige.com/zh/post/daily-linux-command/","summary":"ifconfig ➜ ~ ifconfig enx2c16dba37d18: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1500 inet 10.0.117.154 netmask 255.255.255.0 broadcast 10.0.117.255 inet6 2001:250:c00:218:5bd6:795c:5b92:e787 prefixlen 64 scopeid 0x0\u0026lt;global\u0026gt; inet6 fe80::2224:6ee:2527:f54d prefixlen 64 scopeid 0x20\u0026lt;link\u0026gt; inet6 2001:250:c00:218:44fc:ad73:aeb8:b07d prefixlen 64 scopeid 0x0\u0026lt;global\u0026gt; ether 2c:16:db:a3:7d:18 txqueuelen 1000 (Ethernet) RX packets 110382 bytes 150904005 (150.9 MB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 30811 bytes 3569027 (3.5 MB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 lo: flags=73\u0026lt;UP,LOOPBACK,RUNNING\u0026gt; mtu 65536 inet 127.","title":"每天一个 Linux 指令"},{"content":"今天遇到一个奇怪的问题：\n一个 C 语言初学者写了这样的错误代码：\nswitch (a) { case1: // do something  break; case2: // do something  break; case3: // do something  break; default: break; } 错误很容易解决，但是，在编译这样的程序时，编译器居然没有报错？？！！\n那么 case1 case2 这些东西是哪里来的？\n几番求证无果，最后在翻阅《C 专家编程》这本书的时候突然发现了原因：\n首先像下面这样写是可以的：\nswitch (i) { case 5 + 3: do_again: case 2: printf(\u0026#34;I loop unremittingly\\n\u0026#34;); goto do_again; default: i++; case 3: ; } 这里定义了一个标签 do_again，并且通过 goto 跳转。\n原错误代码中 case1 case2 等被编译器理解为了标签。\n由于 goto 不被建议使用，博主居然已经忘记了标签和 goto 的用法。\n不管怎么说，问题解决了。\n这不是 Bug，而是 C 语言的特性。 #(滑稽)\n类似地，有如下代码：\n#include \u0026lt;stdio.h\u0026gt; int main() { https://aimerneige.com  printf(\u0026#34;Hello World!\\n\u0026#34;); return 0; } 这里的代码直接贴上了一个 url，但是编译器也没有报错，是因为 https 被识别为标签，而后面的内容被识别为注释。\n","permalink":"https://aimerneige.com/zh/post/this-is-not-bug/","summary":"今天遇到一个奇怪的问题：\n一个 C 语言初学者写了这样的错误代码：\nswitch (a) { case1: // do something  break; case2: // do something  break; case3: // do something  break; default: break; } 错误很容易解决，但是，在编译这样的程序时，编译器居然没有报错？？！！\n那么 case1 case2 这些东西是哪里来的？\n几番求证无果，最后在翻阅《C 专家编程》这本书的时候突然发现了原因：\n首先像下面这样写是可以的：\nswitch (i) { case 5 + 3: do_again: case 2: printf(\u0026#34;I loop unremittingly\\n\u0026#34;); goto do_again; default: i++; case 3: ; } 这里定义了一个标签 do_again，并且通过 goto 跳转。\n原错误代码中 case1 case2 等被编译器理解为了标签。\n由于 goto 不被建议使用，博主居然已经忘记了标签和 goto 的用法。","title":"这不是 Bug，而是语言特性"},{"content":"函数指针在大型的 C 语言项目中十分重要，但是学校对它的介绍一带而过，国内一些介绍函数指针的文章十分粗浅甚至存在错误（这里就不点名了），因此博主写了这篇文章介绍函数指针，希望能够帮助一些 C 语言学习者。\n文章部分内容翻译引用于 https://www.geeksforgeeks.org/function-pointer-in-c/\n函数指针的概念 类似变量，函数也会被分配一段存储空间，这段存储空间的首地址即被称做这个函数的地址。而且函数名表示的就是这个地址。既然是地址，我们就可以定义一个指针变量来存放，这个指针变量就叫做函数指针变量，简称函数指针。\n函数指针的定义 下面的语句定义了一个指向函数的指针变量 p。其中 void *表示返回值，(*p) 表示 p 是一个指针变量， (int, float) 是函数的参数列表。\nvoid *(*p) (int, float); 这样我们就得到了一个指针变量 p，它的类型为 void * (*)(int, float)\n所以函数指针的定义方法为：\n函数返回类型 (*指针变量名) (函数参数列表); 这里的函数参数列表类似函数声明，只需写出变量类型即可，并不需要定义变量。\n即下面的俩种写法等价并且第二种写法中定义的变量并没有任何意义，建议使用第一种写法，不要使用第二种写法。\nvoid *(*p) (int, float); void *(*p) (int a, float b); 如何对函数指针赋值 int Func(int x); // 函数的声明  int (*p) (int x); // 函数指针的定义  p = \u0026amp;Func; // 函数指针的赋值 p = Func; // 另一种可行的写法 注：对于俩种赋值写法的详细说明见对函数赋值和调用的一些说明\n函数指针的调用 #include \u0026lt;stdio.h\u0026gt; int max(int a, int b); // 函数声明  int main(int argc, char const *argv[]) { int a = 12; int b = 32; int (*p)(int, int); // 函数指针定义  p = \u0026amp;max; // 函数指针赋值  int c = (*p)(a, b); // 函数指针的调用  printf(\u0026#34;%d\\n\u0026#34;, c); // 输出 `32`  return 0; } // 函数定义 int max(int a, int b) { return a \u0026gt; b ? a : b; } 另一种可行的写法\n#include \u0026lt;stdio.h\u0026gt; int max(int a, int b); // 函数声明  int main(int argc, char const *argv[]) { int a = 12; int b = 32; int (*p)(int, int); // 函数指针定义  p = max; // 函数指针赋值  int c = *p(a, b); // 函数指针的调用  printf(\u0026#34;%d\\n\u0026#34;, c); // 输出 `32`  return 0; } // 函数定义 int max(int a, int b) { return a \u0026gt; b ? a : b; } 注：对于这俩种调用的写法的详细说明见对函数赋值和调用的一些说明\n函数指针中要注意的一些内容  与一般的指针不同，函数指针指向代码而不是数据。通常，一个函数指针存储了可执行代码的起始位置。 与普通指针不同，我们使用函数指针时不需要分配和释放内存。 函数名也可以用来获取函数的地址。（详见对函数赋值和调用的一些说明） 类似普通的指针，我们也有函数指针数组。（详见函数指针数组示例） 函数指针可被用于 switch case 结构中，例如函数指针数组示例中的示例程序中，用户可以通过输入 0 ～ 2 来选择不同的操作。 就像普通数据的指针一样，一个函数指针同样可以被用作函数的参数和返回值，例如函数指针作为参数的示例中的程序中 wrapper() 函数接受 void (*fun)() 作为参数并且执行这个函数。这个特性有很多的应用，你可以在函数指针作为参数的应用中查看更多内容。 C++ 中的许多面向对象特性都是使用 C 中的函数指针实现的，例如虚函数，类方法是使用函数指针实现的另一个示例。  对函数赋值和调用的一些说明 通常，既然是指针赋值，我们会使用取地址操作来获取地址，然后使用 * 运算符调用，但是，对于函数来说，直接使用函数名也可以获得地址。即如下俩种写法等价：\np = \u0026amp;Func; (*p)(2, 3); p = Func; p(2, 3); 编译执行以下程序：\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; int max(int a, int b); int main(int argc, char const *argv[]) { printf(\u0026#34;%p\\n\u0026#34;, (max) ); printf(\u0026#34;%p\\n\u0026#34;, (\u0026amp;max) ); return 0; } int max(int a, int b) { return a \u0026gt; b ? a : b; } 你会发现 (max) (\u0026amp;max) 拥有相同的值，即直接使用函数名也可以获得地址。\n因此，我更推荐第二种没有 \u0026amp; 和 * 的写法，更加直观易用。\n函数指针数组示例 #include \u0026lt;stdio.h\u0026gt; void add(int a, int b) { printf(\u0026#34;Addition is %d\\n\u0026#34;, a + b); } void subtract(int a, int b) { printf(\u0026#34;Subtraction is %d\\n\u0026#34;, a - b); } void multiply(int a, int b) { printf(\u0026#34;Multiplication is %d\\n\u0026#34;, a * b); } int main() { // fun_ptr_arr 是一个函数指针的数组  void (*fun_ptr_arr[])(int, int) = {add, subtract, multiply}; unsigned int ch, a = 15, b = 10; printf(\u0026#34;Enter Choice: 0 for add, 1 for subtract and 2 for multiply\\n\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;ch); if (ch \u0026gt; 2) { return 0; } (*fun_ptr_arr[ch])(a, b); return 0; } 函数指针作为参数的示例 // 一个简单的 C 语言程序来演示使用函数指针作为参数 #include \u0026lt;stdio.h\u0026gt; // 俩个简单的函数 void fun1() { printf(\u0026#34;Fun1\\n\u0026#34;); } void fun2() { printf(\u0026#34;Fun2\\n\u0026#34;); } // 一个接受函数作为参数并在内部执行这个函数的函数 void wrapper(void (*fun)()) { fun(); } int main() { wrapper(fun1); wrapper(fun2); return 0; } 函数指针作为参数的应用 我们可以使用将函数指针作为参数来避免书写重复的代码，例如较为简单的函数 qsort() 可以被用来排序数组或其他任何的自定义结构体。不仅这些，有了函数指针和空指针，使用 qsort() 函数可以对任何数据类型进行排序。\n// 一个关于 qsort 和比较器的定义 #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; // 一个比较器示例函数 // 它被用对一个整数数组进行排序 // 为了对任何其他数据类型或条件的任何数组进行排序 // 我们需要编写更多的比较函数 // 这样我们就可以使用相同的 qsort() int compare(const void *a, const void *b) { return (*(int *)a - *(int *)b); } int main() { int arr[] = {10, 5, 15, 12, 90, 80}; int n = sizeof(arr) / sizeof(arr[0]); qsort(arr, n, sizeof(int), compare); for (int i = 0; i \u0026lt; n; i++) { printf(\u0026#34;%d \u0026#34;, arr[i]); } return 0; } 类似 qsort() 函数，我们可以定义自己的可以用于任何数据类型的函数来处理不同的任务。下面是一个搜索函数的示例，它可以被用于任何数据类型。事实上，我们可以通过写一个专门的比较函数使用这个搜索函数来找到相近的元素（低于某阈值）。\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdbool.h\u0026gt; // 一个被用来对整数数组进行搜索的比较函数 bool compare(const void *a, const void *b) { return (*(int *)a == *(int *)b); } // 可以被用来在一个长度为 arr_size 的数组 arr[] 中 // 搜索元素 *x 的通用 search() 函数。 // 注意这里使用 void 指针，这样函数就可以在调用 // 的时候传入任何类型的参数 // ele_size 是数组元素的大小 int search(void *arr, int arr_size, int ele_size, void *x, bool compare(const void *, const void *)) { // 因为 char 占用一个字节，因此我们使用 char 指针  // 来可以保证用于任何类型的指针运算都正确，我们  // 需要将 index 与元素的大小 ele_size 相乘  char *ptr = (char *)arr; int i; for (i = 0; i \u0026lt; arr_size; i++) if (compare(ptr + i * ele_size, x)) return i; // 如果没有找到元素  return -1; } int main() { int arr[] = {2, 5, 7, 90, 70}; int n = sizeof(arr) / sizeof(arr[0]); int x = 7; printf(\u0026#34;Returned index is %d \u0026#34;, search(arr, n, sizeof(int), \u0026amp;x, compare)); return 0; } 这个函数可以被用于任何类型的数据，只要定义一个比较函数。\n如何使用 typedef 定义函数指针类型 与一般的定义不同，函数指针在使用 typedef 重命名时，新的变量名不是在末尾而是类似函数指针变量定义的写法。\n下面是一个简单的例子：\ntypedef int (*type_name) (const void *, double); 其中 int 为函数返回值类型， const void *, double 是函数接受的参数列表，(*type_name) 表明定义的是一个函数指针，它的类型为 int (*)(const void *, double)，新的类型名为 type_name，你可以使用 type_name 来定义一个类型为 int (*)(const void *, double) 的函数指针。\n也就是说，使用定义函数指针类型的格式如下：\ntypedef 函数返回值类型 (*类型名) (函数参数列表) 接下来看一下 qsort() 函数的源代码：\n首先是函数 qsort() 的声明：\nextern void qsort (void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar) __nonnull ((1, 4)); 这里有一个新的数据类型 __compar_fn_t，我们知道它是一个函数指针，我们找一下它的定义：\ntypedef int (*__compar_fn_t) (const void *, const void *); 上例中 search() 函数可以这样定义：\n// 类型定义 typedef bool (*compare_fun)(const void *, const void *); // 函数声明 int search(void *arr, int arr_size, int ele_size, void *x, compare_fun compare);  建议阅读： https://www.geeksforgeeks.org/function-pointer-in-c/\n","permalink":"https://aimerneige.com/zh/post/c-function-point/","summary":"函数指针在大型的 C 语言项目中十分重要，但是学校对它的介绍一带而过，国内一些介绍函数指针的文章十分粗浅甚至存在错误（这里就不点名了），因此博主写了这篇文章介绍函数指针，希望能够帮助一些 C 语言学习者。\n文章部分内容翻译引用于 https://www.geeksforgeeks.org/function-pointer-in-c/\n函数指针的概念 类似变量，函数也会被分配一段存储空间，这段存储空间的首地址即被称做这个函数的地址。而且函数名表示的就是这个地址。既然是地址，我们就可以定义一个指针变量来存放，这个指针变量就叫做函数指针变量，简称函数指针。\n函数指针的定义 下面的语句定义了一个指向函数的指针变量 p。其中 void *表示返回值，(*p) 表示 p 是一个指针变量， (int, float) 是函数的参数列表。\nvoid *(*p) (int, float); 这样我们就得到了一个指针变量 p，它的类型为 void * (*)(int, float)\n所以函数指针的定义方法为：\n函数返回类型 (*指针变量名) (函数参数列表); 这里的函数参数列表类似函数声明，只需写出变量类型即可，并不需要定义变量。\n即下面的俩种写法等价并且第二种写法中定义的变量并没有任何意义，建议使用第一种写法，不要使用第二种写法。\nvoid *(*p) (int, float); void *(*p) (int a, float b); 如何对函数指针赋值 int Func(int x); // 函数的声明  int (*p) (int x); // 函数指针的定义  p = \u0026amp;Func; // 函数指针的赋值 p = Func; // 另一种可行的写法 注：对于俩种赋值写法的详细说明见对函数赋值和调用的一些说明","title":"C 函数指针"},{"content":"          thread 线程 有共享内存   process 进程 没有共享内存    gcc file.c -lpthread 创建线程\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;pthread.h\u0026gt; void *myfunc(void *args) { for (int i = 0; i \u0026lt; 50; i++) { printf(\u0026#34;%d\\n\u0026#34;, i); } return NULL; } int main() { pthread_t th1; pthread_t th2; pthread_create(\u0026amp;th1, NULL, myfunc, NULL); pthread_create(\u0026amp;th2, NULL, myfunc, NULL); pthread_join(th1, NULL); pthread_join(th2, NULL); return 0; } 传入参数\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;pthread.h\u0026gt; void *myfunc(void *args) { char *name = (char *)args; for (int i = 0; i \u0026lt; 50; i++) { printf(\u0026#34;%s %d\\n\u0026#34;, name, i); } return NULL; } int main() { pthread_t th1; pthread_t th2; pthread_create(\u0026amp;th1, NULL, myfunc, \u0026#34;th1\u0026#34;); pthread_create(\u0026amp;th2, NULL, myfunc, \u0026#34;th2\u0026#34;); pthread_join(th1, NULL); pthread_join(th2, NULL); return 0; } 分部计算\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;pthread.h\u0026gt; int arr[5000]; int s1 = 0; int s2 = 0; void *myfunc1(void *args) { for (int i = 0; i \u0026lt; 2500; i++) { s1 += arr[i]; } return NULL; } void *myfunc2(void *args) { for (int i = 2500; i \u0026lt; 5000; i++) { s2 += arr[i]; } return NULL; } int main() { for (int i = 0; i \u0026lt; 5000; i++) { arr[i] = rand() % 50; } pthread_t th1; pthread_t th2; pthread_create(\u0026amp;th1, NULL, myfunc1, NULL); pthread_create(\u0026amp;th2, NULL, myfunc2, NULL); pthread_join(th1, NULL); pthread_join(th2, NULL); int S = s1 + s2; printf(\u0026#34;Result: %d\\n\u0026#34;, S); return 0; } 单参数的写法\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;pthread.h\u0026gt; int arr[5000]; int s1 = 0; int s2 = 0; void *myfunc(void *args) { int a = 0 [(int *)args]; if (a == 1) { for (int i = 0; i \u0026lt; 2500; i++) { s1 += arr[i]; } } else { for (int i = 2500; i \u0026lt; 5000; i++) { s2 += arr[i]; } } return NULL; } int main() { for (int i = 0; i \u0026lt; 5000; i++) { arr[i] = rand() % 50; } pthread_t th1; pthread_t th2; pthread_create(\u0026amp;th1, NULL, myfunc, (int []){1}); pthread_create(\u0026amp;th2, NULL, myfunc, (int []){2}); pthread_join(th1, NULL); pthread_join(th2, NULL); int S = s1 + s2; printf(\u0026#34;Result: %d\\n\u0026#34;, S); return 0; } 传入结构体\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;pthread.h\u0026gt; typedef struct { int first; int last; } MY_ARGS; int arr[5000]; int s1 = 0; int s2 = 0; void *myfunc(void *args) { MY_ARGS *arg = (MY_ARGS *)args; for (int i = arg-\u0026gt;first; i \u0026lt; arg-\u0026gt;last; i++) { s1 += arr[i]; } return NULL; } int main() { for (int i = 0; i \u0026lt; 5000; i++) { arr[i] = rand() % 50; } pthread_t th1; pthread_t th2; MY_ARGS args_1 = {0, 2500}; MY_ARGS args_2 = {2500, 5000}; pthread_create(\u0026amp;th1, NULL, myfunc, \u0026amp;args_1); pthread_create(\u0026amp;th2, NULL, myfunc, \u0026amp;args_2); pthread_join(th1, NULL); pthread_join(th2, NULL); int S = s1 + s2; printf(\u0026#34;Result: %d\\n\u0026#34;, S); return 0; } 结构体的更多参数\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;pthread.h\u0026gt; typedef struct { int first; int last; int result; } MY_ARGS; int arr[5000]; void *myfunc(void *args) { MY_ARGS *arg = (MY_ARGS *)args; for (int i = arg-\u0026gt;first; i \u0026lt; arg-\u0026gt;last; i++) { arg-\u0026gt;result += arr[i]; } return NULL; } int main() { for (int i = 0; i \u0026lt; 5000; i++) { arr[i] = rand() % 50; } pthread_t th1; pthread_t th2; MY_ARGS args_1 = {0, 2500, 0}; MY_ARGS args_2 = {2500, 5000, 1}; pthread_create(\u0026amp;th1, NULL, myfunc, \u0026amp;args_1); pthread_create(\u0026amp;th2, NULL, myfunc, \u0026amp;args_2); pthread_join(th1, NULL); pthread_join(th2, NULL); int S = args_1.result + args_2.result; printf(\u0026#34;Result: %d\\n\u0026#34;, S); return 0; } 一些错误的写法\n它会造成 race condition\n// dangerous operation #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;pthread.h\u0026gt; int a = 0; void *myfunc(void *args) { for (int i = 0; i \u0026lt; 1000000; i++) { a++; } return NULL; } int main() { pthread_t pt1; pthread_t pt2; pthread_create(\u0026amp;pt1, NULL, myfunc, NULL); pthread_create(\u0026amp;pt2, NULL, myfunc, NULL); pthread_join(pt1, NULL); pthread_join(pt2, NULL); printf(\u0026#34;%d\\n\u0026#34;, a); return 0; } 加锁\n// in this way, it is slow #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;pthread.h\u0026gt; #define MAX_SIZE 5000000  pthread_mutex_t lock; int a = 0; void *myfunc(void *args) { for (int i = 0; i \u0026lt; 100000; i++) { pthread_mutex_lock(\u0026amp;lock); a++; pthread_mutex_unlock(\u0026amp;lock); } return NULL; } int main() { pthread_t pt1; pthread_t pt2; pthread_mutex_init(\u0026amp;lock, NULL); pthread_create(\u0026amp;pt1, NULL, myfunc, NULL); pthread_create(\u0026amp;pt2, NULL, myfunc, NULL); pthread_join(pt1, NULL); pthread_join(pt2, NULL); printf(\u0026#34;%d\\n\u0026#34;, a); return 0; } 较为完整的写法\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;pthread.h\u0026gt; #define ZERO 0 #define HALF 2500000 #define MAX_SIZE 5000000  typedef struct { int first; int last; int id; } MY_ARGS; int *arr; int result[2]; void *myfunc(void *args) { MY_ARGS *arg = (MY_ARGS *)args; for (int i = arg-\u0026gt;first; i \u0026lt; arg-\u0026gt;last; i++) { result[arg-\u0026gt;id] += arr[i]; } return NULL; } int main() { arr = (int *)malloc(sizeof(int) * MAX_SIZE); for (int i = 0; i \u0026lt; MAX_SIZE; i++) { arr[i] = rand() % 5; } result[0] = 0; result[1] = 0; pthread_t th1; pthread_t th2; MY_ARGS args_1 = {ZERO, HALF, 0}; MY_ARGS args_2 = {HALF, MAX_SIZE, 1}; pthread_create(\u0026amp;th1, NULL, myfunc, \u0026amp;args_1); pthread_create(\u0026amp;th2, NULL, myfunc, \u0026amp;args_2); pthread_join(th1, NULL); pthread_join(th2, NULL); int S = result[0] + result[1]; printf(\u0026#34;Result: %d\\n\u0026#34;, S); return 0; } ","permalink":"https://aimerneige.com/zh/post/c-thread-basic/","summary":"thread 线程 有共享内存   process 进程 没有共享内存    gcc file.c -lpthread 创建线程\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;pthread.h\u0026gt; void *myfunc(void *args) { for (int i = 0; i \u0026lt; 50; i++) { printf(\u0026#34;%d\\n\u0026#34;, i); } return NULL; } int main() { pthread_t th1; pthread_t th2; pthread_create(\u0026amp;th1, NULL, myfunc, NULL); pthread_create(\u0026amp;th2, NULL, myfunc, NULL); pthread_join(th1, NULL); pthread_join(th2, NULL); return 0; } 传入参数","title":"C 语言多线程基础"},{"content":"在 C 语言中，函数默认是全局的。在函数前加“static”关键字可以使一个函数变成静态函数。例如，下面的函数 fun() 是静态的：\nstatic int fun(void) { printf(\u0026#34;I am a static funciton.\\n\u0026#34;); } 与 C 语言中的全局函数不同，对静态函数的访问仅限于声明它们的文件。因此，当我们想要限制函数的访问时，我们可以将函数定义为静态的。另外，如果我们想要在其他文件中使用相同的函数名，我们也可以将函数定义为静态的。\n例如，我们在文件 file.c 中存储了下面的程序：\n// in file `file1.c` #include \u0026lt;stdio.h\u0026gt; static void fun1() { printf(\u0026#34;fun1 called.\\n\u0026#34;); } 然后，我们在文件 file2.c 中存储了这样的程序：\n// in file `file2.c` #include \u0026lt;stdio.h\u0026gt; int main(void) { fun1(); return 0; } 接下来，如果我们按照如下的命令编译：\ngcc file2.c file1.c 你会得到这样的链接错误：\nundefined reference to `fun1\u0026#39; 这是因为 fun1() 函数在 file1.c 中被定义为静态，因而不能在 file2.c 中引用。\n","permalink":"https://aimerneige.com/zh/post/c-static-function/","summary":"在 C 语言中，函数默认是全局的。在函数前加“static”关键字可以使一个函数变成静态函数。例如，下面的函数 fun() 是静态的：\nstatic int fun(void) { printf(\u0026#34;I am a static funciton.\\n\u0026#34;); } 与 C 语言中的全局函数不同，对静态函数的访问仅限于声明它们的文件。因此，当我们想要限制函数的访问时，我们可以将函数定义为静态的。另外，如果我们想要在其他文件中使用相同的函数名，我们也可以将函数定义为静态的。\n例如，我们在文件 file.c 中存储了下面的程序：\n// in file `file1.c` #include \u0026lt;stdio.h\u0026gt; static void fun1() { printf(\u0026#34;fun1 called.\\n\u0026#34;); } 然后，我们在文件 file2.c 中存储了这样的程序：\n// in file `file2.c` #include \u0026lt;stdio.h\u0026gt; int main(void) { fun1(); return 0; } 接下来，如果我们按照如下的命令编译：\ngcc file2.c file1.c 你会得到这样的链接错误：\nundefined reference to `fun1\u0026#39; 这是因为 fun1() 函数在 file1.c 中被定义为静态，因而不能在 file2.c 中引用。","title":"C 语言静态函数"},{"content":"装修中\u0026hellip;\n各位大佬一定看了 yaml 就可以自动脑补一份完美的 html 吧。。。\n- { title: \u0026#39;伞\u0026#39;, intro: \u0026#39;一只咸鱼的学习记录\u0026#39;, link: \u0026#39;https://farewell12345.github.io/\u0026#39;, github: \u0026#39;https://github.com/farewell12345\u0026#39;, image: \u0026#39;https://avatars.githubusercontent.com/u/53655863?v=4\u0026#39; } - { title: \u0026#39;HelloWorld的小博客\u0026#39;, intro: \u0026#39;这里是一个小白的博客\u0026#39;, link: \u0026#39;https://mzdluo123.github.io/\u0026#39;, github: \u0026#39;https://github.com/mzdluo123\u0026#39;, image: \u0026#39;https://avatars.githubusercontent.com/u/23146087?v=4\u0026#39; } - { title: \u0026#39;TangZ\u0026#39;, intro: \u0026#39;TangZ 的个人页面\u0026#39;, link: \u0026#39;https://wstzj.github.io/\u0026#39;, github: \u0026#39;https://github.com/wstzj\u0026#39;, image: \u0026#39;https://avatars.githubusercontent.com/u/55931768?v=4\u0026#39; } - { title: \u0026#39;Kenvix\u0026#39;, intro: \u0026#39;党明学姐\u0026#39;, link: \u0026#39;https://kenvix.com/\u0026#39;, github: \u0026#39;https://github.com/kenvix\u0026#39;, image: \u0026#39;https://avatars.githubusercontent.com/u/4546175?v=4\u0026#39; } - { title: \u0026#39;HeoLis\u0026#39;, intro: \u0026#39;We need to go faster and deeper.\u0026#39;, link: \u0026#39;http://ishero.net/\u0026#39;, github: \u0026#39;https://github.com/wmpscc\u0026#39;, image: \u0026#39;https://avatars.githubusercontent.com/u/29891793?v=4\u0026#39; } - { title: \u0026#39;🔨\u0026#39;, intro: \u0026#39;🔨のBlog\u0026#39;, link: \u0026#39;https://geekhe-p.github.io/\u0026#39;, github: \u0026#39;https://github.com/geekhe-p\u0026#39;, image: \u0026#39;https://avatars.githubusercontent.com/u/55914926?v=4\u0026#39; } - { title: \u0026#39;异国迷宫的十字路口\u0026#39;, intro: \u0026#39;一位弱鸡带学生的个人博客\u0026#39;, link: \u0026#39;https://blog.fivezha.cn/\u0026#39;, github: \u0026#39;https://github.com/xmmmmmovo\u0026#39;, image: \u0026#39;https://avatars.githubusercontent.com/u/32405482?v=4\u0026#39; } - { title: \u0026#39;Gaein nidb\u0026#39;, intro: \u0026#39;Gaein nidb的网站\u0026#39;, link: \u0026#39;https://www.gaein.cn/\u0026#39;, github: \u0026#39;https://github.com/nidbCN\u0026#39;, image: \u0026#39;https://avatars.githubusercontent.com/u/36162655?v=4\u0026#39; } - { title: \u0026#39;fzf404\u0026#39;, intro: \u0026#39;fzf的网站\u0026#39;, link: \u0026#39;https://fzf404.top/\u0026#39;, github: \u0026#39;https://github.com/fzf404\u0026#39;, image: \u0026#39;https://avatars.githubusercontent.com/u/40832831?v=4\u0026#39; } - { title: \u0026#39;凛凛酱\u0026#39;, intro: \u0026#39;傻逼凛凛\u0026#39;, link: \u0026#39;https://baolong24.github.io/\u0026#39;, github: \u0026#39;https://github.com/baolong24\u0026#39;, image: \u0026#39;https://avatars.githubusercontent.com/u/30337499?v=4\u0026#39; } - { title: \u0026#39;Web-Worker\u0026#39;, intro: \u0026#39;道阻且长,行则将至。\u0026#39;, link: \u0026#39;https://web-worker.cn/\u0026#39;, github: \u0026#39;https://github.com/Star-caorui\u0026#39;, image: \u0026#39;https://avatars.githubusercontent.com/u/51264180?v=4\u0026#39; } - { title: \u0026#39;vritser\u0026#39;, intro: \u0026#39;半斤八两\u0026#39;, link: \u0026#39;https://vritser.github.io/\u0026#39;, github: \u0026#39;https://github.com/vritser\u0026#39;, image: \u0026#39;https://avatars.githubusercontent.com/u/16340478?v=4\u0026#39; } ","permalink":"https://aimerneige.com/zh/friends/","summary":"装修中\u0026hellip;\n各位大佬一定看了 yaml 就可以自动脑补一份完美的 html 吧。。。\n- { title: \u0026#39;伞\u0026#39;, intro: \u0026#39;一只咸鱼的学习记录\u0026#39;, link: \u0026#39;https://farewell12345.github.io/\u0026#39;, github: \u0026#39;https://github.com/farewell12345\u0026#39;, image: \u0026#39;https://avatars.githubusercontent.com/u/53655863?v=4\u0026#39; } - { title: \u0026#39;HelloWorld的小博客\u0026#39;, intro: \u0026#39;这里是一个小白的博客\u0026#39;, link: \u0026#39;https://mzdluo123.github.io/\u0026#39;, github: \u0026#39;https://github.com/mzdluo123\u0026#39;, image: \u0026#39;https://avatars.githubusercontent.com/u/23146087?v=4\u0026#39; } - { title: \u0026#39;TangZ\u0026#39;, intro: \u0026#39;TangZ 的个人页面\u0026#39;, link: \u0026#39;https://wstzj.github.io/\u0026#39;, github: \u0026#39;https://github.com/wstzj\u0026#39;, image: \u0026#39;https://avatars.githubusercontent.com/u/55931768?v=4\u0026#39; } - { title: \u0026#39;Kenvix\u0026#39;, intro: \u0026#39;党明学姐\u0026#39;, link: \u0026#39;https://kenvix.com/\u0026#39;, github: \u0026#39;https://github.com/kenvix\u0026#39;, image: \u0026#39;https://avatars.githubusercontent.com/u/4546175?v=4\u0026#39; } - { title: \u0026#39;HeoLis\u0026#39;, intro: \u0026#39;We need to go faster and deeper.","title":"Friends"},{"content":" 中北大学学生，学习物联网专业。Linux 用户，热爱开源和分享。\n 技能  使用的编程语言，软件和服务\n  golang python JavaScript vala Linux git mysql  工具  neovim VSCode VirtualBox Dbeaver Joplin Spotify  语言  中文 英语  教育  中北大学 宁武县高级中学 宁武一中  联系我 GitHub: https://github.com/AimerNeige/\n邮件: aimer.neige@aimerneige.com\n电报: @AimerNeige\n域名: aimerneige.com neige.icu\n","permalink":"https://aimerneige.com/zh/about/","summary":"中北大学学生，学习物联网专业。Linux 用户，热爱开源和分享。\n 技能  使用的编程语言，软件和服务\n  golang python JavaScript vala Linux git mysql  工具  neovim VSCode VirtualBox Dbeaver Joplin Spotify  语言  中文 英语  教育  中北大学 宁武县高级中学 宁武一中  联系我 GitHub: https://github.com/AimerNeige/\n邮件: aimer.neige@aimerneige.com\n电报: @AimerNeige\n域名: aimerneige.com neige.icu","title":"关于我 👨‍💻"}]